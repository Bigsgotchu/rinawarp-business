[{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/admin/feedback/add.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":4,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":4,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":20,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":27,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":9}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const onRequestPost = async ({ request, env }) => {\n  const data = await request.json().catch(() => null);\n  if (!data || !data.message) {\n    return new Response('Missing message', { status: 400 });\n  }\n\n  const id = cryptoRandom();\n  const now = Date.now();\n  const email = data.email || '';\n  const source = data.source || 'unknown';\n  const msg = data.message;\n\n  await env.RINAWARP_DB.prepare(\n    `INSERT INTO feedback (id, email, message, source, created_at)\n       VALUES (?, ?, ?, ?, ?)`,\n  )\n    .bind(id, email, msg, source, now)\n    .run();\n\n  return new Response(JSON.stringify({ ok: true }), {\n    headers: { 'Content-Type': 'application/json' },\n  });\n};\n\nfunction cryptoRandom() {\n  const arr = new Uint8Array(8);\n  crypto.getRandomValues(arr);\n  return [...arr].map((b) => b.toString(16).padStart(2, '0')).join('');\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/admin/feedback/export.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":5,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":23,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":23,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { requireAdmin } from '../../../../lib/auth';\n\nexport const onRequestGet = async ({ request, env }) => {\n  const auth = await requireAdmin(request, env);\n  if (!auth.ok) return new Response(auth.error, { status: auth.status });\n\n  const rows = await env.RINAWARP_DB.prepare(\n    `\n    SELECT id, email, message, source, created_at\n    FROM feedback\n    ORDER BY created_at DESC\n  `,\n  ).all();\n\n  const csv = [\n    'id,email,message,source,created_at',\n    ...rows.results.map(\n      (r) =>\n        `\"${r.id}\",\"${r.email}\",\"${r.message.replace(/\"/g, '\"\"')}\",\"${r.source}\",${r.created_at}`,\n    ),\n  ].join('\\n');\n\n  return new Response(csv, {\n    headers: {\n      'Content-Type': 'text/csv',\n      'Content-Disposition': 'attachment; filename=feedback.csv',\n    },\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/admin/feedback/list.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":5,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":14,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { requireAdmin } from '../../lib/auth';\n\nexport const onRequestGet = async ({ request, env }) => {\n  const auth = await requireAdmin(request, env);\n  if (!auth.ok) return new Response(auth.error, { status: auth.status });\n\n  const rows = await env.RINAWARP_DB.prepare(\n    `SELECT id, email, message, source, created_at\n     FROM feedback\n     ORDER BY created_at DESC\n     LIMIT 100`,\n  ).all();\n\n  return new Response(JSON.stringify({ ok: true, feedback: rows.results }), {\n    headers: { 'Content-Type': 'application/json' },\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/admin/licenses/export.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":5,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":22,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { requireAdmin } from '../../../../lib/auth';\n\nexport const onRequestGet = async ({ request, env }) => {\n  const auth = await requireAdmin(request, env);\n  if (!auth.ok) return new Response(auth.error, { status: auth.status });\n\n  const rows = await env.RINAWARP_DB.prepare(\n    `\n    SELECT id, email, name, plan, status, created_at\n    FROM licenses\n    ORDER BY created_at DESC\n  `,\n  ).all();\n\n  const csv = [\n    'license_key,email,name,plan,status,created_at',\n    ...rows.results.map(\n      (r) => `\"${r.id}\",\"${r.email}\",\"${r.name}\",\"${r.plan}\",\"${r.status}\",${r.created_at}`,\n    ),\n  ].join('\\n');\n\n  return new Response(csv, {\n    headers: {\n      'Content-Type': 'text/csv',\n      'Content-Disposition': 'attachment; filename=licenses.csv',\n    },\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/admin/licenses/list.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":5,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":14,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { requireAdmin } from '../../lib/auth';\n\nexport const onRequestGet = async ({ request, env }) => {\n  const auth = await requireAdmin(request, env);\n  if (!auth.ok) return new Response(auth.error, { status: auth.status });\n\n  const rows = await env.RINAWARP_DB.prepare(\n    `SELECT id, email, name, plan, status, created_at\n     FROM licenses\n     ORDER BY created_at DESC\n     LIMIT 200`,\n  ).all();\n\n  return new Response(JSON.stringify({ ok: true, licenses: rows.results }), {\n    headers: { 'Content-Type': 'application/json' },\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/admin/stats.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":5,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":35,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { requireAdmin } from '../../lib/auth';\n\nexport const onRequestGet = async ({ request, env }) => {\n  const auth = await requireAdmin(request, env);\n  if (!auth.ok) return new Response(auth.error, { status: auth.status });\n\n  // Total licenses\n  const total = await env.RINAWARP_DB.prepare('SELECT COUNT(*) as count FROM licenses').first();\n\n  // Licenses by plan\n  const byPlan = await env.RINAWARP_DB.prepare(\n    'SELECT plan, COUNT(*) as count FROM licenses GROUP BY plan',\n  ).all();\n\n  // Licenses per day (last 30 days)\n  const byDay = await env.RINAWARP_DB.prepare(\n    `SELECT\n       DATE(datetime(created_at / 1000, 'unixepoch')) as day,\n       COUNT(*) as count\n     FROM licenses\n     WHERE created_at >= strftime('%s','now','-30 days') * 1000\n     GROUP BY day\n     ORDER BY day ASC`,\n  ).all();\n\n  return json({\n    ok: true,\n    totalLicenses: total?.count || 0,\n    byPlan: byPlan.results,\n    byDay: byDay.results,\n  });\n};\n\nfunction json(body, status = 200) {\n  return new Response(JSON.stringify(body), {\n    status,\n    headers: { 'Content-Type': 'application/json' },\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/admin/user-analytics.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":9,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":15,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":49,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":69,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":70,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":24}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { requireAdmin } from '../../lib/auth.js';\n\nexport const onRequestGet = async ({ request, env }) => {\n  try {\n    // Check admin authentication\n    const authResult = await requireAdmin(request, env);\n\n    if (!authResult.ok) {\n      return new Response(JSON.stringify({ ok: false, error: authResult.error }), {\n        status: authResult.status,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const url = new URL(request.url);\n    const timeRange = url.searchParams.get('range') || '30d'; // 7d, 30d, 90d, all\n    const filter = url.searchParams.get('filter') || 'all'; // all, active, new, churned\n\n    // Calculate date range\n    const now = new Date();\n    let startDate;\n\n    switch (timeRange) {\n      case '7d':\n        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n        break;\n      case '90d':\n        startDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);\n        break;\n      case 'all':\n        startDate = new Date(0);\n        break;\n      default:\n        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n        break;\n    }\n\n    const startTimestamp = Math.floor(startDate.getTime());\n    const endTimestamp = Math.floor(now.getTime());\n\n    // Get user metrics\n    const [userStats, deviceStats, activityStats, licenseStats] = await Promise.all([\n      getUserStatistics(env, startTimestamp, endTimestamp, filter),\n      getDeviceStatistics(env, startTimestamp, endTimestamp),\n      getActivityStatistics(env, startTimestamp, endTimestamp),\n      getLicenseStatistics(env, startTimestamp, endTimestamp),\n    ]);\n\n    return new Response(\n      JSON.stringify({\n        ok: true,\n        time_range: {\n          start: startDate.toISOString(),\n          end: now.toISOString(),\n          range: timeRange,\n        },\n        user_stats: userStats,\n        device_stats: deviceStats,\n        activity_stats: activityStats,\n        license_stats: licenseStats,\n        generated_at: new Date().toISOString(),\n      }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  } catch (error) {\n    console.error('User analytics error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nasync function getUserStatistics(env, startTimestamp, endTimestamp, filter) {\n  // Total users\n  const totalUsersResult = await env.RINAWARP_DB.prepare(\n    \"SELECT COUNT(*) as count FROM users WHERE status = 'active'\",\n  ).first();\n\n  // New users in time range\n  const newUsersResult = await env.RINAWARP_DB.prepare(\n    `SELECT COUNT(*) as count FROM users\n     WHERE status = 'active' AND created_at >= ? AND created_at <= ?`,\n  )\n    .bind(startTimestamp, endTimestamp)\n    .first();\n\n  // Active users (logged in during time range)\n  const activeUsersResult = await env.RINAWARP_DB.prepare(\n    `SELECT COUNT(DISTINCT user_id) as count FROM user_activity\n     WHERE action = 'login' AND created_at >= ? AND created_at <= ?`,\n  )\n    .bind(startTimestamp, endTimestamp)\n    .first();\n\n  // User growth by day\n  const growthByDay = await env.RINAWARP_DB.prepare(\n    `SELECT DATE(created_at / 1000, 'unixepoch') as day,\n            COUNT(*) as count\n     FROM users\n     WHERE status = 'active' AND created_at >= ?\n     GROUP BY day\n     ORDER BY day`,\n  )\n    .bind(startTimestamp)\n    .all();\n\n  // Auth methods distribution\n  const authMethods = await env.RINAWARP_DB.prepare(\n    `SELECT auth_method, COUNT(*) as count\n     FROM users\n     WHERE status = 'active'\n     GROUP BY auth_method`,\n  ).all();\n\n  return {\n    total_users: totalUsersResult.count || 0,\n    new_users: newUsersResult.count || 0,\n    active_users: activeUsersResult.count || 0,\n    growth_by_day: growthByDay.results || [],\n    auth_methods: authMethods.results || [],\n    filter_applied: filter,\n  };\n}\n\nasync function getDeviceStatistics(env, startTimestamp, endTimestamp) {\n  // Total active devices\n  const totalDevicesResult = await env.RINAWARP_DB.prepare(\n    \"SELECT COUNT(*) as count FROM user_devices WHERE status = 'active'\",\n  ).first();\n\n  // New device activations\n  const newDevicesResult = await env.RINAWARP_DB.prepare(\n    `SELECT COUNT(*) as count FROM user_devices\n     WHERE status = 'active' AND created_at >= ? AND created_at <= ?`,\n  )\n    .bind(startTimestamp, endTimestamp)\n    .first();\n\n  // Devices by platform\n  const devicesByPlatform = await env.RINAWARP_DB.prepare(\n    `SELECT os_name, COUNT(*) as count\n     FROM user_devices\n     WHERE status = 'active'\n     GROUP BY os_name\n     ORDER BY count DESC`,\n  ).all();\n\n  // Devices by product\n  const devicesByProduct = await env.RINAWARP_DB.prepare(\n    `SELECT l.plan, COUNT(*) as count\n     FROM user_devices ud\n     JOIN licenses l ON ud.license_id = l.id\n     WHERE ud.status = 'active'\n     GROUP BY l.plan`,\n  ).all();\n\n  return {\n    total_devices: totalDevicesResult.count || 0,\n    new_devices: newDevicesResult.count || 0,\n    devices_by_platform: devicesByPlatform.results || [],\n    devices_by_product: devicesByProduct.results || [],\n  };\n}\n\nasync function getActivityStatistics(env, startTimestamp, endTimestamp) {\n  // Total activity\n  const totalActivityResult = await env.RINAWARP_DB.prepare(\n    `SELECT COUNT(*) as count FROM user_activity\n     WHERE created_at >= ? AND created_at <= ?`,\n  )\n    .bind(startTimestamp, endTimestamp)\n    .first();\n\n  // Activity by type\n  const activityByType = await env.RINAWARP_DB.prepare(\n    `SELECT action, COUNT(*) as count\n     FROM user_activity\n     WHERE created_at >= ? AND created_at <= ?\n     GROUP BY action\n     ORDER BY count DESC`,\n  )\n    .bind(startTimestamp, endTimestamp)\n    .all();\n\n  // Activity timeline\n  const activityTimeline = await env.RINAWARP_DB.prepare(\n    `SELECT DATE(created_at / 1000, 'unixepoch') as day,\n            COUNT(*) as count\n     FROM user_activity\n     WHERE created_at >= ? AND created_at <= ?\n     GROUP BY day\n     ORDER BY day`,\n  )\n    .bind(startTimestamp, endTimestamp)\n    .all();\n\n  return {\n    total_activity: totalActivityResult.count || 0,\n    activity_by_type: activityByType.results || [],\n    activity_timeline: activityTimeline.results || [],\n  };\n}\n\nasync function getLicenseStatistics(env, startTimestamp, endTimestamp) {\n  // Total active licenses\n  const totalLicensesResult = await env.RINAWARP_DB.prepare(\n    \"SELECT COUNT(*) as count FROM licenses WHERE status = 'active'\",\n  ).first();\n\n  // New license activations\n  const newLicensesResult = await env.RINAWARP_DB.prepare(\n    `SELECT COUNT(*) as count FROM licenses\n     WHERE status = 'active' AND created_at >= ? AND created_at <= ?`,\n  )\n    .bind(startTimestamp, endTimestamp)\n    .first();\n\n  // Licenses by plan\n  const licensesByPlan = await env.RINAWARP_DB.prepare(\n    `SELECT plan, COUNT(*) as count\n     FROM licenses\n     WHERE status = 'active'\n     GROUP BY plan`,\n  ).all();\n\n  // License recovery requests\n  const recoveryRequests = await env.RINAWARP_DB.prepare(\n    `SELECT COUNT(*) as count FROM user_activity\n     WHERE action = 'license_recovery_request' AND created_at >= ? AND created_at <= ?`,\n  )\n    .bind(startTimestamp, endTimestamp)\n    .first();\n\n  return {\n    total_licenses: totalLicensesResult.count || 0,\n    new_licenses: newLicensesResult.count || 0,\n    licenses_by_plan: licensesByPlan.results || [],\n    recovery_requests: recoveryRequests.count || 0,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/auth/github.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":10,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":16,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":22,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":36,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":46,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":46,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":50,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":50,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":55,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":55,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":62,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sessionId' is assigned a value but never used.","line":91,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":91,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'expires_at' is assigned a value but never used.","line":91,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":91,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":109,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":109,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":117,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":117,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":118,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":118,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'URLSearchParams' is not defined.","line":131,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":131,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":137,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":155,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":155,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":170,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":37}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { OAUTH_PROVIDERS } from '../../config.js';\nimport {\n  getUserByEmail,\n  createUser,\n  createUserSession,\n  logUserActivity,\n} from '../../lib/user-auth.js';\n\nexport const onRequestGet = async ({ request, env }) => {\n  const url = new URL(request.url);\n  const action = url.searchParams.get('action');\n\n  if (action === 'login') {\n    // Step 1: Redirect to GitHub OAuth\n    const githubAuthUrl = getGitHubAuthUrl(env);\n    return Response.redirect(githubAuthUrl, 302);\n  } else if (action === 'callback') {\n    // Step 2: Handle GitHub OAuth callback\n    return handleGitHubCallback(request, env);\n  }\n\n  return new Response(JSON.stringify({ ok: false, error: 'Invalid OAuth action' }), {\n    status: 400,\n    headers: { 'Content-Type': 'application/json' },\n  });\n};\n\nfunction getGitHubAuthUrl(env) {\n  const config = OAUTH_PROVIDERS.GITHUB;\n  const clientId = env.GITHUB_CLIENT_ID || config.clientId;\n\n  if (!clientId) {\n    throw new Error('GitHub OAuth not configured');\n  }\n\n  const authUrl = new URL('https://github.com/login/oauth/authorize');\n  authUrl.searchParams.set('client_id', clientId);\n  authUrl.searchParams.set('redirect_uri', config.redirectUri);\n  authUrl.searchParams.set('scope', config.scope);\n  authUrl.searchParams.set('state', generateRandomState());\n\n  return authUrl.toString();\n}\n\nfunction generateRandomState() {\n  return crypto.randomUUID();\n}\n\nasync function handleGitHubCallback(request, env) {\n  const url = new URL(request.url);\n  const code = url.searchParams.get('code');\n  const error = url.searchParams.get('error');\n\n  if (error) {\n    return new Response(JSON.stringify({ ok: false, error: `GitHub OAuth error: ${error}` }), {\n      status: 400,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n\n  if (!code) {\n    return new Response(JSON.stringify({ ok: false, error: 'Authorization code missing' }), {\n      status: 400,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n\n  try {\n    // Exchange code for tokens\n    const tokens = await exchangeGitHubCodeForTokens(code, env);\n    const userInfo = await getGitHubUserInfo(tokens.access_token);\n\n    // Get or create user\n    let user = await getUserByEmail(env, userInfo.email);\n\n    if (!user) {\n      user = await createUser(\n        env,\n        userInfo.email,\n        userInfo.name || userInfo.login || '',\n        'oauth_github',\n        'github',\n        userInfo.id.toString(),\n      );\n    }\n\n    // Create user session\n    const ipAddress = request.headers.get('CF-Connecting-IP') || 'unknown';\n    const userAgent = request.headers.get('User-Agent') || 'unknown';\n\n    const { sessionId, expires_at, cookie } = await createUserSession(\n      env,\n      user.id,\n      ipAddress,\n      userAgent,\n    );\n\n    // Log the OAuth login activity\n    await logUserActivity(env, user.id, 'login', null, ipAddress, userAgent, {\n      auth_method: 'oauth_github',\n      provider: 'github',\n      user_agent: userAgent,\n    });\n\n    // Check for redirectTo parameter\n    const redirectTo = url.searchParams.get('redirectTo') || '/portal.html';\n\n    // Return session cookie and redirect\n    return new Response(null, {\n      status: 302,\n      headers: {\n        Location: redirectTo,\n        'Set-Cookie': cookie,\n      },\n    });\n  } catch (error) {\n    console.error('GitHub OAuth error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'OAuth authentication failed' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n}\n\nasync function exchangeGitHubCodeForTokens(code, env) {\n  const config = OAUTH_PROVIDERS.GITHUB;\n  const clientId = env.GITHUB_CLIENT_ID || config.clientId;\n  const clientSecret = env.GITHUB_CLIENT_SECRET || config.clientSecret;\n\n  const tokenUrl = 'https://github.com/login/oauth/access_token';\n  const params = new URLSearchParams();\n  params.append('code', code);\n  params.append('client_id', clientId);\n  params.append('client_secret', clientSecret);\n  params.append('redirect_uri', config.redirectUri);\n\n  const response = await fetch(tokenUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Accept: 'application/json',\n    },\n    body: params,\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json();\n    throw new Error(`Token exchange failed: ${errorData.error}`);\n  }\n\n  return await response.json();\n}\n\nasync function getGitHubUserInfo(accessToken) {\n  const response = await fetch('https://api.github.com/user', {\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      Accept: 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json();\n    throw new Error(`User info fetch failed: ${errorData.error}`);\n  }\n\n  const userData = await response.json();\n\n  // Get user emails to find the primary email\n  const emailsResponse = await fetch('https://api.github.com/user/emails', {\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      Accept: 'application/json',\n    },\n  });\n\n  if (!emailsResponse.ok) {\n    throw new Error('Failed to fetch user emails');\n  }\n\n  const emails = await emailsResponse.json();\n  const primaryEmail =\n    emails.find((e) => e.primary)?.email || `${userData.id}+${userData.login}@github.com`;\n\n  return {\n    id: userData.id,\n    login: userData.login,\n    name: userData.name,\n    email: primaryEmail,\n    avatar_url: userData.avatar_url,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/auth/google.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":10,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":16,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":22,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":36,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":48,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":53,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":60,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sessionId' is assigned a value but never used.","line":89,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'expires_at' is assigned a value but never used.","line":89,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":107,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":107,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":115,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":115,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":116,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":116,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'URLSearchParams' is not defined.","line":129,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":129,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":136,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":153,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":153,"endColumn":31}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { OAUTH_PROVIDERS } from '../../config.js';\nimport {\n  getUserByEmail,\n  createUser,\n  createUserSession,\n  logUserActivity,\n} from '../../lib/user-auth.js';\n\nexport const onRequestGet = async ({ request, env }) => {\n  const url = new URL(request.url);\n  const action = url.searchParams.get('action');\n\n  if (action === 'login') {\n    // Step 1: Redirect to Google OAuth\n    const googleAuthUrl = getGoogleAuthUrl(env);\n    return Response.redirect(googleAuthUrl, 302);\n  } else if (action === 'callback') {\n    // Step 2: Handle Google OAuth callback\n    return handleGoogleCallback(request, env);\n  }\n\n  return new Response(JSON.stringify({ ok: false, error: 'Invalid OAuth action' }), {\n    status: 400,\n    headers: { 'Content-Type': 'application/json' },\n  });\n};\n\nfunction getGoogleAuthUrl(env) {\n  const config = OAUTH_PROVIDERS.GOOGLE;\n  const clientId = env.GOOGLE_CLIENT_ID || config.clientId;\n\n  if (!clientId) {\n    throw new Error('Google OAuth not configured');\n  }\n\n  const authUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth');\n  authUrl.searchParams.set('client_id', clientId);\n  authUrl.searchParams.set('redirect_uri', config.redirectUri);\n  authUrl.searchParams.set('response_type', 'code');\n  authUrl.searchParams.set('scope', config.scope);\n  authUrl.searchParams.set('access_type', 'offline');\n  authUrl.searchParams.set('prompt', 'consent');\n\n  return authUrl.toString();\n}\n\nasync function handleGoogleCallback(request, env) {\n  const url = new URL(request.url);\n  const code = url.searchParams.get('code');\n  const error = url.searchParams.get('error');\n\n  if (error) {\n    return new Response(JSON.stringify({ ok: false, error: `Google OAuth error: ${error}` }), {\n      status: 400,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n\n  if (!code) {\n    return new Response(JSON.stringify({ ok: false, error: 'Authorization code missing' }), {\n      status: 400,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n\n  try {\n    // Exchange code for tokens\n    const tokens = await exchangeGoogleCodeForTokens(code, env);\n    const userInfo = await getGoogleUserInfo(tokens.access_token);\n\n    // Get or create user\n    let user = await getUserByEmail(env, userInfo.email);\n\n    if (!user) {\n      user = await createUser(\n        env,\n        userInfo.email,\n        userInfo.name || '',\n        'oauth_google',\n        'google',\n        userInfo.id,\n      );\n    }\n\n    // Create user session\n    const ipAddress = request.headers.get('CF-Connecting-IP') || 'unknown';\n    const userAgent = request.headers.get('User-Agent') || 'unknown';\n\n    const { sessionId, expires_at, cookie } = await createUserSession(\n      env,\n      user.id,\n      ipAddress,\n      userAgent,\n    );\n\n    // Log the OAuth login activity\n    await logUserActivity(env, user.id, 'login', null, ipAddress, userAgent, {\n      auth_method: 'oauth_google',\n      provider: 'google',\n      user_agent: userAgent,\n    });\n\n    // Check for redirectTo parameter\n    const redirectTo = url.searchParams.get('redirectTo') || '/portal.html';\n\n    // Return session cookie and redirect\n    return new Response(null, {\n      status: 302,\n      headers: {\n        Location: redirectTo,\n        'Set-Cookie': cookie,\n      },\n    });\n  } catch (error) {\n    console.error('Google OAuth error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'OAuth authentication failed' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n}\n\nasync function exchangeGoogleCodeForTokens(code, env) {\n  const config = OAUTH_PROVIDERS.GOOGLE;\n  const clientId = env.GOOGLE_CLIENT_ID || config.clientId;\n  const clientSecret = env.GOOGLE_CLIENT_SECRET || config.clientSecret;\n\n  const tokenUrl = 'https://oauth2.googleapis.com/token';\n  const params = new URLSearchParams();\n  params.append('code', code);\n  params.append('client_id', clientId);\n  params.append('client_secret', clientSecret);\n  params.append('redirect_uri', config.redirectUri);\n  params.append('grant_type', 'authorization_code');\n\n  const response = await fetch(tokenUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: params,\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json();\n    throw new Error(`Token exchange failed: ${errorData.error}`);\n  }\n\n  return await response.json();\n}\n\nasync function getGoogleUserInfo(accessToken) {\n  const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    },\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json();\n    throw new Error(`User info fetch failed: ${errorData.error}`);\n  }\n\n  return await response.json();\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/auth/magic-link.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":21,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":47,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":62,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":75,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":87,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":87,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":104,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":104,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":105,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":105,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":114,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":114,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":118,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":118,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":128,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":128,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sessionId' is assigned a value but never used.","line":146,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":146,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'expires_at' is assigned a value but never used.","line":146,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":146,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":163,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":163,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":172,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":172,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":173,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":173,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":181,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":181,"endColumn":28}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  generateMagicLinkToken,\n  verifyMagicLinkToken,\n  createUserSession,\n  getUserByEmail,\n  createUser,\n} from '../../lib/user-auth.js';\nimport { sendMagicLinkEmail } from '../../lib/email-service.js';\nimport {\n  applyRateLimiting,\n  validateInput,\n  sanitizeInput,\n  setSecurityHeaders,\n} from '../../lib/security.js';\n\nexport const onRequestPost = async ({ request, env }) => {\n  try {\n    // Apply rate limiting\n    const rateLimitResult = await applyRateLimiting(request, env, 'MAGIC_LINK');\n    if (!rateLimitResult.allowed) {\n      return new Response(\n        JSON.stringify({\n          ok: false,\n          error: 'Too many requests',\n          retry_after: rateLimitResult.retryAfter,\n        }),\n        {\n          status: 429,\n          headers: {\n            'Content-Type': 'application/json',\n            'Retry-After': rateLimitResult.retryAfter.toString(),\n          },\n        },\n      );\n    }\n\n    const body = await request.json().catch(() => null);\n    const sanitizedBody = sanitizeInput(body);\n\n    // Validate input\n    const validation = validateInput(sanitizedBody, {\n      email: { required: true, type: 'email' },\n      redirectTo: { required: false, type: 'string' },\n    });\n\n    if (!validation.valid) {\n      return new Response(\n        JSON.stringify({\n          ok: false,\n          error: validation.error,\n        }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    const email = sanitizedBody.email;\n\n    if (!email) {\n      return new Response(JSON.stringify({ ok: false, error: 'Email is required' }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    // Generate magic link token\n    const { token, expires_at, magic_link } = await generateMagicLinkToken(env, email);\n\n    // Send magic link via email\n    const emailResult = await sendMagicLinkEmail(env, email, magic_link);\n\n    if (emailResult.success) {\n      return new Response(\n        JSON.stringify({\n          ok: true,\n          message: 'Magic link sent successfully. Please check your email.',\n        }),\n        {\n          status: 200,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    } else {\n      // Fallback: return the magic link for testing if email fails\n      return new Response(\n        JSON.stringify({\n          ok: true,\n          token,\n          expires_at,\n          magic_link,\n          message:\n            'Magic link generated successfully. Email sending failed, here is your direct link.',\n          email_error: emailResult.error,\n        }),\n        {\n          status: 200,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n  } catch (error) {\n    console.error('Magic link error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nexport const onRequestGet = async ({ request, env }) => {\n  try {\n    const url = new URL(request.url);\n    const token = url.searchParams.get('token');\n\n    if (!token) {\n      return new Response(JSON.stringify({ ok: false, error: 'Token is required' }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    // Verify magic link token\n    const verification = await verifyMagicLinkToken(env, token);\n\n    if (!verification.valid) {\n      return new Response(JSON.stringify({ ok: false, error: 'Invalid or expired token' }), {\n        status: 401,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    // Get or create user\n    let user = await getUserByEmail(env, verification.email);\n\n    if (!user) {\n      // Create new user with magic link auth\n      user = await createUser(env, verification.email, '', 'magic_link');\n    }\n\n    // Create user session\n    const ipAddress = request.headers.get('CF-Connecting-IP') || 'unknown';\n    const userAgent = request.headers.get('User-Agent') || 'unknown';\n\n    const { sessionId, expires_at, cookie } = await createUserSession(\n      env,\n      user.id,\n      ipAddress,\n      userAgent,\n    );\n\n    // Log the login activity\n    await logUserActivity(env, user.id, 'login', null, ipAddress, userAgent, {\n      auth_method: 'magic_link',\n      user_agent: userAgent,\n    });\n\n    // Check for redirectTo parameter from the original request\n    const redirectTo = url.searchParams.get('redirectTo') || '/portal.html';\n\n    // Return session cookie and redirect\n    return new Response(null, {\n      status: 302,\n      headers: {\n        Location: redirectTo,\n        'Set-Cookie': cookie,\n        ...setSecurityHeaders(),\n      },\n    });\n  } catch (error) {\n    console.error('Magic link verification error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nasync function logUserActivity(env, userId, action, licenseId, ipAddress, userAgent, metadata) {\n  const activityId = crypto.randomUUID();\n\n  await env.RINAWARP_DB.prepare(\n    `INSERT INTO user_activity (id, user_id, license_id, action, ip_address, user_agent, metadata, created_at)\n     VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n  )\n    .bind(\n      activityId,\n      userId,\n      licenseId,\n      action,\n      ipAddress,\n      userAgent,\n      JSON.stringify(metadata),\n      Date.now(),\n    )\n    .run();\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/billing/portal.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":5,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":9,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":22,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":32,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":40,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":22}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createBillingPortalSession } from '../../lib/stripe-service.js';\n\nexport const onRequestPost = async ({ request, env }) => {\n  const stripeSecret = env.STRIPE_SECRET_KEY;\n  if (!stripeSecret) return new Response('Missing Stripe key', { status: 500 });\n\n  const body = await request.json().catch(() => null);\n  if (!body || !body.licenseKey) {\n    return new Response('Missing licenseKey', { status: 400 });\n  }\n\n  const licenseKey = body.licenseKey.trim();\n\n  // Look up license to get Stripe customer ID\n  const license = await env.RINAWARP_DB.prepare(\n    'SELECT stripe_customer_id FROM licenses WHERE id = ?',\n  )\n    .bind(licenseKey)\n    .first();\n\n  if (!license || !license.stripe_customer_id) {\n    return new Response('License not found or no customer', { status: 404 });\n  }\n\n  const result = await createBillingPortalSession(\n    env,\n    license.stripe_customer_id,\n    env.STRIPE_PORTAL_RETURN_URL,\n  );\n\n  if (!result.success) {\n    return new Response(JSON.stringify({ ok: false, error: result.error }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n\n  const session = { url: result.url };\n\n  return new Response(JSON.stringify({ url: session.url }), {\n    status: 200,\n    headers: { 'Content-Type': 'application/json' },\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/device/activate.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":9,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":19,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":28,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":45,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":58,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":58,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":90,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":105,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":105,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":136,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":149,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":150,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":163,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":163,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":170,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":184,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":184,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":207,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":207,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":218,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":218,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":219,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":219,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":227,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":227,"endColumn":28}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { requireUserAuth } from '../../lib/user-auth.js';\n\nexport const onRequestPost = async ({ request, env }) => {\n  try {\n    // Check authentication\n    const authResult = await requireUserAuth(request, env);\n\n    if (!authResult.ok) {\n      return new Response(JSON.stringify({ ok: false, error: authResult.error }), {\n        status: authResult.status,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const { user } = authResult;\n    const body = await request.json().catch(() => null);\n\n    if (!body || typeof body !== 'object') {\n      return new Response(JSON.stringify({ ok: false, error: 'Invalid request body' }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const { licenseId, deviceName, deviceType, osName, osVersion, appVersion } = body;\n\n    if (!licenseId) {\n      return new Response(JSON.stringify({ ok: false, error: 'License ID is required' }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    // Verify the license belongs to this user\n    const licenseCheck = await env.RINAWARP_DB.prepare(\n      `SELECT l.id, l.status\n       FROM user_licenses ul\n       JOIN licenses l ON ul.license_id = l.id\n       WHERE ul.user_id = ? AND l.id = ?`,\n    )\n      .bind(user.id, licenseId)\n      .first();\n\n    if (!licenseCheck) {\n      return new Response(\n        JSON.stringify({\n          ok: false,\n          error: 'License not found or not associated with your account',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    if (licenseCheck.status !== 'active') {\n      return new Response(JSON.stringify({ ok: false, error: 'License is not active' }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    // Check if device already exists for this license\n    const existingDevice = await env.RINAWARP_DB.prepare(\n      `SELECT id FROM user_devices\n       WHERE user_id = ? AND license_id = ? AND device_name = ? AND os_name = ?`,\n    )\n      .bind(user.id, licenseId, deviceName || '', osName || '')\n      .first();\n\n    if (existingDevice) {\n      // Update existing device\n      await env.RINAWARP_DB.prepare(\n        `UPDATE user_devices\n         SET last_active_at = ?, app_version = ?, status = ?\n         WHERE id = ?`,\n      )\n        .bind(Date.now(), appVersion || '', 'active', existingDevice.id)\n        .run();\n\n      // Log activity\n      await logUserActivity(env, user.id, 'device_checkin', licenseId, null, null, {\n        device_id: existingDevice.id,\n        device_name: deviceName,\n        os_name: osName,\n        app_version: appVersion,\n      });\n\n      return new Response(\n        JSON.stringify({\n          ok: true,\n          message: 'Device check-in successful',\n          deviceId: existingDevice.id,\n          action: 'updated',\n        }),\n        {\n          status: 200,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    // Create new device\n    const deviceId = crypto.randomUUID();\n    const now = Date.now();\n\n    await env.RINAWARP_DB.prepare(\n      `INSERT INTO user_devices\n       (id, user_id, license_id, device_name, device_type, os_name, os_version, app_version, last_active_at, status, created_at)\n       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,\n    )\n      .bind(\n        deviceId,\n        user.id,\n        licenseId,\n        deviceName || 'Unknown Device',\n        deviceType || 'desktop',\n        osName || 'Unknown',\n        osVersion || '',\n        appVersion || '',\n        now,\n        'active',\n        now,\n      )\n      .run();\n\n    // Log activity\n    await logUserActivity(env, user.id, 'device_activation', licenseId, null, null, {\n      device_id: deviceId,\n      device_name: deviceName,\n      os_name: osName,\n      app_version: appVersion,\n    });\n\n    return new Response(\n      JSON.stringify({\n        ok: true,\n        message: 'Device activated successfully',\n        deviceId,\n        action: 'created',\n      }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  } catch (error) {\n    console.error('Device activation error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nexport const onRequestGet = async ({ request, env }) => {\n  try {\n    // Check authentication\n    const authResult = await requireUserAuth(request, env);\n\n    if (!authResult.ok) {\n      return new Response(JSON.stringify({ ok: false, error: authResult.error }), {\n        status: authResult.status,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const { user } = authResult;\n    const url = new URL(request.url);\n    const licenseId = url.searchParams.get('licenseId');\n\n    // Get devices for user (optionally filtered by license)\n    let devices;\n    if (licenseId) {\n      // Verify license belongs to user\n      const licenseCheck = await env.RINAWARP_DB.prepare(\n        'SELECT 1 FROM user_licenses WHERE user_id = ? AND license_id = ?',\n      )\n        .bind(user.id, licenseId)\n        .first();\n\n      if (!licenseCheck) {\n        return new Response(JSON.stringify({ ok: false, error: 'License not found' }), {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        });\n      }\n\n      devices = await env.RINAWARP_DB.prepare(\n        `SELECT * FROM user_devices\n         WHERE user_id = ? AND license_id = ?\n         ORDER BY last_active_at DESC`,\n      )\n        .bind(user.id, licenseId)\n        .all();\n    } else {\n      devices = await env.RINAWARP_DB.prepare(\n        `SELECT * FROM user_devices\n         WHERE user_id = ?\n         ORDER BY last_active_at DESC`,\n      )\n        .bind(user.id)\n        .all();\n    }\n\n    return new Response(\n      JSON.stringify({\n        ok: true,\n        devices: devices.results || [],\n      }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  } catch (error) {\n    console.error('Get devices error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nasync function logUserActivity(env, userId, action, licenseId, ipAddress, userAgent, metadata) {\n  const activityId = crypto.randomUUID();\n\n  await env.RINAWARP_DB.prepare(\n    `INSERT INTO user_activity (id, user_id, license_id, action, ip_address, user_agent, metadata, created_at)\n     VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n  )\n    .bind(\n      activityId,\n      userId,\n      licenseId,\n      action,\n      ipAddress,\n      userAgent,\n      JSON.stringify(metadata),\n      Date.now(),\n    )\n    .run();\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/download/manager.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":9,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":16,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":30,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":119,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":119,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":134,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":134,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":135,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":135,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":143,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":143,"endColumn":28}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { requireUserAuth } from '../../lib/user-auth.js';\n\nexport const onRequestGet = async ({ request, env }) => {\n  try {\n    // Check authentication\n    const authResult = await requireUserAuth(request, env);\n\n    if (!authResult.ok) {\n      return new Response(JSON.stringify({ ok: false, error: authResult.error }), {\n        status: authResult.status,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const { user } = authResult;\n    const url = new URL(request.url);\n    const platform = url.searchParams.get('platform') || 'all';\n\n    // Get available downloads based on user's licenses\n    const userLicenses = await env.RINAWARP_DB.prepare(\n      `SELECT l.id, l.plan\n       FROM user_licenses ul\n       JOIN licenses l ON ul.license_id = l.id\n       WHERE ul.user_id = ? AND l.status = 'active'`,\n    )\n      .bind(user.id)\n      .all();\n\n    if (!userLicenses.results || userLicenses.results.length === 0) {\n      return new Response(\n        JSON.stringify({\n          ok: false,\n          error: 'No active licenses found. Please purchase a license to access downloads.',\n        }),\n        {\n          status: 403,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    // Determine available downloads based on licenses\n    const availableDownloads = [];\n\n    // Terminal Pro downloads\n    const hasTerminalPro = userLicenses.results.some((l) => l.plan.includes('terminal-pro'));\n    if (hasTerminalPro) {\n      if (platform === 'all' || platform === 'windows') {\n        availableDownloads.push({\n          product: 'Terminal Pro',\n          platform: 'windows',\n          version: '0.9.0',\n          download_url: '/downloads/RinaWarp-Terminal-Pro-Windows.exe',\n          file_size: '45.2 MB',\n          release_date: '2025-11-15',\n          requirements: 'Windows 10/11',\n        });\n      }\n\n      if (platform === 'all' || platform === 'mac') {\n        availableDownloads.push({\n          product: 'Terminal Pro',\n          platform: 'mac',\n          version: '0.9.0',\n          download_url: '/downloads/RinaWarp-Terminal-Pro-Mac.dmg',\n          file_size: '38.7 MB',\n          release_date: '2025-11-15',\n          requirements: 'macOS 12+',\n        });\n      }\n\n      if (platform === 'all' || platform === 'linux') {\n        availableDownloads.push({\n          product: 'Terminal Pro',\n          platform: 'linux',\n          version: '0.9.0',\n          download_url: '/downloads/RinaWarp-Terminal-Pro-Linux.AppImage',\n          file_size: '32.1 MB',\n          release_date: '2025-11-15',\n          requirements: 'Most Linux distributions',\n        });\n      }\n    }\n\n    // Music Video Creator downloads (future product)\n    const hasMusicVideoCreator = userLicenses.results.some((l) => l.plan.includes('music-video'));\n    if (hasMusicVideoCreator) {\n      if (platform === 'all' || platform === 'windows') {\n        availableDownloads.push({\n          product: 'Music Video Creator',\n          platform: 'windows',\n          version: '1.0.0-beta',\n          download_url: '/downloads/RinaWarp-Music-Video-Creator-Windows.exe',\n          file_size: '120.5 MB',\n          release_date: '2025-12-01',\n          requirements: 'Windows 10/11 with GPU',\n        });\n      }\n\n      if (platform === 'all' || platform === 'mac') {\n        availableDownloads.push({\n          product: 'Music Video Creator',\n          platform: 'mac',\n          version: '1.0.0-beta',\n          download_url: '/downloads/RinaWarp-Music-Video-Creator-Mac.dmg',\n          file_size: '98.3 MB',\n          release_date: '2025-12-01',\n          requirements: 'macOS 13+ with GPU',\n        });\n      }\n    }\n\n    // Log the download access\n    await logUserActivity(env, user.id, 'download_access', null, null, null, {\n      platform,\n      available_downloads: availableDownloads.length,\n    });\n\n    return new Response(\n      JSON.stringify({\n        ok: true,\n        downloads: availableDownloads,\n        user_licenses: userLicenses.results.map((l) => ({\n          id: l.id,\n          plan: l.plan,\n        })),\n      }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  } catch (error) {\n    console.error('Download manager error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nasync function logUserActivity(env, userId, action, licenseId, ipAddress, userAgent, metadata) {\n  const activityId = crypto.randomUUID();\n\n  await env.RINAWARP_DB.prepare(\n    `INSERT INTO user_activity (id, user_id, license_id, action, ip_address, user_agent, metadata, created_at)\n     VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n  )\n    .bind(\n      activityId,\n      userId,\n      licenseId,\n      action,\n      ipAddress,\n      userAgent,\n      JSON.stringify(metadata),\n      Date.now(),\n    )\n    .run();\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/license-activate.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'validateDeviceFingerprint' is defined but never used.","line":1,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":11,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":26,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":40,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":57,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":91,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":106,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":106,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":113,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":113,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":157,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":157,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":172,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":172,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":173,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":173,"endColumn":24}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createLicenseBlob, validateDeviceFingerprint } from '../lib/license-service.js';\n\nexport const onRequestPost = async ({ request, env }) => {\n  try {\n    const body = await request.json();\n    const { licenseKey, deviceFingerprint, deviceName, deviceType, osName, osVersion, appVersion } =\n      body;\n\n    // Validate required fields\n    if (!licenseKey || !deviceFingerprint) {\n      return new Response(\n        JSON.stringify({\n          ok: false,\n          error: 'License key and device fingerprint are required',\n        }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    // Get license from cache or database\n    const license = await getLicense(env, licenseKey);\n    if (!license) {\n      return new Response(\n        JSON.stringify({\n          ok: false,\n          error: 'Invalid license key',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    // Validate license is active\n    if (license.status !== 'active') {\n      return new Response(\n        JSON.stringify({\n          ok: false,\n          error: `License is ${license.status}`,\n        }),\n        {\n          status: 403,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    const userId = license.user_id;\n\n    // Get current entitlements for this user\n    const entitlements = await getUserEntitlements(env, userId);\n    if (!entitlements) {\n      return new Response(\n        JSON.stringify({\n          ok: false,\n          error: 'User entitlements not found',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    // Check if this device is already activated\n    let deviceActivation = await getDeviceActivation(env, userId, deviceFingerprint);\n\n    if (deviceActivation) {\n      // Update existing device activation\n      await updateDeviceActivation(env, deviceActivation.id, {\n        deviceName,\n        deviceType,\n        osName,\n        osVersion,\n        appVersion,\n      });\n\n      // Generate new license blob with updated timestamp\n      const licenseBlob = await createLicenseBlob(env, {\n        userId,\n        licenseKey,\n        entitlements,\n        deviceFingerprint,\n        expiresAt: getExpirationTime(entitlements),\n      });\n\n      return new Response(\n        JSON.stringify({\n          ok: true,\n          licenseBlob,\n          entitlements,\n          deviceId: deviceActivation.id,\n          message: 'Device re-activated successfully',\n        }),\n        {\n          status: 200,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    } else {\n      // Create new device activation\n      const deviceId = crypto.randomUUID();\n\n      // Check device limit (e.g., max 3 devices per license)\n      const deviceCount = await getDeviceCount(env, userId);\n      const maxDevices = 3; // Configurable limit\n\n      if (deviceCount >= maxDevices) {\n        return new Response(\n          JSON.stringify({\n            ok: false,\n            error: `Device limit reached (${maxDevices} devices)`,\n          }),\n          {\n            status: 403,\n            headers: { 'Content-Type': 'application/json' },\n          },\n        );\n      }\n\n      // Create new device activation\n      await env.RINAWARP_DB.prepare(\n        `\n        INSERT INTO device_activations \n        (id, user_id, license_id, device_fingerprint, device_name, device_type, os_name, os_version, app_version, last_validated_at, created_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `,\n      )\n        .bind(\n          deviceId,\n          userId,\n          licenseKey,\n          deviceFingerprint,\n          deviceName || 'Unknown Device',\n          deviceType || 'desktop',\n          osName || 'Unknown',\n          osVersion || '',\n          appVersion || '',\n          Date.now(),\n          Date.now(),\n        )\n        .run();\n\n      // Generate license blob\n      const licenseBlob = await createLicenseBlob(env, {\n        userId,\n        licenseKey,\n        entitlements,\n        deviceFingerprint,\n        expiresAt: getExpirationTime(entitlements),\n      });\n\n      return new Response(\n        JSON.stringify({\n          ok: true,\n          licenseBlob,\n          entitlements,\n          deviceId,\n          message: 'Device activated successfully',\n        }),\n        {\n          status: 200,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n  } catch (error) {\n    console.error('License activation error:', error);\n    return new Response(\n      JSON.stringify({\n        ok: false,\n        error: 'Internal server error',\n      }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  }\n};\n\nasync function getLicense(env, licenseKey) {\n  // Try cache first\n  const cacheKey = `license:${licenseKey}`;\n  let license = await env.LICENSES.get(cacheKey, 'json');\n\n  if (!license) {\n    // Fallback to database\n    const result = await env.RINAWARP_DB.prepare(\n      `\n      SELECT * FROM licenses WHERE id = ? AND status = 'active'\n    `,\n    )\n      .bind(licenseKey)\n      .first();\n\n    if (result) {\n      license = {\n        license_key: result.id,\n        user_id: result.user_id,\n        plan: result.plan,\n        status: result.status,\n        created_at: result.created_at,\n      };\n\n      // Cache it\n      await env.LICENSES.put(cacheKey, JSON.stringify(license));\n    }\n  }\n\n  return license;\n}\n\nasync function getUserEntitlements(env, userId) {\n  // Try cache first\n  const cacheKey = `user:${userId}:entitlements`;\n  let entitlements = await env.LICENSES.get(cacheKey, 'json');\n\n  if (!entitlements) {\n    // Fallback to database\n    const result = await env.RINAWARP_DB.prepare(\n      `\n      SELECT * FROM entitlements WHERE user_id = ?\n    `,\n    )\n      .bind(userId)\n      .first();\n\n    if (result) {\n      entitlements = {\n        terminal_pro_lifetime: result.terminal_pro_lifetime === 1,\n        agent_pro_status: result.agent_pro_status,\n        agent_pro_ends_at: result.agent_pro_ends_at,\n        agent_memory: result.agent_memory === 1,\n        ghost_text: result.ghost_text === 1,\n        tool_registry_level: result.tool_registry_level,\n        ai_cloud: result.ai_cloud === 1,\n        grace_period_ends_at: result.grace_period_ends_at,\n        updated_at: result.updated_at,\n      };\n\n      // Cache it\n      await env.LICENSES.put(cacheKey, JSON.stringify(entitlements));\n    }\n  }\n\n  return entitlements;\n}\n\nasync function getDeviceActivation(env, userId, deviceFingerprint) {\n  return await env.RINAWARP_DB.prepare(\n    `\n    SELECT * FROM device_activations \n    WHERE user_id = ? AND device_fingerprint = ?\n    ORDER BY last_validated_at DESC \n    LIMIT 1\n  `,\n  )\n    .bind(userId, deviceFingerprint)\n    .first();\n}\n\nasync function updateDeviceActivation(env, deviceId, updates) {\n  await env.RINAWARP_DB.prepare(\n    `\n    UPDATE device_activations \n    SET device_name = ?, device_type = ?, os_name = ?, os_version = ?, app_version = ?, last_validated_at = ?\n    WHERE id = ?\n  `,\n  )\n    .bind(\n      updates.deviceName,\n      updates.deviceType,\n      updates.osName,\n      updates.osVersion,\n      updates.appVersion,\n      Date.now(),\n      deviceId,\n    )\n    .run();\n}\n\nasync function getDeviceCount(env, userId) {\n  const result = await env.RINAWARP_DB.prepare(\n    `\n    SELECT COUNT(*) as count FROM device_activations WHERE user_id = ?\n  `,\n  )\n    .bind(userId)\n    .first();\n\n  return result?.count || 0;\n}\n\nfunction getExpirationTime(entitlements) {\n  // For lifetime licenses, return null (no expiration)\n  if (entitlements.terminal_pro_lifetime) {\n    return null;\n  }\n\n  // For subscription licenses, use the subscription end time\n  if (entitlements.agent_pro_ends_at) {\n    return entitlements.agent_pro_ends_at;\n  }\n\n  // Default: 7 days offline grace period\n  return Date.now() + 7 * 24 * 60 * 60 * 1000;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/license/manage.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":9,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'url' is assigned a value but never used.","line":16,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":16,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":30,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":42,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":43,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":43,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":56,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":66,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":75,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":95,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":95,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":126,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":126,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":141,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":141,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":155,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":155,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":161,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":161,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":174,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":174,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":175,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":175,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":183,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":183,"endColumn":28}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { requireUserAuth } from '../../lib/user-auth.js';\n\nexport const onRequestGet = async ({ request, env }) => {\n  try {\n    // Check authentication\n    const authResult = await requireUserAuth(request, env);\n\n    if (!authResult.ok) {\n      return new Response(JSON.stringify({ ok: false, error: authResult.error }), {\n        status: authResult.status,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const { user } = authResult;\n    const url = new URL(request.url);\n\n    // Get all licenses for this user\n    const licenses = await env.RINAWARP_DB.prepare(\n      `SELECT l.id, l.email, l.name, l.plan, l.status, l.created_at,\n              ul.is_primary\n       FROM user_licenses ul\n       JOIN licenses l ON ul.license_id = l.id\n       WHERE ul.user_id = ?\n       ORDER BY ul.is_primary DESC, l.created_at DESC`,\n    )\n      .bind(user.id)\n      .all();\n\n    return new Response(\n      JSON.stringify({\n        ok: true,\n        user_id: user.id,\n        licenses: licenses.results || [],\n      }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  } catch (error) {\n    console.error('License management error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nexport const onRequestPost = async ({ request, env }) => {\n  try {\n    // Check authentication\n    const authResult = await requireUserAuth(request, env);\n\n    if (!authResult.ok) {\n      return new Response(JSON.stringify({ ok: false, error: authResult.error }), {\n        status: authResult.status,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const { user } = authResult;\n    const body = await request.json().catch(() => null);\n\n    if (!body || typeof body !== 'object') {\n      return new Response(JSON.stringify({ ok: false, error: 'Invalid request body' }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const { licenseId, action } = body;\n\n    if (!licenseId || !action) {\n      return new Response(\n        JSON.stringify({ ok: false, error: 'License ID and action are required' }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    // Verify the license exists and belongs to this user\n    const licenseCheck = await env.RINAWARP_DB.prepare(\n      `SELECT l.id, l.status, ul.is_primary\n       FROM user_licenses ul\n       JOIN licenses l ON ul.license_id = l.id\n       WHERE ul.user_id = ? AND l.id = ?`,\n    )\n      .bind(user.id, licenseId)\n      .first();\n\n    if (!licenseCheck) {\n      return new Response(\n        JSON.stringify({\n          ok: false,\n          error: 'License not found or not associated with your account',\n        }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    // Handle different actions\n    switch (action) {\n      case 'set_primary':\n        // Set this license as primary\n        await env.RINAWARP_DB.prepare('UPDATE user_licenses SET is_primary = 0 WHERE user_id = ?')\n          .bind(user.id)\n          .run();\n\n        await env.RINAWARP_DB.prepare(\n          'UPDATE user_licenses SET is_primary = 1 WHERE user_id = ? AND license_id = ?',\n        )\n          .bind(user.id, licenseId)\n          .run();\n\n        await logUserActivity(env, user.id, 'set_primary_license', licenseId);\n        break;\n\n      case 'revoke':\n        if (licenseCheck.status !== 'active') {\n          return new Response(JSON.stringify({ ok: false, error: 'License is already revoked' }), {\n            status: 400,\n            headers: { 'Content-Type': 'application/json' },\n          });\n        }\n\n        await env.RINAWARP_DB.prepare(\"UPDATE licenses SET status = 'revoked' WHERE id = ?\")\n          .bind(licenseId)\n          .run();\n\n        await logUserActivity(env, user.id, 'license_revoked', licenseId);\n        break;\n\n      case 'reactivate':\n        if (licenseCheck.status === 'active') {\n          return new Response(JSON.stringify({ ok: false, error: 'License is already active' }), {\n            status: 400,\n            headers: { 'Content-Type': 'application/json' },\n          });\n        }\n\n        await env.RINAWARP_DB.prepare(\"UPDATE licenses SET status = 'active' WHERE id = ?\")\n          .bind(licenseId)\n          .run();\n\n        await logUserActivity(env, user.id, 'license_reactivated', licenseId);\n        break;\n\n      default:\n        return new Response(JSON.stringify({ ok: false, error: 'Invalid action' }), {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        });\n    }\n\n    return new Response(\n      JSON.stringify({\n        ok: true,\n        message: `License ${action} successful`,\n        license_id: licenseId,\n        action,\n      }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  } catch (error) {\n    console.error('License management error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nasync function logUserActivity(env, userId, action, licenseId, metadata = {}) {\n  const activityId = crypto.randomUUID();\n\n  await env.RINAWARP_DB.prepare(\n    `INSERT INTO user_activity (id, user_id, license_id, action, ip_address, user_agent, metadata, created_at)\n     VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n  )\n    .bind(activityId, userId, licenseId, action, null, null, JSON.stringify(metadata), Date.now())\n    .run();\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/license/recover.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sendLicenseRecoveryEmail' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":10,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":20,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":40,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":57,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":76,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":77,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":77,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'env' is defined but never used.","line":84,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":84,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":86,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":86,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":90,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":98,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":98,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":110,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":110,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":111,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":111,"endColumn":24}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getUserByEmail, logUserActivity } from '../../lib/user-auth.js';\nimport { sendLicenseRecoveryEmail } from '../../lib/email-service.js';\n\nexport const onRequestPost = async ({ request, env }) => {\n  try {\n    const body = await request.json().catch(() => null);\n    const email = body?.email?.trim();\n\n    if (!email) {\n      return new Response(JSON.stringify({ ok: false, error: 'Email is required' }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    // Get user by email\n    const user = await getUserByEmail(env, email);\n\n    if (!user) {\n      return new Response(\n        JSON.stringify({ ok: false, error: 'No account found with this email' }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    // Get user's active licenses\n    const licenses = await env.RINAWARP_DB.prepare(\n      `SELECT l.id, l.plan, l.status, l.created_at\n       FROM user_licenses ul\n       JOIN licenses l ON ul.license_id = l.id\n       WHERE ul.user_id = ? AND l.status = 'active'`,\n    )\n      .bind(user.id)\n      .all();\n\n    if (!licenses.results || licenses.results.length === 0) {\n      return new Response(\n        JSON.stringify({ ok: false, error: 'No active licenses found for this account' }),\n        {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    // Log the recovery request\n    await logUserActivity(env, user.id, 'license_recovery_request', null, null, null, {\n      email: email,\n      license_count: licenses.results.length,\n    });\n\n    // In a real implementation, you would send this via email\n    // For now, we'll return the license information for testing\n    return new Response(\n      JSON.stringify({\n        ok: true,\n        message: 'License recovery information generated successfully',\n        email: email,\n        licenses: licenses.results.map((license) => ({\n          id: license.id,\n          plan: license.plan,\n          status: license.status,\n          created_at: license.created_at,\n        })),\n        note: 'In production, this information would be emailed to the user securely.',\n      }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  } catch (error) {\n    console.error('License recovery error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nexport const onRequestGet = async ({ request, env }) => {\n  try {\n    const url = new URL(request.url);\n    const token = url.searchParams.get('token');\n\n    if (!token) {\n      return new Response(JSON.stringify({ ok: false, error: 'Recovery token is required' }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    // In a real implementation, you would verify the token from email\n    // For this example, we'll just return a success message\n    return new Response(\n      JSON.stringify({\n        ok: true,\n        message: 'License recovery token verified successfully',\n        next_steps: 'In a real implementation, this would show the user their license keys',\n      }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  } catch (error) {\n    console.error('License recovery verification error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/license/verify.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":2,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":2,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":45,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const onRequestGet = async ({ request, env }) => {\n  const url = new URL(request.url);\n  const key = url.searchParams.get('key');\n\n  if (!key) {\n    return json({ ok: false, error: 'Missing license key' }, 400);\n  }\n\n  // 1) Check KV cache first\n  const cacheKey = `license:${key}`;\n  let license = await env.LICENSES.get(cacheKey, 'json');\n\n  if (!license) {\n    // 2) Fallback to D1\n    const result = await env.RINAWARP_DB.prepare(\n      'SELECT id, email, name, plan, status, created_at FROM licenses WHERE id = ?',\n    )\n      .bind(key)\n      .first();\n\n    if (!result) {\n      return json({ ok: false, valid: false, reason: 'Not found' }, 404);\n    }\n\n    license = {\n      email: result.email,\n      name: result.name,\n      plan: result.plan,\n      status: result.status,\n      created_at: result.created_at,\n    };\n\n    // Refill KV cache\n    await env.LICENSES.put(cacheKey, JSON.stringify(license));\n  }\n\n  if (license.status !== 'active') {\n    return json({ ok: true, valid: false, status: license.status }, 200);\n  }\n\n  return json({ ok: true, valid: true, data: license }, 200);\n};\n\nfunction json(body, status = 200) {\n  return new Response(JSON.stringify(body), {\n    status,\n    headers: { 'Content-Type': 'application/json' },\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/stripe-webhook-v2.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":16,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'stripe' is assigned a value but never used.","line":19,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":24,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":25,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":38,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":39,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":42,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":51,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":52,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":67,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":70,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":71,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":73,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":74,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":24}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  getStripeInstance,\n  verifyWebhookSignature,\n  handleStripeEvent,\n} from '../lib/stripe-service-v2.js';\n\nexport const onRequestPost = async ({ request, env }) => {\n  // CRITICAL: Read raw body as text, NOT JSON\n  const rawBody = await request.text();\n  const signature = request.headers.get('stripe-signature');\n\n  const webhookSecret = env.STRIPE_WEBHOOK_SECRET;\n  const stripeSecret = env.STRIPE_SECRET_KEY;\n\n  if (!webhookSecret || !stripeSecret) {\n    return new Response('Missing Stripe secrets', { status: 500 });\n  }\n\n  const stripe = getStripeInstance(env);\n\n  // Verify webhook signature using raw body\n  const signatureResult = await verifyWebhookSignature(env, rawBody, signature);\n  if (!signatureResult.success) {\n    console.error('Stripe signature verification failed:', signatureResult.error);\n    return new Response('Invalid signature', { status: 400 });\n  }\n\n  const event = signatureResult.event;\n\n  // Idempotency check - skip if we've already processed this event\n  const eventId = event.id;\n  const idempotencyKey = `event:${eventId}`;\n\n  try {\n    // Check if event already processed\n    const existingEvent = await env.LICENSES.get(idempotencyKey);\n    if (existingEvent) {\n      console.log(`Event ${eventId} already processed, skipping`);\n      return new Response('Event already processed', { status: 200 });\n    }\n  } catch (error) {\n    console.warn('Failed to check idempotency:', error);\n    // Continue processing if we can't check idempotency\n  }\n\n  try {\n    // Handle the event with proper event routing\n    const result = await handleStripeEvent(env, event);\n\n    if (!result.success) {\n      console.error('Event processing failed:', result.error);\n      return new Response('Event processing failed', { status: 500 });\n    }\n\n    // Mark event as processed (for idempotency)\n    try {\n      await env.LICENSES.put(\n        idempotencyKey,\n        JSON.stringify({\n          processed: true,\n          timestamp: Date.now(),\n          eventType: event.type,\n          result: result,\n        }),\n      );\n    } catch (error) {\n      console.warn('Failed to mark event as processed:', error);\n    }\n\n    console.log(`Successfully processed event: ${event.type}`);\n    return new Response('Event processed', { status: 200 });\n  } catch (error) {\n    console.error('Webhook processing error:', error);\n    return new Response('Internal error', { status: 500 });\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/stripe-webhook.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":15,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'stripe' is assigned a value but never used.","line":18,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":23,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":23,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":24,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":34,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":35,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":35,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":38,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":42,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":22}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  getStripeInstance,\n  verifyWebhookSignature,\n  handleCheckoutCompleted,\n} from '../lib/stripe-service.js';\n\nexport const onRequestPost = async ({ request, env }) => {\n  const rawBody = await request.text();\n  const signature = request.headers.get('stripe-signature');\n\n  const webhookSecret = env.STRIPE_WEBHOOK_SECRET;\n  const stripeSecret = env.STRIPE_SECRET_KEY;\n\n  if (!webhookSecret || !stripeSecret) {\n    return new Response('Missing Stripe secrets', { status: 500 });\n  }\n\n  const stripe = getStripeInstance(env);\n\n  // Verify webhook signature\n  const signatureResult = await verifyWebhookSignature(env, rawBody, signature);\n  if (!signatureResult.success) {\n    console.error('Stripe signature verification failed:', signatureResult.error);\n    return new Response('Invalid signature', { status: 400 });\n  }\n\n  const event = signatureResult.event;\n\n  if (event.type === 'checkout.session.completed') {\n    const session = event.data.object;\n    const result = await handleCheckoutCompleted(env, session);\n\n    if (!result.success) {\n      console.error('Checkout processing failed:', result.error);\n      return new Response('Checkout processing failed', { status: 500 });\n    }\n\n    return new Response('Checkout processed', { status: 200 });\n  }\n\n  // Other events you may handle later\n  return new Response('Event ignored', { status: 200 });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/user/export.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":9,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":16,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":23,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":23,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":32,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":41,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":42,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":24}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { requireUserAuth } from '../../lib/user-auth.js';\n\nexport const onRequestGet = async ({ request, env }) => {\n  try {\n    // Check authentication\n    const authResult = await requireUserAuth(request, env);\n\n    if (!authResult.ok) {\n      return new Response(JSON.stringify({ ok: false, error: authResult.error }), {\n        status: authResult.status,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const { user } = authResult;\n    const url = new URL(request.url);\n    const format = url.pathname.endsWith('.json') ? 'json' : 'csv';\n\n    // Get user's complete data\n    const profileData = await getUserProfileData(env, user.id);\n\n    if (format === 'json') {\n      return new Response(JSON.stringify(profileData, null, 2), {\n        status: 200,\n        headers: {\n          'Content-Type': 'application/json',\n          'Content-Disposition': `attachment; filename=rinawarp-user-data-${user.id}-${new Date().toISOString().split('T')[0]}.json`,\n        },\n      });\n    } else {\n      const csvData = convertToCSV(profileData);\n      return new Response(csvData, {\n        status: 200,\n        headers: {\n          'Content-Type': 'text/csv',\n          'Content-Disposition': `attachment; filename=rinawarp-user-data-${user.id}-${new Date().toISOString().split('T')[0]}.csv`,\n        },\n      });\n    }\n  } catch (error) {\n    console.error('Export error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nasync function getUserProfileData(env, userId) {\n  // Get user details\n  const user = await env.RINAWARP_DB.prepare(\n    'SELECT id, email, name, status, created_at, updated_at, last_login_at FROM users WHERE id = ?',\n  )\n    .bind(userId)\n    .first();\n\n  // Get user's licenses\n  const licenses = await env.RINAWARP_DB.prepare(\n    `SELECT l.id, l.plan, l.status, l.created_at,\n            ul.is_primary\n     FROM user_licenses ul\n     JOIN licenses l ON ul.license_id = l.id\n     WHERE ul.user_id = ?`,\n  )\n    .bind(userId)\n    .all();\n\n  // Get user's devices\n  const devices = await env.RINAWARP_DB.prepare(\n    `SELECT id, device_name, device_type, os_name, os_version,\n            app_version, last_active_at, status\n     FROM user_devices\n     WHERE user_id = ?`,\n  )\n    .bind(userId)\n    .all();\n\n  // Get recent activity\n  const activity = await env.RINAWARP_DB.prepare(\n    `SELECT id, action, license_id, ip_address, created_at, metadata\n     FROM user_activity\n     WHERE user_id = ?\n     ORDER BY created_at DESC\n     LIMIT 50`,\n  )\n    .bind(userId)\n    .all();\n\n  return {\n    user: {\n      id: user.id,\n      email: user.email,\n      name: user.name || '',\n      status: user.status,\n      created_at: user.created_at,\n      updated_at: user.updated_at,\n      last_login_at: user.last_login_at,\n      export_timestamp: Date.now(),\n      export_format: 'GDPR Compliant User Data Export',\n    },\n    licenses: licenses.results || [],\n    devices: devices.results || [],\n    activity: activity.results || [],\n  };\n}\n\nfunction convertToCSV(data) {\n  const headers = [\n    // User headers\n    'User ID',\n    'Email',\n    'Name',\n    'Status',\n    'Created At',\n    'Updated At',\n    'Last Login At',\n    'Export Timestamp',\n    'Export Format',\n\n    // License headers (will be repeated for each license)\n    'License ID',\n    'License Plan',\n    'License Status',\n    'License Created At',\n    'License Is Primary',\n\n    // Device headers (will be repeated for each device)\n    'Device ID',\n    'Device Name',\n    'Device Type',\n    'OS Name',\n    'OS Version',\n    'App Version',\n    'Last Active At',\n    'Device Status',\n\n    // Activity headers (will be repeated for each activity)\n    'Activity ID',\n    'Activity Action',\n    'Activity License ID',\n    'Activity IP Address',\n    'Activity Created At',\n    'Activity Metadata',\n  ];\n\n  const rows = [];\n\n  // Add user data row\n  const user = data.user;\n  rows.push([\n    user.id,\n    user.email,\n    user.name,\n    user.status,\n    new Date(user.created_at).toISOString(),\n    user.updated_at ? new Date(user.updated_at).toISOString() : '',\n    user.last_login_at ? new Date(user.last_login_at).toISOString() : '',\n    new Date(user.export_timestamp).toISOString(),\n    user.export_format,\n  ]);\n\n  // Add license rows\n  data.licenses.forEach((lic) => {\n    rows.push([\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '', // Empty user columns\n      lic.id,\n      lic.plan,\n      lic.status,\n      new Date(lic.created_at).toISOString(),\n      lic.is_primary ? 'Yes' : 'No',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '', // Empty other columns\n    ]);\n  });\n\n  // Add device rows\n  data.devices.forEach((dev) => {\n    rows.push([\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '', // Empty user columns\n      '',\n      '',\n      '',\n      '',\n      '', // Empty license columns\n      dev.id,\n      dev.device_name,\n      dev.device_type,\n      dev.os_name,\n      dev.os_version,\n      dev.app_version,\n      dev.last_active_at ? new Date(dev.last_active_at).toISOString() : '',\n      dev.status,\n      '',\n      '',\n      '',\n      '',\n      '',\n      '', // Empty activity columns\n    ]);\n  });\n\n  // Add activity rows\n  data.activity.forEach((act) => {\n    rows.push([\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '', // Empty user columns\n      '',\n      '',\n      '',\n      '',\n      '', // Empty license columns\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '',\n      '', // Empty device columns\n      act.id,\n      act.action,\n      act.license_id,\n      act.ip_address,\n      new Date(act.created_at).toISOString(),\n      JSON.stringify(act.metadata),\n    ]);\n  });\n\n  // Convert to CSV format\n  let csv = headers.join(',') + '\\n';\n  rows.forEach((row) => {\n    csv +=\n      row\n        .map((field) => {\n          // Escape quotes and wrap fields containing commas\n          if (typeof field === 'string' && (field.includes(',') || field.includes('\"'))) {\n            return `\"${field.replace(/\"/g, '\"\"')}\"`;\n          }\n          return field;\n        })\n        .join(',') + '\\n';\n  });\n\n  return csv;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/api/user/profile.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":9,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":50,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":50,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":72,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":73,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":86,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":86,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":96,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":96,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":109,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":109,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":129,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":129,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":141,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":141,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":142,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":142,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":150,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":28}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { requireUserAuth } from '../../lib/user-auth.js';\n\nexport const onRequestGet = async ({ request, env }) => {\n  try {\n    // Check authentication\n    const authResult = await requireUserAuth(request, env);\n\n    if (!authResult.ok) {\n      return new Response(JSON.stringify({ ok: false, error: authResult.error }), {\n        status: authResult.status,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const { user } = authResult;\n\n    // Get user's licenses\n    const licenses = await env.RINAWARP_DB.prepare(\n      `SELECT l.id, l.plan, l.status, l.created_at,\n              ul.is_primary\n       FROM user_licenses ul\n       JOIN licenses l ON ul.license_id = l.id\n       WHERE ul.user_id = ?`,\n    )\n      .bind(user.id)\n      .all();\n\n    // Get user's devices\n    const devices = await env.RINAWARP_DB.prepare(\n      `SELECT id, device_name, device_type, os_name, os_version,\n              app_version, last_active_at, status\n       FROM user_devices\n       WHERE user_id = ?\n       ORDER BY last_active_at DESC`,\n    )\n      .bind(user.id)\n      .all();\n\n    // Get recent activity\n    const activity = await env.RINAWARP_DB.prepare(\n      `SELECT id, action, license_id, ip_address, created_at, metadata\n       FROM user_activity\n       WHERE user_id = ?\n       ORDER BY created_at DESC\n       LIMIT 10`,\n    )\n      .bind(user.id)\n      .all();\n\n    return new Response(\n      JSON.stringify({\n        ok: true,\n        user: {\n          id: user.id,\n          email: user.email,\n          name: user.name || '',\n          status: user.status,\n          created_at: user.created_at,\n          updated_at: user.updated_at,\n          last_login_at: user.last_login_at,\n        },\n        licenses: licenses.results || [],\n        devices: devices.results || [],\n        recent_activity: activity.results || [],\n      }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  } catch (error) {\n    console.error('Profile error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nexport const onRequestPut = async ({ request, env }) => {\n  try {\n    // Check authentication\n    const authResult = await requireUserAuth(request, env);\n\n    if (!authResult.ok) {\n      return new Response(JSON.stringify({ ok: false, error: authResult.error }), {\n        status: authResult.status,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const { user } = authResult;\n    const body = await request.json().catch(() => null);\n\n    if (!body || typeof body !== 'object') {\n      return new Response(JSON.stringify({ ok: false, error: 'Invalid request body' }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    // Update user profile\n    const updates = {};\n    if (body.name !== undefined) updates.name = body.name;\n    if (body.email !== undefined) updates.email = body.email;\n    updates.updated_at = Date.now();\n\n    if (Object.keys(updates).length === 0) {\n      return new Response(JSON.stringify({ ok: false, error: 'No updates provided' }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n\n    const updateQuery = `UPDATE users SET ${Object.keys(updates)\n      .map((key) => `${key} = ?`)\n      .join(', ')} WHERE id = ?`;\n    const updateValues = [...Object.values(updates), user.id];\n\n    await env.RINAWARP_DB.prepare(updateQuery)\n      .bind(...updateValues)\n      .run();\n\n    // Log the profile update\n    await logUserActivity(env, user.id, 'profile_update', null, null, null, {\n      updated_fields: Object.keys(updates),\n    });\n\n    return new Response(\n      JSON.stringify({\n        ok: true,\n        message: 'Profile updated successfully',\n        updated_fields: Object.keys(updates),\n      }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  } catch (error) {\n    console.error('Profile update error:', error);\n    return new Response(JSON.stringify({ ok: false, error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nasync function logUserActivity(env, userId, action, licenseId, ipAddress, userAgent, metadata) {\n  const activityId = crypto.randomUUID();\n\n  await env.RINAWARP_DB.prepare(\n    `INSERT INTO user_activity (id, user_id, license_id, action, ip_address, user_agent, metadata, created_at)\n     VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n  )\n    .bind(\n      activityId,\n      userId,\n      licenseId,\n      action,\n      ipAddress,\n      userAgent,\n      JSON.stringify(metadata),\n      Date.now(),\n    )\n    .run();\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/config.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":6,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":6,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":7,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":7,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":12,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":13,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":13,"endColumn":26}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const NOTIFY_EMAIL_FROM = 'no-reply@rinawarptech.com';\nexport const PUBLIC_URL = 'https://rinawarptech.com';\n\nexport const OAUTH_PROVIDERS = {\n  GOOGLE: {\n    clientId: process.env.GOOGLE_CLIENT_ID || '',\n    clientSecret: process.env.GOOGLE_CLIENT_SECRET || '',\n    redirectUri: 'https://rinawarptech.com/api/auth/google/callback',\n    scope: 'openid email profile',\n  },\n  GITHUB: {\n    clientId: process.env.GITHUB_CLIENT_ID || '',\n    clientSecret: process.env.GITHUB_CLIENT_SECRET || '',\n    redirectUri: 'https://rinawarptech.com/api/auth/github/callback',\n    scope: 'user:email',\n  },\n};\n\nexport const RATE_LIMITS = {\n  MAGIC_LINK: {\n    maxAttempts: 5,\n    windowMinutes: 15,\n  },\n  API_REQUESTS: {\n    maxRequests: 100,\n    windowMinutes: 1,\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/index.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'env' is assigned a value but never used.","line":3,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":4,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":4,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":46,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":46,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":79,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":79,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":83,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":83,"endColumn":22}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Main router for Cloudflare Pages Functions\nexport const onRequest = async (context) => {\n  const { request, env } = context;\n  const url = new URL(request.url);\n  const pathname = url.pathname;\n\n  // Route to specific function files\n  if (pathname.startsWith('/api/stripe-webhook')) {\n    const module = await import('./api/stripe-webhook.js');\n    return module.onRequestPost(context);\n  } else if (pathname.startsWith('/api/license/verify')) {\n    const module = await import('./api/license/verify.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/admin/feedback/list')) {\n    const module = await import('./api/admin/feedback/list.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/admin/feedback/add')) {\n    const module = await import('./api/admin/feedback/add.js');\n    return module.onRequestPost(context);\n  } else if (pathname.startsWith('/api/admin/feedback/export')) {\n    const module = await import('./api/admin/feedback/export.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/admin/licenses/list')) {\n    const module = await import('./api/admin/licenses/list.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/admin/licenses/export')) {\n    const module = await import('./api/admin/licenses/export.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/admin/stats')) {\n    const module = await import('./api/admin/stats.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/admin/backup')) {\n    const module = await import('./api/admin/backup.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/billing/portal')) {\n    const module = await import('./api/billing/portal.js');\n    return module.onRequestPost(context);\n  } else if (pathname.startsWith('/api/admin/analytics')) {\n    const module = await import('./api/admin/analytics.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/admin/user-analytics')) {\n    const module = await import('./api/admin/user-analytics.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/admin/login')) {\n    // TODO: Implement admin login\n    return new Response('Admin login not yet implemented', { status: 501 });\n  } else if (pathname.startsWith('/api/auth/magic-link')) {\n    const module = await import('./api/auth/magic-link.js');\n    return request.method === 'POST' ? module.onRequestPost(context) : module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/auth/google')) {\n    const module = await import('./api/auth/google.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/auth/github')) {\n    const module = await import('./api/auth/github.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/user/profile')) {\n    const module = await import('./api/user/profile.js');\n    return request.method === 'GET' ? module.onRequestGet(context) : module.onRequestPut(context);\n  } else if (pathname.startsWith('/api/user/export')) {\n    const module = await import('./api/user/export.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/auth/logout')) {\n    const module = await import('./api/auth/logout.js');\n    return module.onRequestPost(context);\n  } else if (pathname.startsWith('/api/device/activate')) {\n    const module = await import('./api/device/activate.js');\n    return request.method === 'POST' ? module.onRequestPost(context) : module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/license/recover')) {\n    const module = await import('./api/license/recover.js');\n    return request.method === 'POST' ? module.onRequestPost(context) : module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/license/manage')) {\n    const module = await import('./api/license/manage.js');\n    return request.method === 'GET' ? module.onRequestGet(context) : module.onRequestPost(context);\n  } else if (pathname.startsWith('/api/download/manager')) {\n    const module = await import('./api/download/manager.js');\n    return module.onRequestGet(context);\n  } else if (pathname.startsWith('/api/contact')) {\n    // TODO: Implement contact form\n    return new Response('Contact form not yet implemented', { status: 501 });\n  }\n\n  // Default 404 for unknown API routes\n  return new Response('API endpoint not found', { status: 404 });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/lib/analytics.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'env' is defined but never used.","line":45,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sinceTimestamp' is defined but never used.","line":45,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":120,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":120,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":166,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":166,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":228,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":228,"endColumn":12}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export async function getAnalyticsData(env, days = '30') {\n  const now = Date.now();\n  const daysAgo = now - parseInt(days) * 24 * 60 * 60 * 1000;\n\n  // 1. Get revenue data\n  const revenueData = await getRevenueData(env, daysAgo);\n\n  // 2. Get license growth data\n  const licenseGrowthData = await getLicenseGrowthData(env, daysAgo);\n\n  // 3. Get plan distribution\n  const planDistribution = await getPlanDistribution(env);\n\n  // 4. Get feedback sentiment\n  const feedbackSentiment = await getFeedbackSentiment(env, daysAgo);\n\n  // 5. Get download sources (mock data for now)\n  const downloadSources = {\n    'Direct Download': 45,\n    'Install Script': 30,\n    Homebrew: 15,\n    Other: 10,\n  };\n\n  // 6. Get install script usage (mock data for now)\n  const installScriptUsage = {\n    Linux: 60,\n    Mac: 25,\n    'Windows (WSL)': 15,\n  };\n\n  return {\n    totalRevenue: revenueData.total,\n    totalLicenses: licenseGrowthData.currentCount,\n    newCustomers: licenseGrowthData.newCustomers,\n    revenueByDay: revenueData.byDay,\n    licensesByDay: licenseGrowthData.byDay,\n    plans: planDistribution,\n    feedbackSentiment,\n    downloadSources,\n    installScriptUsage,\n  };\n}\n\nasync function getRevenueData(env, sinceTimestamp) {\n  // In a real implementation, you would query your payment data\n  // For now, we'll return mock data that matches the structure\n\n  const now = new Date();\n  const dataPoints = 30; // days\n  const byDay = [];\n  let total = 0;\n\n  for (let i = dataPoints - 1; i >= 0; i--) {\n    const date = new Date(now);\n    date.setDate(now.getDate() - i);\n    const revenue = Math.floor(Math.random() * 500) + 100; // $100-$600 per day\n    byDay.push({\n      date: date.toISOString().split('T')[0],\n      revenue: revenue,\n    });\n    total += revenue;\n  }\n\n  return { total, byDay };\n}\n\nasync function getLicenseGrowthData(env, sinceTimestamp) {\n  // Query D1 for license growth data\n  try {\n    const result = await env.RINAWARP_DB.prepare(\n      `\n      SELECT\n        DATE(created_at / 1000, 'unixepoch') as date,\n        COUNT(*) as count\n      FROM licenses\n      WHERE created_at >= ?\n      GROUP BY DATE(created_at / 1000, 'unixepoch')\n      ORDER BY date\n    `,\n    )\n      .bind(sinceTimestamp)\n      .all();\n\n    // Calculate cumulative growth\n    let runningTotal = 0;\n    const byDay = [];\n    let newCustomers = 0;\n\n    for (const row of result.results) {\n      runningTotal += row.count;\n      newCustomers += row.count;\n      byDay.push({\n        date: row.date,\n        count: runningTotal,\n      });\n    }\n\n    // If no data, return mock data\n    if (byDay.length === 0) {\n      const now = new Date();\n      for (let i = 29; i >= 0; i--) {\n        const date = new Date(now);\n        date.setDate(now.getDate() - i);\n        byDay.push({\n          date: date.toISOString().split('T')[0],\n          count: 100 + (29 - i) * 2, // Gradual growth\n        });\n      }\n      newCustomers = 60;\n      runningTotal = 160;\n    }\n\n    return {\n      currentCount: runningTotal,\n      newCustomers,\n      byDay,\n    };\n  } catch (error) {\n    console.error('Error getting license growth data:', error);\n    // Return mock data if there's an error\n    const now = new Date();\n    const byDay = [];\n    for (let i = 29; i >= 0; i--) {\n      const date = new Date(now);\n      date.setDate(now.getDate() - i);\n      byDay.push({\n        date: date.toISOString().split('T')[0],\n        count: 100 + (29 - i) * 2,\n      });\n    }\n    return {\n      currentCount: 160,\n      newCustomers: 60,\n      byDay,\n    };\n  }\n}\n\nasync function getPlanDistribution(env) {\n  try {\n    const result = await env.RINAWARP_DB.prepare(\n      `\n      SELECT plan, COUNT(*) as count\n      FROM licenses\n      GROUP BY plan\n    `,\n    ).all();\n\n    const plans = {};\n    for (const row of result.results) {\n      plans[row.plan] = row.count;\n    }\n\n    // If no data, return mock data\n    if (Object.keys(plans).length === 0) {\n      return {\n        'Terminal Pro Lifetime': 70,\n        'Terminal Pro Annual': 20,\n        Enterprise: 10,\n      };\n    }\n\n    return plans;\n  } catch (error) {\n    console.error('Error getting plan distribution:', error);\n    return {\n      'Terminal Pro Lifetime': 70,\n      'Terminal Pro Annual': 20,\n      Enterprise: 10,\n    };\n  }\n}\n\nasync function getFeedbackSentiment(env, sinceTimestamp) {\n  try {\n    const result = await env.RINAWARP_DB.prepare(\n      `\n      SELECT message\n      FROM feedback\n      WHERE created_at >= ?\n    `,\n    )\n      .bind(sinceTimestamp)\n      .all();\n\n    // Simple sentiment analysis\n    let positive = 0;\n    let neutral = 0;\n    let negative = 0;\n\n    for (const row of result.results) {\n      const message = row.message.toLowerCase();\n      if (\n        message.includes('great') ||\n        message.includes('awesome') ||\n        message.includes('love') ||\n        message.includes('excellent')\n      ) {\n        positive++;\n      } else if (\n        message.includes('bad') ||\n        message.includes('hate') ||\n        message.includes('terrible') ||\n        message.includes('awful')\n      ) {\n        negative++;\n      } else {\n        neutral++;\n      }\n    }\n\n    // If no data, return mock data\n    if (positive + neutral + negative === 0) {\n      return {\n        positive: 12,\n        neutral: 5,\n        negative: 2,\n      };\n    }\n\n    return {\n      positive,\n      neutral,\n      negative,\n    };\n  } catch (error) {\n    console.error('Error getting feedback sentiment:', error);\n    return {\n      positive: 12,\n      neutral: 5,\n      negative: 2,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/lib/auth.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/lib/email-service.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":5,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":10,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":59,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":65,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":65,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":72,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":81,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":128,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":128,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":134,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":134,"endColumn":12}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NOTIFY_EMAIL_FROM } from '../config.js';\n\nexport async function sendMagicLinkEmail(env, email, magicLink) {\n  if (!env.RESEND_API_KEY) {\n    console.warn('RESEND_API_KEY not configured, magic link would be sent to:', email);\n    return { success: false, error: 'Email service not configured' };\n  }\n\n  try {\n    const response = await fetch('https://api.resend.com/emails', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${env.RESEND_API_KEY}`,\n      },\n      body: JSON.stringify({\n        from: NOTIFY_EMAIL_FROM || 'no-reply@rinawarptech.com',\n        to: email,\n        subject: 'Your RinaWarp Terminal Pro Magic Link',\n        html: `\n          <!DOCTYPE html>\n          <html>\n          <head>\n            <style>\n              body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }\n              .container { max-width: 600px; margin: 0 auto; padding: 20px; }\n              .header { background-color: #6366f1; color: white; padding: 20px; text-align: center; }\n              .content { padding: 20px; background-color: #f8f9fa; }\n              .button { display: inline-block; padding: 12px 24px; background-color: #6366f1; color: white; text-decoration: none; border-radius: 4px; margin: 20px 0; }\n              .footer { margin-top: 20px; font-size: 12px; color: #666; }\n            </style>\n          </head>\n          <body>\n            <div class=\"container\">\n              <div class=\"header\">\n                <h1>RinaWarp Terminal Pro</h1>\n              </div>\n              <div class=\"content\">\n                <h2>Your Magic Link</h2>\n                <p>Hello,</p>\n                <p>You requested a magic link to access your RinaWarp Terminal Pro account. Click the button below to sign in:</p>\n                <a href=\"${magicLink}\" class=\"button\">Sign In</a>\n                <p>If you didn't request this link, please ignore this email.</p>\n                <p>The link will expire in 15 minutes for security reasons.</p>\n              </div>\n              <div class=\"footer\">\n                <p> ${new Date().getFullYear()} RinaWarp Technologies. All rights reserved.</p>\n                <p>This is an automated message, please do not reply.</p>\n              </div>\n            </div>\n          </body>\n          </html>\n        `,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      console.error('Email sending failed:', response.status, errorData);\n      return { success: false, error: 'Email sending failed' };\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error('Email service error:', error);\n    return { success: false, error: 'Email service error' };\n  }\n}\n\nexport async function sendLicenseRecoveryEmail(env, email, licenses) {\n  if (!env.RESEND_API_KEY) {\n    console.warn('RESEND_API_KEY not configured, license recovery email would be sent to:', email);\n    return { success: false, error: 'Email service not configured' };\n  }\n\n  try {\n    const licenseList = licenses\n      .map((license) => `<li>${license.id} - ${license.plan} (${license.status})</li>`)\n      .join('');\n\n    const response = await fetch('https://api.resend.com/emails', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${env.RESEND_API_KEY}`,\n      },\n      body: JSON.stringify({\n        from: NOTIFY_EMAIL_FROM || 'no-reply@rinawarptech.com',\n        to: email,\n        subject: 'Your RinaWarp Terminal Pro License Information',\n        html: `\n          <!DOCTYPE html>\n          <html>\n          <head>\n            <style>\n              body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }\n              .container { max-width: 600px; margin: 0 auto; padding: 20px; }\n              .header { background-color: #6366f1; color: white; padding: 20px; text-align: center; }\n              .content { padding: 20px; background-color: #f8f9fa; }\n              .footer { margin-top: 20px; font-size: 12px; color: #666; }\n            </style>\n          </head>\n          <body>\n            <div class=\"container\">\n              <div class=\"header\">\n                <h1>RinaWarp Terminal Pro</h1>\n              </div>\n              <div class=\"content\">\n                <h2>Your License Information</h2>\n                <p>Hello,</p>\n                <p>Here is your RinaWarp Terminal Pro license information:</p>\n                <ul>${licenseList}</ul>\n                <p>If you need any assistance, please contact our support team.</p>\n              </div>\n              <div class=\"footer\">\n                <p> ${new Date().getFullYear()} RinaWarp Technologies. All rights reserved.</p>\n                <p>This is an automated message, please do not reply.</p>\n              </div>\n            </div>\n          </body>\n          </html>\n        `,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      console.error('Email sending failed:', response.status, errorData);\n      return { success: false, error: 'Email sending failed' };\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error('Email service error:', error);\n    return { success: false, error: 'Email service error' };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/lib/license-service.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":4,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":4,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'Buffer' is not defined.","line":30,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'Buffer' is not defined.","line":36,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'algorithm' is assigned a value but never used.","line":37,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":74,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":94,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":94,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":95,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":95,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'screen' is not defined.","line":96,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":96,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'screen' is not defined.","line":96,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":96,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":98,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":98,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":99,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":99,"endColumn":14}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import crypto from 'crypto';\n\n// Simple HMAC-based signing (can be upgraded to Ed25519 later)\nconst LICENSE_SECRET = process.env.LICENSE_SIGNING_SECRET || 'your-secret-key-change-this';\n\nexport async function createLicenseBlob(\n  env,\n  { userId, licenseKey, entitlements, deviceFingerprint, expiresAt },\n) {\n  const payload = {\n    userId,\n    licenseKey,\n    entitlements,\n    deviceFingerprint,\n    issuedAt: Date.now(),\n    expiresAt,\n    version: '1.0',\n  };\n\n  // Create signature\n  const payloadString = JSON.stringify(payload);\n  const signature = crypto.createHmac('sha256', LICENSE_SECRET).update(payloadString).digest('hex');\n\n  const licenseBlob = {\n    payload,\n    signature,\n    algorithm: 'HMAC-SHA256',\n  };\n\n  return Buffer.from(JSON.stringify(licenseBlob)).toString('base64');\n}\n\nexport async function validateLicenseBlob(licenseBlob) {\n  try {\n    // Decode blob\n    const blobString = Buffer.from(licenseBlob, 'base64').toString('utf8');\n    const { payload, signature, algorithm } = JSON.parse(blobString);\n\n    // Verify signature\n    const payloadString = JSON.stringify(payload);\n    const expectedSignature = crypto\n      .createHmac('sha256', LICENSE_SECRET)\n      .update(payloadString)\n      .digest('hex');\n\n    if (signature !== expectedSignature) {\n      return { valid: false, error: 'Invalid signature' };\n    }\n\n    // Check expiration\n    if (payload.expiresAt && Date.now() > payload.expiresAt) {\n      return { valid: false, error: 'License expired' };\n    }\n\n    // Check grace period for failed payments\n    if (\n      payload.entitlements.grace_period_ends_at &&\n      Date.now() > payload.entitlements.grace_period_ends_at\n    ) {\n      return {\n        valid: true,\n        expired: true,\n        entitlements: applyGracePeriodRules(payload.entitlements),\n      };\n    }\n\n    return {\n      valid: true,\n      entitlements: payload.entitlements,\n      licenseKey: payload.licenseKey,\n      userId: payload.userId,\n    };\n  } catch (error) {\n    console.error('License blob validation error:', error);\n    return { valid: false, error: 'Invalid license blob' };\n  }\n}\n\nexport function validateDeviceFingerprint(fingerprint) {\n  // Basic validation - ensure it's not empty and has reasonable length\n  if (!fingerprint || typeof fingerprint !== 'string') {\n    return false;\n  }\n\n  // Remove any whitespace and check length\n  const cleanFingerprint = fingerprint.trim();\n  return cleanFingerprint.length >= 10 && cleanFingerprint.length <= 200;\n}\n\nexport function generateDeviceFingerprint() {\n  // This would be implemented on the client side\n  // Combine various device characteristics to create a unique fingerprint\n  const characteristics = [\n    navigator.userAgent,\n    navigator.language,\n    screen.width + 'x' + screen.height,\n    new Date().getTimezoneOffset(),\n    navigator.hardwareConcurrency,\n    navigator.deviceMemory,\n  ].filter(Boolean);\n\n  return crypto.createHash('sha256').update(characteristics.join('|')).digest('hex');\n}\n\nfunction applyGracePeriodRules(entitlements) {\n  // During grace period, keep some features but degrade others\n  return {\n    ...entitlements,\n    agent_memory: false, // Read-only during grace\n    ghost_text: entitlements.ghost_text, // Keep ghost text on\n    // Other features remain as-is during grace\n  };\n}\n\n// Offline validation helper for client-side use\nexport class OfflineLicenseValidator {\n  constructor() {\n    this.cachedLicense = null;\n  }\n\n  async validateCachedLicense() {\n    if (!this.cachedLicense) {\n      return { valid: false, error: 'No cached license' };\n    }\n\n    const result = await validateLicenseBlob(this.cachedLicense);\n\n    if (!result.valid) {\n      return result;\n    }\n\n    // Additional offline checks\n    if (result.expired) {\n      return {\n        valid: true,\n        expired: true,\n        entitlements: result.entitlements,\n        offline: true,\n      };\n    }\n\n    return {\n      valid: true,\n      entitlements: result.entitlements,\n      licenseKey: result.licenseKey,\n      userId: result.userId,\n      offline: true,\n    };\n  }\n\n  setCachedLicense(licenseBlob) {\n    this.cachedLicense = licenseBlob;\n  }\n\n  clearCache() {\n    this.cachedLicense = null;\n  }\n}\n\n// Export singleton instance for use across the app\nexport const offlineValidator = new OfflineLicenseValidator();\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/lib/security-middleware.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":23,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":23,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":49,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":76,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":92,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":92,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":93,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":114,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":114,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":122,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":122,"endColumn":24}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  applyRateLimiting,\n  validateInput,\n  sanitizeInput,\n  setSecurityHeaders,\n  checkAuthentication,\n  logSecurityEvent,\n} from './security.js';\n\nexport async function withSecurity(context, options = {}) {\n  const { request, env, next } = context;\n  const { endpointType = 'API_REQUESTS', requireAuth = false, inputSchema = {} } = options;\n\n  // Apply rate limiting\n  const rateLimitResult = await applyRateLimiting(request, env, endpointType);\n  if (!rateLimitResult.allowed) {\n    await logSecurityEvent(env, 'rate_limit_triggered', {\n      endpoint: request.url,\n      ip: request.headers.get('CF-Connecting-IP'),\n      retryAfter: rateLimitResult.retryAfter,\n    });\n\n    return new Response(\n      JSON.stringify({\n        ok: false,\n        error: 'Too many requests',\n        retry_after: rateLimitResult.retryAfter,\n      }),\n      {\n        status: 429,\n        headers: {\n          'Content-Type': 'application/json',\n          'Retry-After': rateLimitResult.retryAfter.toString(),\n          ...setSecurityHeaders(),\n        },\n      },\n    );\n  }\n\n  // Check authentication if required\n  if (requireAuth) {\n    const authResult = checkAuthentication(request, env);\n    if (!authResult.authenticated) {\n      await logSecurityEvent(env, 'unauthorized_access_attempt', {\n        endpoint: request.url,\n        ip: request.headers.get('CF-Connecting-IP'),\n      });\n\n      return new Response(\n        JSON.stringify({\n          ok: false,\n          error: 'Unauthorized',\n        }),\n        {\n          status: 401,\n          headers: {\n            'Content-Type': 'application/json',\n            ...setSecurityHeaders(),\n          },\n        },\n      );\n    }\n  }\n\n  // Parse and sanitize input for POST/PUT requests\n  let sanitizedBody = null;\n  if (request.method === 'POST' || request.method === 'PUT') {\n    try {\n      const body = await request.json().catch(() => null);\n      sanitizedBody = sanitizeInput(body);\n\n      // Validate input if schema is provided\n      if (Object.keys(inputSchema).length > 0) {\n        const validation = validateInput(sanitizedBody, inputSchema);\n        if (!validation.valid) {\n          return new Response(\n            JSON.stringify({\n              ok: false,\n              error: validation.error,\n            }),\n            {\n              status: 400,\n              headers: {\n                'Content-Type': 'application/json',\n                ...setSecurityHeaders(),\n              },\n            },\n          );\n        }\n      }\n    } catch (error) {\n      console.error('Input parsing error:', error);\n      return new Response(\n        JSON.stringify({\n          ok: false,\n          error: 'Invalid input format',\n        }),\n        {\n          status: 400,\n          headers: {\n            'Content-Type': 'application/json',\n            ...setSecurityHeaders(),\n          },\n        },\n      );\n    }\n  }\n\n  // Call the actual endpoint handler\n  try {\n    const response = await next({ ...context, sanitizedBody });\n    return response;\n  } catch (error) {\n    console.error('Endpoint error:', error);\n\n    await logSecurityEvent(env, 'endpoint_error', {\n      endpoint: request.url,\n      error: error.message,\n      ip: request.headers.get('CF-Connecting-IP'),\n    });\n\n    return new Response(\n      JSON.stringify({\n        ok: false,\n        error: 'Internal server error',\n      }),\n      {\n        status: 500,\n        headers: {\n          'Content-Type': 'application/json',\n          ...setSecurityHeaders(),\n        },\n      },\n    );\n  }\n}\n\n// Helper to create security-wrapped endpoints\nexport function createSecureEndpoint(handler, options = {}) {\n  return async (context) => {\n    return withSecurity({ ...context, next: handler }, options);\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/lib/security.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'env' is defined but never used.","line":108,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":108,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":136,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":147,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":147,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'env' is defined but never used.","line":151,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":151,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ipAddress' is defined but never used.","line":151,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":151,"endColumn":55}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { RATE_LIMITS } from '../config.js';\n\nexport async function applyRateLimiting(request, env, endpointType) {\n  const ipAddress = request.headers.get('CF-Connecting-IP') || 'unknown';\n  const rateLimitKey = `rate_limit:${endpointType}:${ipAddress}`;\n\n  // Get current rate limit data\n  const rateLimitData = await env.RATE_LIMITS.get(rateLimitKey, 'json');\n\n  const now = Date.now();\n  const limitConfig = RATE_LIMITS[endpointType] || RATE_LIMITS.API_REQUESTS;\n\n  if (rateLimitData) {\n    // Check if within the same time window\n    const timeElapsed = now - rateLimitData.windowStart;\n    const windowMinutes = limitConfig.windowMinutes * 60 * 1000;\n\n    if (timeElapsed < windowMinutes) {\n      // Still in the same window\n      if (rateLimitData.count >= limitConfig.maxRequests) {\n        return {\n          allowed: false,\n          retryAfter: Math.ceil((windowMinutes - timeElapsed) / 1000),\n        };\n      }\n\n      // Increment count\n      rateLimitData.count++;\n      await env.RATE_LIMITS.put(rateLimitKey, JSON.stringify(rateLimitData));\n      return { allowed: true };\n    }\n  }\n\n  // Start new window\n  const newRateLimitData = {\n    count: 1,\n    windowStart: now,\n  };\n\n  await env.RATE_LIMITS.put(rateLimitKey, JSON.stringify(newRateLimitData));\n  return { allowed: true };\n}\n\nexport function validateInput(input, schema) {\n  if (!input) {\n    return { valid: false, error: 'Input is required' };\n  }\n\n  // Basic validation based on schema\n  for (const [field, rules] of Object.entries(schema)) {\n    if (rules.required && !input[field]) {\n      return { valid: false, error: `Field ${field} is required` };\n    }\n\n    if (input[field] && rules.type) {\n      if (rules.type === 'email' && !validateEmail(input[field])) {\n        return { valid: false, error: `Field ${field} must be a valid email` };\n      }\n\n      if (rules.type === 'string' && typeof input[field] !== 'string') {\n        return { valid: false, error: `Field ${field} must be a string` };\n      }\n    }\n\n    if (input[field] && rules.minLength && input[field].length < rules.minLength) {\n      return {\n        valid: false,\n        error: `Field ${field} must be at least ${rules.minLength} characters`,\n      };\n    }\n\n    if (input[field] && rules.maxLength && input[field].length > rules.maxLength) {\n      return {\n        valid: false,\n        error: `Field ${field} must be at most ${rules.maxLength} characters`,\n      };\n    }\n  }\n\n  return { valid: true };\n}\n\nfunction validateEmail(email) {\n  const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return re.test(email);\n}\n\nexport function sanitizeInput(input) {\n  if (typeof input === 'string') {\n    return input.trim().replace(/[<>]/g, ''); // Basic XSS prevention\n  }\n\n  if (Array.isArray(input)) {\n    return input.map((item) => sanitizeInput(item));\n  }\n\n  if (typeof input === 'object' && input !== null) {\n    const sanitized = {};\n    for (const [key, value] of Object.entries(input)) {\n      sanitized[sanitizeInput(key)] = sanitizeInput(value);\n    }\n    return sanitized;\n  }\n\n  return input;\n}\n\nexport function checkAuthentication(request, env) {\n  const authHeader = request.headers.get('Authorization');\n\n  if (authHeader && authHeader.startsWith('Bearer ')) {\n    const token = authHeader.substring(7);\n    // Here you would validate the token against your auth system\n    // For now, we'll just check if it's a valid format\n    if (token.length > 10) {\n      return { authenticated: true, token };\n    }\n  }\n\n  return { authenticated: false };\n}\n\nexport function setSecurityHeaders() {\n  return {\n    'X-Content-Type-Options': 'nosniff',\n    'X-Frame-Options': 'DENY',\n    'X-XSS-Protection': '1; mode=block',\n    'Content-Security-Policy':\n      \"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self' https://rinawarptech.com https://downloads.rinawarptech.com; frame-ancestors 'none'; form-action 'self'\",\n    'Referrer-Policy': 'strict-origin-when-cross-origin',\n    'Strict-Transport-Security': 'max-age=63072000; includeSubDomains; preload',\n  };\n}\n\nexport function logSecurityEvent(env, eventType, details = {}) {\n  const eventId = crypto.randomUUID();\n  const timestamp = Date.now();\n\n  // Store in D1 for security auditing\n  env.RINAWARP_DB.prepare(\n    `INSERT INTO security_events (id, event_type, details, created_at)\n     VALUES (?, ?, ?, ?)`,\n  )\n    .bind(eventId, eventType, JSON.stringify(details), timestamp)\n    .run()\n    .catch((error) => {\n      console.error('Failed to log security event:', error);\n    });\n}\n\nexport async function checkIpReputation(env, ipAddress) {\n  // In a real implementation, you would check against a threat intelligence service\n  // For now, we'll just return a mock response\n  return {\n    isMalicious: false,\n    reason: 'IP reputation check not implemented',\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/lib/stripe-service-v2.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":22,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":29,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":56,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":60,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'app' is assigned a value but never used.","line":67,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":67,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":76,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":81,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":127,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":127,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":131,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":131,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":149,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":166,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":166,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":170,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":197,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":197,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":201,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":201,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":248,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":248,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":271,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":271,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":275,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":275,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":283,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":283,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":289,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":289,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":306,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":306,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":323,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":323,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":354,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":354,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":393,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":393,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":483,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":483,"endColumn":12}],"suppressedMessages":[],"errorCount":24,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Stripe from 'stripe';\n\nlet stripeInstance = null;\n\nexport function getStripeInstance(env) {\n  if (!stripeInstance) {\n    stripeInstance = new Stripe(env.STRIPE_SECRET_KEY, {\n      apiVersion: '2023-10-16',\n      httpClient: Stripe.createFetchHttpClient(),\n    });\n  }\n  return stripeInstance;\n}\n\nexport async function verifyWebhookSignature(env, rawBody, signature) {\n  const stripe = getStripeInstance(env);\n\n  try {\n    const event = stripe.webhooks.constructEvent(rawBody, signature, env.STRIPE_WEBHOOK_SECRET);\n    return { success: true, event };\n  } catch (error) {\n    console.error('Stripe webhook signature verification error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n// Main event handler that routes to specific event handlers\nexport async function handleStripeEvent(env, event) {\n  console.log(`Processing Stripe event: ${event.type}`);\n\n  try {\n    switch (event.type) {\n      // One-time payments (Terminal Pro lifetime)\n      case 'checkout.session.completed':\n        return await handleCheckoutCompleted(env, event.data.object);\n\n      // Subscription events (Agent Pro)\n      case 'invoice.paid':\n        return await handleInvoicePaid(env, event.data.object);\n      case 'invoice.payment_failed':\n        return await handleInvoicePaymentFailed(env, event.data.object);\n      case 'customer.subscription.created':\n        return await handleSubscriptionCreated(env, event.data.object);\n      case 'customer.subscription.updated':\n        return await handleSubscriptionUpdated(env, event.data.object);\n      case 'customer.subscription.deleted':\n        return await handleSubscriptionDeleted(env, event.data.object);\n\n      // Refunds and failures\n      case 'charge.refunded':\n        return await handleChargeRefunded(env, event.data.object);\n      case 'checkout.session.async_payment_failed':\n        return await handleAsyncPaymentFailed(env, event.data.object);\n\n      default:\n        console.log(`Unhandled event type: ${event.type}`);\n        return { success: true, message: 'Event ignored' };\n    }\n  } catch (error) {\n    console.error('Event handling error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n// Handle one-time checkout completion (Terminal Pro lifetime)\nasync function handleCheckoutCompleted(env, session) {\n  const { user_id, plan, app } = session.metadata || {};\n  const customerId = session.customer;\n  const email = session.customer_details?.email;\n  const name = session.customer_details?.name || 'Unknown';\n  const sessionId = session.id;\n  const amount = session.amount_total / 100;\n  const currency = session.currency || 'usd';\n\n  if (!email) {\n    console.warn('Checkout completed without email');\n    return { success: false, error: 'Missing email' };\n  }\n\n  if (!user_id) {\n    console.warn('Checkout completed without user_id metadata');\n    return { success: false, error: 'Missing user_id' };\n  }\n\n  // Map price/product to entitlements\n  const entitlements = deriveEntitlementsFromPurchase({\n    type: 'payment',\n    session,\n    plan: plan || mapPriceToPlan(session.line_items?.data?.[0]?.price?.id),\n  });\n\n  const now = Date.now();\n\n  try {\n    // Ensure user exists\n    await ensureUserExists(env, user_id, email, name);\n\n    // Create license record\n    const licenseKey = generateLicenseKey();\n    await env.RINAWARP_DB.prepare(\n      `\n      INSERT INTO licenses (id, user_id, plan, status, created_at, stripe_session_id, stripe_customer_id, amount, currency)\n      VALUES (?, ?, ?, 'active', ?, ?, ?, ?, ?)\n    `,\n    )\n      .bind(licenseKey, user_id, entitlements.plan, now, sessionId, customerId, amount, currency)\n      .run();\n\n    // Update user entitlements\n    await updateUserEntitlements(env, user_id, entitlements);\n\n    // Cache license for fast verification\n    const licenseData = {\n      license_key: licenseKey,\n      user_id,\n      plan: entitlements.plan,\n      entitlements,\n      status: 'active',\n      created_at: now,\n      amount,\n      currency,\n    };\n\n    await env.LICENSES.put(`license:${licenseKey}`, JSON.stringify(licenseData));\n    await env.LICENSES.put(`user:${user_id}:entitlements`, JSON.stringify(entitlements));\n\n    console.log('Terminal Pro lifetime license created:', { user_id, licenseKey, entitlements });\n\n    return { success: true, licenseKey, user_id, entitlements };\n  } catch (error) {\n    console.error('License creation error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n// Handle subscription payment success (Agent Pro renewal)\nasync function handleInvoicePaid(env, invoice) {\n  const customerId = invoice.customer;\n  const subscriptionId = invoice.subscription;\n\n  if (!customerId || !subscriptionId) {\n    return { success: false, error: 'Missing customer or subscription ID' };\n  }\n\n  try {\n    // Get user_id from customer\n    const customer = await getCustomerById(env, customerId);\n    if (!customer?.user_id) {\n      console.warn('No user_id found for customer:', customerId);\n      return { success: false, error: 'Customer not found' };\n    }\n\n    const userId = customer.user_id;\n    const entitlements = deriveEntitlementsFromPurchase({\n      type: 'subscription',\n      invoice,\n      subscription: await getStripeInstance(env).subscriptions.retrieve(subscriptionId),\n    });\n\n    // Update entitlements with subscription status\n    entitlements.agent_pro_status = 'active';\n    entitlements.agent_pro_ends_at = invoice.lines.data[0]?.period?.end * 1000; // Convert to ms\n\n    await updateUserEntitlements(env, userId, entitlements);\n\n    console.log('Agent Pro subscription renewed:', { userId, subscriptionId, entitlements });\n\n    return { success: true, userId, entitlements };\n  } catch (error) {\n    console.error('Invoice payment handling error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n// Handle subscription payment failure\nasync function handleInvoicePaymentFailed(env, invoice) {\n  const customerId = invoice.customer;\n  const subscriptionId = invoice.subscription;\n\n  try {\n    const customer = await getCustomerById(env, customerId);\n    if (!customer?.user_id) {\n      return { success: false, error: 'Customer not found' };\n    }\n\n    const userId = customer.user_id;\n\n    // Get current entitlements and update status\n    const entitlements = await getUserEntitlements(env, userId);\n    entitlements.agent_pro_status = 'past_due';\n\n    // Set grace period end (3 days from now)\n    entitlements.grace_period_ends_at = Date.now() + 3 * 24 * 60 * 60 * 1000;\n\n    await updateUserEntitlements(env, userId, entitlements);\n\n    console.log('Agent Pro payment failed, entered grace period:', { userId, subscriptionId });\n\n    return { success: true, userId, entitlements };\n  } catch (error) {\n    console.error('Payment failure handling error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n// Handle subscription creation\nasync function handleSubscriptionCreated(env, subscription) {\n  // Similar to invoice.paid but for initial subscription setup\n  return await handleInvoicePaid(env, {\n    customer: subscription.customer,\n    subscription: subscription.id,\n    lines: { data: [{ period: { end: subscription.current_period_end } }] },\n  });\n}\n\n// Handle subscription updates\nasync function handleSubscriptionUpdated(env, subscription) {\n  const customerId = subscription.customer;\n  const status = subscription.status;\n\n  try {\n    const customer = await getCustomerById(env, customerId);\n    if (!customer?.user_id) {\n      return { success: false, error: 'Customer not found' };\n    }\n\n    const userId = customer.user_id;\n    const entitlements = await getUserEntitlements(env, userId);\n\n    // Update subscription status\n    switch (status) {\n      case 'active':\n        entitlements.agent_pro_status = 'active';\n        break;\n      case 'past_due':\n        entitlements.agent_pro_status = 'past_due';\n        entitlements.grace_period_ends_at = Date.now() + 3 * 24 * 60 * 60 * 1000;\n        break;\n      case 'canceled':\n        entitlements.agent_pro_status = 'canceled';\n        break;\n    }\n\n    await updateUserEntitlements(env, userId, entitlements);\n\n    return { success: true, userId, entitlements };\n  } catch (error) {\n    console.error('Subscription update handling error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n// Handle subscription cancellation\nasync function handleSubscriptionDeleted(env, subscription) {\n  const customerId = subscription.customer;\n\n  try {\n    const customer = await getCustomerById(env, customerId);\n    if (!customer?.user_id) {\n      return { success: false, error: 'Customer not found' };\n    }\n\n    const userId = customer.user_id;\n    const entitlements = await getUserEntitlements(env, userId);\n\n    entitlements.agent_pro_status = 'canceled';\n    entitlements.agent_pro_ends_at = subscription.current_period_end * 1000;\n\n    await updateUserEntitlements(env, userId, entitlements);\n\n    console.log('Agent Pro subscription canceled:', { userId, subscriptionId: subscription.id });\n\n    return { success: true, userId, entitlements };\n  } catch (error) {\n    console.error('Subscription deletion handling error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n// Handle refunds\nasync function handleChargeRefunded(env, charge) {\n  // Implementation depends on refund policy\n  console.log('Charge refunded:', charge.id);\n  return { success: true, message: 'Refund noted' };\n}\n\n// Handle async payment failures\nasync function handleAsyncPaymentFailed(env, session) {\n  console.log('Async payment failed:', session.id);\n  return { success: true, message: 'Payment failure noted' };\n}\n\n// Helper functions\n\nasync function ensureUserExists(env, userId, email, name) {\n  try {\n    await env.RINAWARP_DB.prepare(\n      `\n      INSERT OR IGNORE INTO users (id, email, name, created_at)\n      VALUES (?, ?, ?, ?)\n    `,\n    )\n      .bind(userId, email, name, Date.now())\n      .run();\n  } catch (error) {\n    console.error('Error ensuring user exists:', error);\n    throw error;\n  }\n}\n\nasync function getCustomerById(env, stripeCustomerId) {\n  try {\n    const result = await env.RINAWARP_DB.prepare(\n      `\n      SELECT user_id, stripe_customer_id FROM users WHERE stripe_customer_id = ?\n    `,\n    )\n      .bind(stripeCustomerId)\n      .first();\n\n    return result || null;\n  } catch (error) {\n    console.error('Error fetching customer:', error);\n    return null;\n  }\n}\n\nasync function getUserEntitlements(env, userId) {\n  try {\n    const result = await env.RINAWARP_DB.prepare(\n      `\n      SELECT * FROM entitlements WHERE user_id = ?\n    `,\n    )\n      .bind(userId)\n      .first();\n\n    if (result) {\n      return {\n        terminal_pro_lifetime: result.terminal_pro_lifetime === 1,\n        agent_pro_status: result.agent_pro_status,\n        agent_pro_ends_at: result.agent_pro_ends_at,\n        agent_memory: result.agent_memory === 1,\n        ghost_text: result.ghost_text === 1,\n        tool_registry_level: result.tool_registry_level,\n        ai_cloud: result.ai_cloud === 1,\n        updated_at: result.updated_at,\n      };\n    }\n\n    // Return default entitlements\n    return getDefaultEntitlements();\n  } catch (error) {\n    console.error('Error fetching entitlements:', error);\n    return getDefaultEntitlements();\n  }\n}\n\nasync function updateUserEntitlements(env, userId, entitlements) {\n  try {\n    await env.RINAWARP_DB.prepare(\n      `\n      INSERT INTO entitlements \n      (user_id, terminal_pro_lifetime, agent_pro_status, agent_pro_ends_at, agent_memory, ghost_text, tool_registry_level, ai_cloud, updated_at)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n      ON CONFLICT(user_id) DO UPDATE SET\n        terminal_pro_lifetime = excluded.terminal_pro_lifetime,\n        agent_pro_status = excluded.agent_pro_status,\n        agent_pro_ends_at = excluded.agent_pro_ends_at,\n        agent_memory = excluded.agent_memory,\n        ghost_text = excluded.ghost_text,\n        tool_registry_level = excluded.tool_registry_level,\n        ai_cloud = excluded.ai_cloud,\n        updated_at = excluded.updated_at\n    `,\n    )\n      .bind(\n        userId,\n        entitlements.terminal_pro_lifetime ? 1 : 0,\n        entitlements.agent_pro_status,\n        entitlements.agent_pro_ends_at,\n        entitlements.agent_memory ? 1 : 0,\n        entitlements.ghost_text ? 1 : 0,\n        entitlements.tool_registry_level,\n        entitlements.ai_cloud ? 1 : 0,\n        Date.now(),\n      )\n      .run();\n\n    // Update cache\n    await env.LICENSES.put(`user:${userId}:entitlements`, JSON.stringify(entitlements));\n  } catch (error) {\n    console.error('Error updating entitlements:', error);\n    throw error;\n  }\n}\n\nfunction deriveEntitlementsFromPurchase(purchase) {\n  const entitlements = getDefaultEntitlements();\n\n  if (purchase.type === 'payment') {\n    // One-time purchase (Terminal Pro lifetime)\n    if (purchase.plan === 'terminal_pro_lifetime' || purchase.session.mode === 'payment') {\n      entitlements.terminal_pro_lifetime = true;\n      entitlements.ghost_text = true;\n    }\n  } else if (purchase.type === 'subscription') {\n    // Subscription (Agent Pro)\n    entitlements.agent_pro_status = 'active';\n    entitlements.agent_memory = true;\n    entitlements.tool_registry_level = 'pro';\n    entitlements.ai_cloud = true;\n\n    if (purchase.subscription?.current_period_end) {\n      entitlements.agent_pro_ends_at = purchase.subscription.current_period_end * 1000;\n    }\n  }\n\n  return entitlements;\n}\n\nfunction getDefaultEntitlements() {\n  return {\n    terminal_pro_lifetime: false,\n    agent_pro_status: 'none',\n    agent_pro_ends_at: null,\n    agent_memory: false,\n    ghost_text: false,\n    tool_registry_level: 'basic',\n    ai_cloud: false,\n  };\n}\n\nfunction mapPriceToPlan(priceId) {\n  const mappings = {\n    price_terminal_pro_lifetime: 'terminal_pro_lifetime',\n    price_agent_pro_monthly: 'agent_pro_monthly',\n    price_agent_pro_yearly: 'agent_pro_yearly',\n  };\n  return mappings[priceId] || 'terminal_pro_lifetime';\n}\n\nfunction generateLicenseKey() {\n  const segment = () => Math.random().toString(36).substring(2, 6).toUpperCase();\n  return `RW-${segment()}-${segment()}-${segment()}`;\n}\n\nexport async function createCheckoutSession(\n  env,\n  { priceId, customerEmail, userId, successUrl, cancelUrl, metadata = {} },\n) {\n  const stripe = getStripeInstance(env);\n\n  try {\n    const session = await stripe.checkout.sessions.create({\n      payment_method_types: ['card'],\n      line_items: [\n        {\n          price: priceId,\n          quantity: 1,\n        },\n      ],\n      mode: 'payment', // or 'subscription' for Agent Pro\n      customer_email: customerEmail,\n      success_url: successUrl,\n      cancel_url: cancelUrl,\n      client_reference_id: userId, // CRITICAL: Link to user\n      metadata: {\n        ...metadata,\n        user_id: userId, // CRITICAL: For webhook mapping\n        app: 'terminal-pro',\n        timestamp: Date.now(),\n      },\n      subscription_data: {\n        metadata: {\n          user_id: userId, // CRITICAL: For subscription webhooks\n        },\n      },\n    });\n\n    return { success: true, sessionId: session.id, url: session.url };\n  } catch (error) {\n    console.error('Stripe checkout error:', error);\n    return { success: false, error: error.message };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/lib/stripe-service.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":43,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":43,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":59,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":71,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":92,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":92,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":104,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":104,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":127,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":127,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":156,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":156,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":170,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":195,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":195,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":200,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":200,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":251,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":251,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":254,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":254,"endColumn":12}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Stripe from 'stripe';\n\nlet stripeInstance = null;\n\nexport function getStripeInstance(env) {\n  if (!stripeInstance) {\n    stripeInstance = new Stripe(env.STRIPE_SECRET_KEY, {\n      apiVersion: '2023-10-16',\n      httpClient: Stripe.createFetchHttpClient(),\n    });\n  }\n  return stripeInstance;\n}\n\nexport async function createCheckoutSession(\n  env,\n  { priceId, customerEmail, successUrl, cancelUrl, metadata = {} },\n) {\n  const stripe = getStripeInstance(env);\n\n  try {\n    const session = await stripe.checkout.sessions.create({\n      payment_method_types: ['card'],\n      line_items: [\n        {\n          price: priceId,\n          quantity: 1,\n        },\n      ],\n      mode: 'payment',\n      customer_email: customerEmail,\n      success_url: successUrl,\n      cancel_url: cancelUrl,\n      metadata: {\n        ...metadata,\n        source: 'rinawarp-terminal-pro',\n        timestamp: Date.now(),\n      },\n    });\n\n    return { success: true, sessionId: session.id, url: session.url };\n  } catch (error) {\n    console.error('Stripe checkout error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function createBillingPortalSession(env, customerId, returnUrl) {\n  const stripe = getStripeInstance(env);\n\n  try {\n    const session = await stripe.billingPortal.sessions.create({\n      customer: customerId,\n      return_url: returnUrl,\n    });\n\n    return { success: true, url: session.url };\n  } catch (error) {\n    console.error('Stripe billing portal error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function getCustomerDetails(env, customerId) {\n  const stripe = getStripeInstance(env);\n\n  try {\n    const customer = await stripe.customers.retrieve(customerId);\n    return { success: true, customer };\n  } catch (error) {\n    console.error('Stripe customer retrieval error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function createCustomer(env, email, name, metadata = {}) {\n  const stripe = getStripeInstance(env);\n\n  try {\n    const customer = await stripe.customers.create({\n      email,\n      name,\n      metadata: {\n        ...metadata,\n        created_at: Date.now(),\n        source: 'rinawarp-terminal-pro',\n      },\n    });\n\n    return { success: true, customerId: customer.id };\n  } catch (error) {\n    console.error('Stripe customer creation error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function verifyWebhookSignature(env, rawBody, signature) {\n  const stripe = getStripeInstance(env);\n\n  try {\n    const event = stripe.webhooks.constructEvent(rawBody, signature, env.STRIPE_WEBHOOK_SECRET);\n    return { success: true, event };\n  } catch (error) {\n    console.error('Stripe webhook signature verification error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function handleCheckoutCompleted(env, session) {\n  const email = session.customer_details?.email;\n  const name = session.customer_details?.name || 'Unknown';\n  const customerId = session.customer || null;\n  const sessionId = session.id;\n  const amount = session.amount_total / 100;\n  const currency = session.currency || 'usd';\n\n  // Determine plan based on price ID or metadata\n  let plan = 'terminal-pro-lifetime';\n  if (session.metadata?.plan) {\n    plan = session.metadata.plan;\n  } else if (session.line_items?.data?.[0]?.price?.id) {\n    // Map price ID to plan\n    plan = mapPriceIdToPlan(session.line_items.data[0].price.id);\n  }\n\n  if (!email) {\n    console.warn('Checkout completed without email');\n    return { success: false, error: 'Missing email' };\n  }\n\n  const licenseKey = generateLicenseKey();\n  const now = Date.now();\n\n  try {\n    // Store in D1 database\n    await env.RINAWARP_DB.prepare(\n      `INSERT INTO licenses (id, email, name, stripe_customer_id, stripe_session_id, plan, status, created_at)\n       VALUES (?, ?, ?, ?, ?, ?, 'active', ?)`,\n    )\n      .bind(licenseKey, email, name, customerId, sessionId, plan, now)\n      .run();\n\n    // Cache in KV for fast verification\n    const licenseData = JSON.stringify({\n      email,\n      name,\n      plan,\n      status: 'active',\n      created_at: now,\n      amount,\n      currency,\n    });\n\n    await env.LICENSES.put(`license:${licenseKey}`, licenseData);\n\n    console.log('New license created', email, licenseKey, plan);\n\n    // Send confirmation email to customer\n    await sendLicenseConfirmationEmail(env, {\n      email,\n      name,\n      licenseKey,\n      plan,\n      amount,\n      currency,\n    });\n\n    return { success: true, licenseKey, email, plan };\n  } catch (error) {\n    console.error('License creation error:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nfunction generateLicenseKey() {\n  const segment = () => Math.random().toString(36).substring(2, 6).toUpperCase();\n  return `RW-${segment()}-${segment()}-${segment()}`;\n}\n\nfunction mapPriceIdToPlan(priceId) {\n  // Add your price ID to plan mappings here\n  const mappings = {\n    price_123_lifetime: 'terminal-pro-lifetime',\n    price_456_annual: 'terminal-pro-annual',\n    price_789_monthly: 'terminal-pro-monthly',\n  };\n  return mappings[priceId] || 'terminal-pro-lifetime';\n}\n\nasync function sendLicenseConfirmationEmail(\n  env,\n  { email, name, licenseKey, plan, amount, currency },\n) {\n  if (!env.RESEND_API_KEY || !env.NOTIFY_EMAIL_FROM) {\n    console.warn('Email service not configured, skipping confirmation email');\n    return;\n  }\n\n  try {\n    const response = await fetch('https://api.resend.com/emails', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${env.RESEND_API_KEY}`,\n      },\n      body: JSON.stringify({\n        from: env.NOTIFY_EMAIL_FROM,\n        to: email,\n        subject: 'Your RinaWarp Terminal Pro License',\n        html: `\n          <!DOCTYPE html>\n          <html>\n          <head>\n            <style>\n              body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }\n              .container { max-width: 600px; margin: 0 auto; padding: 20px; }\n              .header { background-color: #6366f1; color: white; padding: 20px; text-align: center; }\n              .content { padding: 20px; background-color: #f8f9fa; }\n              .license-key { font-family: monospace; font-size: 18px; background: #f0f0f0; padding: 10px; border-radius: 4px; text-align: center; margin: 20px 0; }\n              .footer { margin-top: 20px; font-size: 12px; color: #666; }\n            </style>\n          </head>\n          <body>\n            <div class=\"container\">\n              <div class=\"header\">\n                <h1>RinaWarp Terminal Pro</h1>\n              </div>\n              <div class=\"content\">\n                <h2>Thank You for Your Purchase!</h2>\n                <p>Hello ${name || 'Customer'},</p>\n                <p>Your purchase of <strong>${plan}</strong> has been completed successfully.</p>\n                <p>Here is your license key:</p>\n                <div class=\"license-key\">${licenseKey}</div>\n                <p>Please keep this license key safe as it grants you access to RinaWarp Terminal Pro.</p>\n                <p>Amount: ${amount} ${currency.toUpperCase()}</p>\n                <p>If you have any questions or need support, please contact us at support@rinawarptech.com.</p>\n              </div>\n              <div class=\"footer\">\n                <p> ${new Date().getFullYear()} RinaWarp Technologies. All rights reserved.</p>\n                <p>This is an automated message, please do not reply.</p>\n              </div>\n            </div>\n          </body>\n          </html>\n        `,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      console.error('License confirmation email failed:', response.status, errorData);\n    }\n  } catch (error) {\n    console.error('Email sending error:', error);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/functions/lib/user-auth.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createHash' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":188,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":188,"endColumn":12}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { v4 as uuidv4 } from 'uuid';\nimport { createHash, randomBytes } from 'crypto';\n\nexport async function generateMagicLinkToken(env, email) {\n  // Generate a secure random token\n  const token = randomBytes(32).toString('hex');\n  const expiresAt = Date.now() + 15 * 60 * 1000; // 15 minutes\n\n  // Store in KV for quick lookup\n  await env.MAGIC_LINKS.put(\n    `magic:${token}`,\n    JSON.stringify({\n      email,\n      expires_at: expiresAt,\n      created_at: Date.now(),\n    }),\n  );\n\n  return {\n    token,\n    expires_at: expiresAt,\n    magic_link: `${env.PUBLIC_URL}/auth/magic?token=${token}`,\n  };\n}\n\nexport async function verifyMagicLinkToken(env, token) {\n  const data = await env.MAGIC_LINKS.get(`magic:${token}`, 'json');\n  if (!data || data.expires_at < Date.now()) {\n    return { valid: false, reason: 'expired_or_invalid' };\n  }\n\n  return { valid: true, email: data.email };\n}\n\nexport async function createUserSession(env, userId, ipAddress, userAgent) {\n  const sessionId = uuidv4();\n  const expiresAt = Date.now() + 30 * 24 * 60 * 60 * 1000; // 30 days\n\n  // Store session in database\n  await env.RINAWARP_DB.prepare(\n    `INSERT INTO user_sessions (id, user_id, expires_at, ip_address, user_agent, created_at)\n     VALUES (?, ?, ?, ?, ?, ?)`,\n  )\n    .bind(sessionId, userId, expiresAt, ipAddress, userAgent, Date.now())\n    .run();\n\n  // Also store in KV for faster lookup\n  await env.USER_SESSIONS.put(\n    `session:${sessionId}`,\n    JSON.stringify({\n      user_id: userId,\n      expires_at: expiresAt,\n      created_at: Date.now(),\n    }),\n  );\n\n  return {\n    sessionId,\n    expires_at: expiresAt,\n    cookie: `rw_user_session=${sessionId}; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age=${30 * 24 * 60 * 60}`,\n  };\n}\n\nexport async function getUserSession(env, sessionId) {\n  // Try KV first\n  let session = await env.USER_SESSIONS.get(`session:${sessionId}`, 'json');\n\n  if (!session) {\n    // Fallback to database\n    const result = await env.RINAWARP_DB.prepare('SELECT * FROM user_sessions WHERE id = ?')\n      .bind(sessionId)\n      .first();\n\n    if (result) {\n      session = {\n        user_id: result.user_id,\n        expires_at: result.expires_at,\n        created_at: result.created_at,\n      };\n\n      // Cache in KV\n      await env.USER_SESSIONS.put(`session:${sessionId}`, JSON.stringify(session));\n    }\n  }\n\n  return session;\n}\n\nexport async function requireUserAuth(request, env) {\n  const cookieHeader = request.headers.get('Cookie') || '';\n  const sessionId = getCookie(cookieHeader, 'rw_user_session');\n\n  if (!sessionId) {\n    return { ok: false, status: 401, error: 'Missing session' };\n  }\n\n  const session = await getUserSession(env, sessionId);\n\n  if (!session || session.expires_at < Date.now()) {\n    return { ok: false, status: 401, error: 'Session expired' };\n  }\n\n  // Get user details\n  const user = await env.RINAWARP_DB.prepare(\n    'SELECT id, email, name, status FROM users WHERE id = ?',\n  )\n    .bind(session.user_id)\n    .first();\n\n  if (!user || user.status !== 'active') {\n    return { ok: false, status: 401, error: 'User not found or inactive' };\n  }\n\n  return { ok: true, user, session };\n}\n\nexport async function getUserByEmail(env, email) {\n  return await env.RINAWARP_DB.prepare('SELECT * FROM users WHERE email = ?').bind(email).first();\n}\n\nexport async function createUser(\n  env,\n  email,\n  name,\n  authMethod,\n  oauthProvider = null,\n  oauthId = null,\n) {\n  const userId = uuidv4();\n  const now = Date.now();\n\n  await env.RINAWARP_DB.prepare(\n    `INSERT INTO users (id, email, name, auth_method, oauth_provider, oauth_id, status, created_at, updated_at, email_verified)\n     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,\n  )\n    .bind(userId, email, name, authMethod, oauthProvider, oauthId, 'active', now, now, 1)\n    .run();\n\n  return { id: userId, email, name, auth_method: authMethod };\n}\n\nexport async function logUserActivity(\n  env,\n  userId,\n  action,\n  licenseId = null,\n  ipAddress = null,\n  userAgent = null,\n  metadata = {},\n) {\n  const activityId = uuidv4();\n\n  await env.RINAWARP_DB.prepare(\n    `INSERT INTO user_activity (id, user_id, license_id, action, ip_address, user_agent, metadata, created_at)\n     VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n  )\n    .bind(\n      activityId,\n      userId,\n      licenseId,\n      action,\n      ipAddress,\n      userAgent,\n      JSON.stringify(metadata),\n      Date.now(),\n    )\n    .run();\n\n  return { id: activityId };\n}\n\nexport async function deleteUserSession(env, sessionCookie) {\n  const sessionId = getCookie(sessionCookie, 'rw_user_session');\n\n  if (!sessionId) {\n    return true; // No session to delete\n  }\n\n  try {\n    // Delete from KV\n    await env.USER_SESSIONS.delete(`session:${sessionId}`);\n\n    // Delete from database\n    await env.RINAWARP_DB.prepare('DELETE FROM user_sessions WHERE id = ?').bind(sessionId).run();\n\n    return true;\n  } catch (error) {\n    console.error('Error deleting session:', error);\n    return false;\n  }\n}\n\nfunction getCookie(str, name) {\n  const cookies = str.split(';').map((c) => c.trim());\n  for (const c of cookies) {\n    if (c.startsWith(name + '=')) return c.substring(name.length + 1);\n  }\n  return null;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/js/main.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":2,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":2,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":3,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":3,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":8,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":8,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":10,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":13,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":13,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":15,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used.","line":17,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":18,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":10}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// INSTALL LOGIC\ndocument.getElementById('install-btn').addEventListener('click', () => {\n  window.location.href =\n    'https://downloads.rinawarptech.com/terminal-pro/0.9.0/RinaWarp-Terminal-Pro-Linux.AppImage';\n});\n\n// CHECKOUT LOGIC\ndocument.getElementById('buy-btn').addEventListener('click', async () => {\n  try {\n    const res = await fetch('/api/checkout?product=terminal-pro');\n    const data = await res.json();\n    if (data?.url) {\n      window.location.href = data.url;\n    } else {\n      alert('Checkout failed.');\n    }\n  } catch (err) {\n    alert('Error connecting to checkout.');\n  }\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/sw-fix-20251209-192716/sw.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'self' is not defined.","line":15,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":5},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":16,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":19,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":22,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":26,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'self' is not defined.","line":27,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":30,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'self' is not defined.","line":36,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":5},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":37,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":40,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":46,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":46,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":47,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":53,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'self' is not defined.","line":54,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":54,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'self' is not defined.","line":60,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":5},{"ruleId":"no-undef","severity":2,"message":"'self' is not defined.","line":67,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":72,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":75,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":80,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":91,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":98,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":98,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'caches' is not defined.","line":102,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":102,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'self' is not defined.","line":113,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":113,"endColumn":5},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":114,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":114,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":128,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":128,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'self' is not defined.","line":131,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":131,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":139,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":139,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'self' is not defined.","line":144,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":144,"endColumn":5},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":145,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":145,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'self' is not defined.","line":161,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":161,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'self' is not defined.","line":166,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":166,"endColumn":5},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":167,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":167,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'clients' is not defined.","line":171,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":171,"endColumn":26}],"suppressedMessages":[],"errorCount":33,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// RinaWarp Terminal Pro - Service Worker\nconst CACHE_NAME = 'rinawarp-terminal-v1';\nconst OFFLINE_URL = '/offline.html';\n\n// Assets to cache for offline functionality\nconst CACHE_ASSETS = [\n  '/',\n  '/offline.html',\n  '/favicon.svg',\n  '/og-image.svg',\n  '/ga4-ultimate-tracking.js',\n];\n\n// Install event - cache assets\nself.addEventListener('install', (event) => {\n  console.log('[SW] Installing service worker...');\n\n  event.waitUntil(\n    caches\n      .open(CACHE_NAME)\n      .then((cache) => {\n        console.log('[SW] Caching assets');\n        return cache.addAll(CACHE_ASSETS);\n      })\n      .then(() => {\n        console.log('[SW] Assets cached successfully');\n        return self.skipWaiting();\n      })\n      .catch((error) => {\n        console.error('[SW] Error caching assets:', error);\n      }),\n  );\n});\n\n// Activate event - cleanup old caches\nself.addEventListener('activate', (event) => {\n  console.log('[SW] Activating service worker...');\n\n  event.waitUntil(\n    caches\n      .keys()\n      .then((cacheNames) => {\n        return Promise.all(\n          cacheNames.map((cacheName) => {\n            if (cacheName !== CACHE_NAME) {\n              console.log('[SW] Deleting old cache:', cacheName);\n              return caches.delete(cacheName);\n            }\n          }),\n        );\n      })\n      .then(() => {\n        console.log('[SW] Service worker activated');\n        return self.clients.claim();\n      }),\n  );\n});\n\n// Fetch event - serve cached content when offline\nself.addEventListener('fetch', (event) => {\n  // Skip non-GET requests\n  if (event.request.method !== 'GET') {\n    return;\n  }\n\n  // Skip cross-origin requests\n  if (!event.request.url.startsWith(self.location.origin)) {\n    return;\n  }\n\n  event.respondWith(\n    caches.match(event.request).then((response) => {\n      // Return cached version if available\n      if (response) {\n        console.log('[SW] Serving from cache:', event.request.url);\n        return response;\n      }\n\n      // Try network first\n      return fetch(event.request)\n        .then((fetchResponse) => {\n          // Check if valid response\n          if (!fetchResponse || fetchResponse.status !== 200 || fetchResponse.type !== 'basic') {\n            return fetchResponse;\n          }\n\n          // Clone the response for caching\n          const responseToCache = fetchResponse.clone();\n\n          // Cache successful responses\n          caches.open(CACHE_NAME).then((cache) => {\n            cache.put(event.request, responseToCache);\n          });\n\n          return fetchResponse;\n        })\n        .catch((error) => {\n          console.log('[SW] Network failed, trying cache:', error);\n\n          // Return offline page for navigation requests\n          if (event.request.destination === 'document') {\n            return caches.match(OFFLINE_URL);\n          }\n\n          // For other requests, just fail gracefully\n          throw error;\n        });\n    }),\n  );\n});\n\n// Background sync for offline actions\nself.addEventListener('sync', (event) => {\n  console.log('[SW] Background sync triggered:', event.tag);\n\n  if (event.tag === 'background-sync') {\n    event.waitUntil(\n      // Handle background sync operations\n      handleBackgroundSync(),\n    );\n  }\n});\n\n// Handle background sync operations\nasync function handleBackgroundSync() {\n  try {\n    // Sync any offline actions when connection is restored\n    console.log('[SW] Performing background sync operations');\n\n    // Notify clients that sync is complete\n    const clients = await self.clients.matchAll();\n    clients.forEach((client) => {\n      client.postMessage({\n        type: 'BACKGROUND_SYNC_COMPLETE',\n        timestamp: new Date().toISOString(),\n      });\n    });\n  } catch (error) {\n    console.error('[SW] Background sync failed:', error);\n  }\n}\n\n// Push notifications (for future features)\nself.addEventListener('push', (event) => {\n  console.log('[SW] Push received');\n\n  if (event.data) {\n    const data = event.data.json();\n\n    const options = {\n      body: data.body,\n      icon: '/favicon.svg',\n      badge: '/favicon.svg',\n      vibrate: [100, 50, 100],\n      data: {\n        dateOfArrival: Date.now(),\n        primaryKey: data.primaryKey || 1,\n      },\n    };\n\n    event.waitUntil(self.registration.showNotification(data.title, options));\n  }\n});\n\n// Notification click handler\nself.addEventListener('notificationclick', (event) => {\n  console.log('[SW] Notification clicked');\n\n  event.notification.close();\n\n  event.waitUntil(clients.openWindow(event.notification.data.url || '/'));\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/audit/tools/r2-proxy-worker.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ctx' is defined but never used.","line":2,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":3,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":3,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":7,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":7,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":18,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":21,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":24,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":24}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    const prefix = '/terminal-pro/';\n\n    if (!url.pathname.startsWith(prefix)) {\n      return new Response('Invalid path', { status: 400 });\n    }\n\n    const objectKey = `terminal-pro/${url.pathname.slice(prefix.length)}`;\n    const object = await env.BUCKET.get(objectKey);\n\n    // Log access\n    const country = request.headers.get('cf-ipcountry') || 'XX';\n    const ip = (request.headers.get('cf-connecting-ip') || '0.0.0.0').replace(/\\d+$/, '0');\n    const agent = request.headers.get('user-agent') || 'Unknown';\n\n    console.log(`[${new Date().toISOString()}] DL: ${objectKey} | ${country} | ${ip} | ${agent}`);\n\n    if (!object) {\n      return new Response('File not found', { status: 404 });\n    }\n\n    return new Response(object.body, {\n      headers: {\n        'Content-Type': object.httpMetadata?.contentType || 'application/octet-stream',\n        'Content-Disposition': `attachment; filename=\"${objectKey.split('/').pop()}\"`,\n        'Access-Control-Allow-Origin': '*',\n        'Cache-Control': 'public, max-age=300',\n      },\n    });\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/ai-service/server.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":14,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":16,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":27,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":29,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":81,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":121,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":121,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":131,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":131,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":186,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":186,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":236,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":236,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'systemContext' is assigned a value but never used.","line":238,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":238,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'planBehavior' is assigned a value but never used.","line":264,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":264,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":293,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":293,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":371,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":371,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":396,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":396,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":428,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":428,"endColumn":10}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// backend/ai-service/server.js\nimport express from 'express';\nimport cors from 'cors';\nimport dotenv from 'dotenv';\nimport { exec } from 'child_process';\nimport OpenAI from 'openai';\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport fetch from 'node-fetch';\n\ndotenv.config();\n\nconst LICENSE_API_BASE = process.env.LICENSE_API_BASE || 'http://localhost:3000'; // gateway\n\nconst AUTH_API_BASE = process.env.AUTH_API_BASE || 'http://localhost:3001'; // direct to auth service for now\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Load Rina persona\nlet rinaPersona = null;\ntry {\n  const personaPath = path.join(__dirname, 'personas', 'rina.json');\n  const raw = fs.readFileSync(personaPath, 'utf8');\n  rinaPersona = JSON.parse(raw);\n  console.log(' Rina persona loaded for AI service');\n} catch (err) {\n  console.warn(' Could not load Rina persona:', err.message);\n}\n\nasync function checkLicense({ licenseKey, authToken }) {\n  if (!licenseKey) {\n    return {\n      status: 'missing',\n      plan: 'free',\n      features: {\n        premiumMode: false,\n        maxDailyMessages: 10,\n      },\n    };\n  }\n\n  const headers = {\n    'Content-Type': 'application/json',\n  };\n  if (authToken) {\n    headers.Authorization = `Bearer ${authToken}`;\n  }\n\n  try {\n    const resp = await fetch(`${LICENSE_API_BASE}/license/check`, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify({ licenseKey }),\n    });\n\n    if (!resp.ok) {\n      return {\n        status: 'error',\n        plan: null,\n        features: {\n          premiumMode: false,\n          maxDailyMessages: 0,\n        },\n        httpStatus: resp.status,\n      };\n    }\n\n    const json = await resp.json();\n\n    return {\n      status: json.status || 'unknown',\n      plan: json.plan || null,\n      features: json.features || {\n        premiumMode: false,\n        maxDailyMessages: 0,\n      },\n    };\n  } catch (error) {\n    console.error('License check failed:', error.message);\n    return {\n      status: 'error',\n      plan: null,\n      features: {\n        premiumMode: false,\n        maxDailyMessages: 0,\n      },\n      error: error.message,\n    };\n  }\n}\n\nasync function verifyAuth(authHeader) {\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return { valid: false, user: null };\n  }\n\n  const token = authHeader.replace(/^Bearer\\s+/i, '').trim();\n\n  try {\n    const resp = await fetch(`${AUTH_API_BASE}/auth/verify`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({}),\n    });\n\n    if (!resp.ok) {\n      return { valid: false, user: null, httpStatus: resp.status };\n    }\n\n    const data = await resp.json();\n    return {\n      valid: !!data.valid,\n      user: data.user || null,\n    };\n  } catch (error) {\n    console.error('Auth verification failed:', error.message);\n    return {\n      valid: false,\n      user: null,\n      error: error.message,\n    };\n  }\n}\n\nconst app = express();\nconst PORT = process.env.AI_SERVICE_PORT || 3004;\n\napp.use(cors());\napp.use(express.json());\n\n// Usage tracking system\nconst usageBuckets = new Map();\n\nfunction getUserKey(req, authInfo) {\n  if (authInfo?.user?.id) return `user:${authInfo.user.id}`;\n  return `ip:${req.ip}`;\n}\n\nfunction resetIfNeeded(bucket) {\n  const now = Date.now();\n  if (bucket.resetAt < now) {\n    bucket.count = 0;\n    bucket.resetAt = now + 24 * 60 * 60 * 1000;\n  }\n}\n\nfunction enforceUsage(req, licenseInfo, authInfo) {\n  const max = licenseInfo.features?.maxDailyMessages ?? 20;\n\n  const key = getUserKey(req, authInfo);\n  let bucket = usageBuckets.get(key);\n\n  if (!bucket) {\n    bucket = { count: 0, resetAt: Date.now() + 86400000 };\n    usageBuckets.set(key, bucket);\n  }\n\n  resetIfNeeded(bucket);\n\n  if (bucket.count >= max) {\n    return {\n      allowed: false,\n      remaining: 0,\n      max,\n      resetAt: bucket.resetAt,\n    };\n  }\n\n  bucket.count++;\n  usageBuckets.set(key, bucket);\n\n  return {\n    allowed: true,\n    remaining: max - bucket.count,\n    max,\n    resetAt: bucket.resetAt,\n  };\n}\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\n//  Health check\napp.get('/health', (req, res) => {\n  res.json({ status: 'ok', service: 'ai-service' });\n});\n\n//  Simple chat endpoint\napp.post('/chat', async (req, res) => {\n  try {\n    const { prompt, mode = 'default', context = {}, licenseKey } = req.body || {};\n    const authHeader = req.headers.authorization || null;\n\n    if (!prompt) {\n      return res.status(400).json({ error: \"Missing 'prompt' field\" });\n    }\n\n    // 1) Verify auth\n    const authInfo = await verifyAuth(authHeader);\n\n    // 2) Check license (your existing checkLicense function)\n    const licenseInfo = await checkLicense({\n      licenseKey,\n      authToken: authHeader ? authHeader.replace(/^Bearer\\s+/i, '') : null,\n    });\n\n    // Simple gating example: if explicitly invalid, block\n    if (licenseInfo.status === 'invalid') {\n      return res.status(403).json({\n        error: 'License invalid',\n        license: licenseInfo,\n        message:\n          'Your license key appears invalid or expired. Please update your license in RinaWarp Terminal Pro.',\n      });\n    }\n\n    //  Usage enforcement\n    const usage = enforceUsage(req, licenseInfo, authInfo);\n\n    if (!usage.allowed) {\n      return res.status(429).json({\n        error: 'usage_limit',\n        message: \"You've hit your daily Rina usage limit for your plan.\",\n        usage,\n        upgrade: licenseInfo.plan === 'free' ? 'basic' : 'pro',\n      });\n    }\n\n    //  DEV MODE: Skip OpenAI call entirely\n    if (process.env.NODE_ENV === 'dev') {\n      // Build system context for plan-based behavior\n      const systemContext = {\n        userPlan: licenseInfo.plan,\n        hasPremium: licenseInfo.features.premiumMode,\n        dailyLimitRemaining: usage.remaining,\n        maxDaily: usage.max,\n      };\n\n      // Plan-based behavior\n      let planBehavior = '';\n      if (licenseInfo.plan === 'free') {\n        planBehavior = `\n          IMPORTANT: User is on FREE PLAN.\n          - Keep responses helpful but shorter.\n          - Encourage upgrading in a friendly, soft way.\n          - Mention limits if user is approaching them.\n          - Do not reveal premium features directly.\n        `;\n      } else if (licenseInfo.plan === 'lifetime') {\n        planBehavior = `\n          IMPORTANT: User is LIFETIME VIP.\n          - Be more expressive, warm, and engaged.\n          - Offer advanced help without being asked.\n          - Adapt tone to be slightly more playful and supportive.\n          - User should feel special and valued.\n        `;\n      } else {\n        planBehavior = `\n          User is PREMIUM.\n          - Provide full-depth high-quality answers.\n          - No upsell prompts.\n        `;\n      }\n\n      // Upsell messaging for free users\n      let responseText = `[MOCKED RINA RESPONSE]: Hey babe, I'm in dev mode  All systems are running smooth!`;\n      const nearingLimit = usage.remaining <= 3;\n\n      if (nearingLimit && licenseInfo.plan === 'free') {\n        responseText +=\n          \"\\n\\n You're almost out of free messages for today. Upgrade anytime to unlock unlimited Rina \";\n      }\n\n      return res.json({\n        text: responseText,\n        mode,\n        persona: mode === 'rina' ? rinaPersona?.name || 'Rina' : 'generic',\n        license: licenseInfo,\n        auth: {\n          valid: authInfo.valid,\n          user: authInfo.user,\n        },\n        usage,\n      });\n    }\n\n    if (!process.env.OPENAI_API_KEY) {\n      return res.status(500).json({\n        error: 'OPENAI_API_KEY not set on ai-service',\n      });\n    }\n\n    let input;\n\n    if (mode === 'rina' && rinaPersona?.system_prompt) {\n      // Build a messages array using her persona\n      const systemContext = {\n        userPlan: licenseInfo.plan || 'unknown',\n        hasPremium: !!licenseInfo.features?.premiumMode,\n        dailyLimitRemaining: usage.remaining,\n        maxDaily: usage.max,\n        userId: authInfo.user?.id || null,\n        userEmail: authInfo.user?.email || null,\n        moodHint: context.moodHint || null,\n        userSkillLevel: context.userSkillLevel || null,\n        projectType: context.projectType || null,\n      };\n\n      // Plan-based behavior for system prompt\n      let planBehavior = '';\n      if (licenseInfo.plan === 'free') {\n        planBehavior = `\n          IMPORTANT: User is on FREE PLAN.\n          - Keep responses helpful but shorter.\n          - Encourage upgrading in a friendly, soft way.\n          - Mention limits if user is approaching them.\n          - Do not reveal premium features directly.\n        `;\n      } else if (licenseInfo.plan === 'lifetime') {\n        planBehavior = `\n          IMPORTANT: User is LIFETIME VIP.\n          - Be more expressive, warm, and engaged.\n          - Offer advanced help without being asked.\n          - Adapt tone to be slightly more playful and supportive.\n          - User should feel special and valued.\n        `;\n      } else {\n        planBehavior = `\n          User is PREMIUM.\n          - Provide full-depth high-quality answers.\n          - No upsell prompts.\n        `;\n      }\n\n      const systemContent = [\n        ...rinaPersona.system_prompt,\n        `Current user + license context: ${JSON.stringify(systemContext)}`,\n        planBehavior,\n      ].join(' ');\n\n      input = [\n        {\n          role: 'system',\n          content: systemContent,\n        },\n        {\n          role: 'user',\n          content: prompt,\n        },\n      ];\n    } else {\n      // Generic mode\n      input = prompt;\n    }\n\n    let text;\n\n    try {\n      const response = await openai.responses.create({\n        model: 'gpt-5', // or your chosen model\n        input,\n      });\n      text = response.output_text || null;\n    } catch (err) {\n      console.error(' OpenAI call failed:', err.message);\n      text = 'Oops! My brain got disconnected for a sec  Try again soon!';\n    }\n\n    // Upsell messaging for free users in production mode\n    const nearingLimit = usage.remaining <= 3;\n    let finalText = text;\n\n    if (nearingLimit && licenseInfo.plan === 'free') {\n      finalText +=\n        \"\\n\\n You're almost out of free messages for today. Upgrade anytime to unlock unlimited Rina \";\n    }\n\n    res.json({\n      text: finalText,\n      mode,\n      persona: mode === 'rina' ? rinaPersona?.name || 'Rina' : 'generic',\n      license: licenseInfo,\n      auth: {\n        valid: authInfo.valid,\n        user: authInfo.user,\n      },\n      usage,\n    });\n  } catch (err) {\n    console.error('AI /chat error:', err);\n    res.status(500).json({\n      error: 'AI chat failed',\n      message: err.message,\n    });\n  }\n});\n\n//  Command execution endpoint (basic sandbox)\napp.post('/command', async (req, res) => {\n  const { command, args = [] } = req.body || {};\n\n  if (!command) {\n    return res.status(400).json({ error: \"Missing 'command' field\" });\n  }\n\n  //  VERY IMPORTANT:\n  // In production, restrict allowed commands.\n  const full = [command, ...args].join(' ');\n\n  exec(full, { timeout: 8000 }, (error, stdout, stderr) => {\n    res.json({\n      command: full,\n      code: error?.code ?? 0,\n      stdout,\n      stderr,\n      error: error ? error.message : null,\n    });\n  });\n});\n\napp.listen(PORT, () => {\n  console.log(` AI Service running on http://localhost:${PORT}`);\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/api-gateway/middleware/dashboardAuth.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":8,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":8,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export function dashboardAuth(req, res, next) {\n  const token = req.header('X-Dashboard-Token');\n\n  if (!token) {\n    return res.status(401).json({ error: 'Access token required' });\n  }\n\n  if (token !== process.env.DASHBOARD_TOKEN) {\n    return res.status(403).json({ error: 'Authentication failed' });\n  }\n\n  return next();\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/api-gateway/server-backup.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'aggregateTelemetry' is defined but never used.","line":17,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":34,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":39,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":44,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":49,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":54,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":54,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":59,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":66,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":67,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":68,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":71,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":90,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":160,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":160,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is assigned a value but never used.","line":166,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":166,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":188,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":188,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":197,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":197,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":216,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":216,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":258,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":258,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":313,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":313,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":314,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":314,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":328,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":328,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":385,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":385,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":403,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":403,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'res' is defined but never used.","line":406,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":406,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":407,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":407,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":434,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":434,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'res' is defined but never used.","line":437,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":437,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":438,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":438,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":450,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":450,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'res' is defined but never used.","line":453,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":453,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":454,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":454,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":463,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":463,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":499,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":499,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'next' is defined but never used.","line":515,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":515,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":516,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":516,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":525,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":525,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":526,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":526,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":527,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":527,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":528,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":528,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":529,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":529,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":530,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":530,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":530,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":530,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":585,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":585,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":598,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":598,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":642,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":642,"endColumn":12}],"suppressedMessages":[],"errorCount":45,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport axios from 'axios';\nimport dotenv from 'dotenv';\nimport { createProxyMiddleware } from 'http-proxy-middleware';\n\n// Load environment variables\ndotenv.config();\n\n// In-memory storage for telemetry data (replace with database in production)\nconst telemetryBuffer = [];\nconst MAX_BUFFER_SIZE = 1000;\n\n// Telemetry aggregation function\nfunction aggregateTelemetry(data) {\n  const now = new Date();\n  const hour = Math.floor(now.getHours() / 6) * 6; // Group by 6-hour windows\n\n  return {\n    timestamp: now.toISOString(),\n    hour: hour,\n    appVersion: data.appVersion,\n    os: data.os,\n    agent: data.agent,\n    license: data.license,\n  };\n}\n\n// Enhanced Service registry with telemetry service\nconst SERVICE_REGISTRY = {\n  'auth-service': {\n    url: process.env.AUTH_SERVICE_URL || 'http://localhost:3001',\n    timeout: 5000,\n    healthCheck: '/health',\n  },\n  'revenue-service': {\n    url: process.env.REVENUE_SERVICE_URL || 'http://localhost:3002',\n    timeout: 10000,\n    healthCheck: '/health',\n  },\n  'licensing-service': {\n    url: process.env.LICENSING_SERVICE_URL || 'http://localhost:3003',\n    timeout: 5000,\n    healthCheck: '/health',\n  },\n  'ai-music-video-service': {\n    url: process.env.AI_MUSIC_VIDEO_SERVICE_URL || 'http://localhost:3004',\n    timeout: 30000,\n    healthCheck: '/health',\n  },\n  'ai-service': {\n    url: process.env.AI_SERVICE_URL || 'http://localhost:3004',\n    timeout: 30000,\n    healthCheck: '/health',\n  },\n  'telemetry-service': {\n    url: process.env.TELEMETRY_SERVICE_URL || 'http://localhost:3006',\n    timeout: 3000,\n    healthCheck: '/health',\n  },\n};\n\n// Environment configuration\nconst LICENSING_SERVICE_URL = process.env.LICENSING_SERVICE_URL || 'http://localhost:3003';\nconst AUTH_SERVICE_URL = process.env.AUTH_SERVICE_URL || 'http://localhost:3001';\nconst DOMAIN = process.env.DOMAIN || 'http://localhost:3000';\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(\n  helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        scriptSrc: [\"'self'\"],\n        imgSrc: [\"'self'\", 'data:', 'https:'],\n        connectSrc: [\"'self'\", 'https://api.stripe.com'],\n      },\n    },\n  }),\n);\n\napp.use(\n  cors({\n    origin: process.env.ALLOWED_ORIGINS?.split(',') || [\n      'http://localhost:5173',\n      'https://rinawarptech.com',\n    ],\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],\n  }),\n);\n\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Rate limiting with more specific rules\nconst generalLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 1000,\n  message: { error: 'Too many requests' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst strictLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  message: { error: 'Rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst telemetryLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  max: 10, // Max 10 telemetry reports per IP per 5 minutes\n  message: { error: 'Telemetry rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use('/api/', generalLimiter);\n\n// FIXED: Real Authentication middleware\nconst authenticateToken = async (req, res, next) => {\n  try {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1];\n\n    if (!token) {\n      return res.status(401).json({ error: 'Access token required' });\n    }\n\n    // Verify token with auth service\n    const response = await axios.post(\n      `${AUTH_SERVICE_URL}/auth/verify`,\n      {},\n      {\n        headers: {\n          Authorization: `Bearer ${token}`,\n          'Content-Type': 'application/json',\n        },\n        timeout: 5000,\n      },\n    );\n\n    if (response.data.valid) {\n      req.user = response.data.user;\n      next();\n    } else {\n      res.status(403).json({ error: 'Invalid or expired token' });\n    }\n  } catch (error) {\n    console.error('Auth verification error:', error.message);\n    res.status(403).json({ error: 'Authentication failed' });\n  }\n};\n\n// Service proxy function with improved error handling\nconst proxyToService = (serviceName, options = {}) => {\n  return async (req, res) => {\n    try {\n      const service = SERVICE_REGISTRY[serviceName];\n\n      if (!service) {\n        return res.status(503).json({ error: `Service ${serviceName} not available` });\n      }\n\n      // Determine target path\n      let targetPath = req.path;\n      let queryString = req.url.split('?')[1] || '';\n\n      // Handle path rewriting based on service type\n      if (serviceName === 'auth-service') {\n        targetPath = targetPath.replace(/^\\/auth/, '');\n      } else if (serviceName === 'ai-service') {\n        targetPath = targetPath.replace(/^\\/ai/, '');\n      }\n\n      const targetUrl = `${service.url}${targetPath}${queryString ? '?' + queryString : ''}`;\n\n      console.log(`Proxying ${req.method} ${req.path} to ${serviceName}: ${targetUrl}`);\n\n      // Prepare request configuration\n      const config = {\n        method: req.method,\n        url: targetUrl,\n        data: req.body,\n        headers: {\n          ...req.headers,\n          host: new URL(service.url).host,\n          'x-forwarded-for': req.ip,\n          'x-forwarded-proto': req.protocol,\n        },\n        timeout: service.timeout,\n        validateStatus: () => true, // Don't throw on non-2xx status codes\n      };\n\n      const response = await axios(config);\n\n      // Forward response with proper status and headers\n      Object.entries(response.headers).forEach(([key, value]) => {\n        if (key.toLowerCase() !== 'transfer-encoding') {\n          res.setHeader(key, value);\n        }\n      });\n\n      res.status(response.status).send(response.data);\n    } catch (error) {\n      console.error(`Service ${serviceName} error:`, error.message);\n\n      if (error.code === 'ECONNREFUSED') {\n        res.status(503).json({ error: `Service ${serviceName} is unavailable` });\n      } else if (error.code === 'ENOTFOUND') {\n        res.status(503).json({ error: `Service ${serviceName} host not found` });\n      } else {\n        res.status(500).json({ error: `Service ${serviceName} request failed` });\n      }\n    }\n  };\n};\n\n// Health check endpoint\napp.get('/health', async (req, res) => {\n  const healthChecks = {};\n\n  // Check each service\n  for (const [serviceName, service] of Object.entries(SERVICE_REGISTRY)) {\n    try {\n      const response = await axios.get(`${service.url}${service.healthCheck}`, {\n        timeout: 3000,\n        validateStatus: () => true,\n      });\n      healthChecks[serviceName] = {\n        status: response.status === 200 ? 'healthy' : 'unhealthy',\n        responseTime: response.headers['x-response-time'] || 'unknown',\n      };\n    } catch (error) {\n      healthChecks[serviceName] = {\n        status: 'unhealthy',\n        error: error.message,\n      };\n    }\n  }\n\n  res.json({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    gateway: 'api-gateway',\n    version: '1.0.1',\n    services: healthChecks,\n    uptime: process.uptime(),\n  });\n});\n\n// TELEMETRY ENDPOINTS\n\n// Public telemetry endpoint (no auth required, rate limited)\napp.post('/api/telemetry', telemetryLimiter, async (req, res) => {\n  try {\n    const telemetryData = req.body;\n\n    // Validate required fields\n    const requiredFields = ['appVersion', 'os'];\n    for (const field of requiredFields) {\n      if (!telemetryData[field]) {\n        return res.status(400).json({ error: `Missing required field: ${field}` });\n      }\n    }\n\n    // Validate data types and sanitize\n    const sanitizedData = {\n      appVersion: String(telemetryData.appVersion).slice(0, 20), // Prevent oversized data\n      os: ['win32', 'darwin', 'linux'].includes(telemetryData.os) ? telemetryData.os : 'unknown',\n      agent: telemetryData.agent\n        ? {\n            status: ['online', 'offline'].includes(telemetryData.agent.status)\n              ? telemetryData.agent.status\n              : 'unknown',\n            pingMs:\n              typeof telemetryData.agent.pingMs === 'number'\n                ? Math.min(telemetryData.agent.pingMs, 60000)\n                : null,\n          }\n        : null,\n      license: telemetryData.license\n        ? {\n            tier: ['free', 'pro', 'enterprise'].includes(telemetryData.license.tier)\n              ? telemetryData.license.tier\n              : 'unknown',\n            offline: Boolean(telemetryData.license.offline),\n          }\n        : null,\n      timestamp: new Date().toISOString(),\n      ip: req.ip, // For basic rate limiting, not stored permanently\n    };\n\n    // Store in memory buffer (replace with database in production)\n    telemetryBuffer.push(sanitizedData);\n\n    // Keep buffer size manageable\n    if (telemetryBuffer.length > MAX_BUFFER_SIZE) {\n      telemetryBuffer.shift();\n    }\n\n    // Log for monitoring (development)\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(' Telemetry received:', {\n        version: sanitizedData.appVersion,\n        os: sanitizedData.os,\n        agentStatus: sanitizedData.agent?.status,\n        licenseTier: sanitizedData.license?.tier,\n      });\n    }\n\n    res.json({\n      success: true,\n      message: 'Telemetry received',\n      timestamp: sanitizedData.timestamp,\n    });\n  } catch (error) {\n    console.error('Telemetry error:', error);\n    res.status(500).json({ error: 'Failed to process telemetry' });\n  }\n});\n\n// Telemetry aggregation endpoint (for dashboard)\napp.get('/api/telemetry/summary', authenticateToken, async (req, res) => {\n  try {\n    const now = new Date();\n    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    // Filter recent telemetry\n    const recentTelemetry = telemetryBuffer.filter(\n      (item) => new Date(item.timestamp) > last24Hours,\n    );\n\n    // Aggregate statistics\n    const summary = {\n      totalReports: recentTelemetry.length,\n      byOS: {},\n      byVersion: {},\n      byAgentStatus: {},\n      byLicenseTier: {},\n      lastReport:\n        recentTelemetry.length > 0 ? recentTelemetry[recentTelemetry.length - 1].timestamp : null,\n      timeRange: {\n        from: last24Hours.toISOString(),\n        to: now.toISOString(),\n      },\n    };\n\n    // Calculate aggregates\n    recentTelemetry.forEach((item) => {\n      // By OS\n      summary.byOS[item.os] = (summary.byOS[item.os] || 0) + 1;\n\n      // By Version\n      summary.byVersion[item.appVersion] = (summary.byVersion[item.appVersion] || 0) + 1;\n\n      // By Agent Status\n      if (item.agent?.status) {\n        summary.byAgentStatus[item.agent.status] =\n          (summary.byAgentStatus[item.agent.status] || 0) + 1;\n      }\n\n      // By License Tier\n      if (item.license?.tier) {\n        summary.byLicenseTier[item.license.tier] =\n          (summary.byLicenseTier[item.license.tier] || 0) + 1;\n      }\n    });\n\n    res.json({\n      success: true,\n      data: summary,\n    });\n  } catch (error) {\n    console.error('Telemetry summary error:', error);\n    res.status(500).json({ error: 'Failed to generate telemetry summary' });\n  }\n});\n\n// Public endpoints (no authentication required)\napp.use('/health', generalLimiter);\n\n// FIXED: Authentication routes - using createProxyMiddleware for consistency\napp.use(\n  '/auth',\n  createProxyMiddleware({\n    target: AUTH_SERVICE_URL,\n    changeOrigin: true,\n    pathRewrite: {\n      '^/auth': '', // Remove /auth prefix when forwarding to auth service\n    },\n    onError: (err, req, res) => {\n      console.error('Auth service proxy error:', err);\n      res.status(503).json({ error: 'Authentication service unavailable' });\n    },\n    onProxyReq: (proxyReq, req, res) => {\n      console.log(\n        `[AUTH] ${req.method} ${req.path} -> ${AUTH_SERVICE_URL}${req.path.replace('/auth', '')}`,\n      );\n    },\n  }),\n);\n\n// AI service routes (public for now)\napp.use('/ai', proxyToService('ai-service'));\n\n// FIXED: Protected API routes with real authentication\napp.use('/api/revenue', authenticateToken, strictLimiter, proxyToService('revenue-service'));\napp.use('/api/licensing', authenticateToken, strictLimiter, proxyToService('licensing-service'));\napp.use(\n  '/api/ai-music-video',\n  authenticateToken,\n  strictLimiter,\n  proxyToService('ai-music-video-service'),\n);\n\n// License check proxy (may be public or require different auth)\napp.use(\n  '/license/check',\n  createProxyMiddleware({\n    target: LICENSING_SERVICE_URL,\n    changeOrigin: true,\n    onError: (err, req, res) => {\n      console.error('License service proxy error:', err);\n      res.status(503).json({ error: 'License service unavailable' });\n    },\n    onProxyReq: (proxyReq, req, res) => {\n      console.log(`[LICENSE] ${req.method} ${req.path} -> ${LICENSING_SERVICE_URL}${req.path}`);\n    },\n  }),\n);\n\n// Auth verify proxy (dedicated endpoint)\napp.use(\n  '/auth/verify',\n  createProxyMiddleware({\n    target: AUTH_SERVICE_URL,\n    changeOrigin: true,\n    onError: (err, req, res) => {\n      console.error('Auth verify proxy error:', err);\n      res.status(200).json({ valid: false, user: null });\n    },\n    onProxyReq: (proxyReq, req, res) => {\n      console.log(`[AUTH-VERIFY] ${req.method} ${req.path} -> ${AUTH_SERVICE_URL}${req.path}`);\n    },\n  }),\n);\n\n// Stripe webhook endpoint (special handling)\napp.post('/api/stripe/webhook', express.raw({ type: 'application/json' }), (req, res) => {\n  // This endpoint should handle Stripe webhooks directly\n  // For now, just acknowledge receipt\n  console.log('Stripe webhook received:', req.headers['stripe-signature']);\n  res.status(200).json({ received: true });\n});\n\n// FIXED: Checkout endpoint with plan validation\napp.post('/api/checkout-v2', express.json({ limit: '1mb' }), async (req, res) => {\n  try {\n    const { plan, successUrl, cancelUrl } = req.body;\n\n    if (!plan) {\n      return res.status(400).json({ error: 'Plan is required' });\n    }\n\n    // Validate plan against known plans\n    const validPlans = [\n      'starter-monthly',\n      'creator-monthly',\n      'pro-monthly',\n      'enterprise-yearly',\n      'pioneer-lifetime',\n      'founder-lifetime',\n    ];\n\n    if (!validPlans.includes(plan)) {\n      return res.status(400).json({ error: 'Invalid plan code' });\n    }\n\n    // This would integrate with Stripe checkout\n    // For now, return a mock response\n    res.json({\n      sessionId: `cs_test_${Date.now()}`,\n      plan,\n      successUrl: successUrl || `${DOMAIN}/success.html`,\n      cancelUrl: cancelUrl || `${DOMAIN}/cancel.html`,\n    });\n  } catch (error) {\n    console.error('Checkout error:', error);\n    res.status(500).json({ error: 'Checkout failed' });\n  }\n});\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    error: 'Endpoint not found',\n    path: req.path,\n    method: req.method,\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Global error handler\napp.use((error, req, res, next) => {\n  console.error('Gateway error:', error);\n  res.status(500).json({\n    error: 'Internal server error',\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Start server\napp.listen(PORT, () => {\n  console.log(` API Gateway running on port ${PORT}`);\n  console.log(` Health check: http://localhost:${PORT}/health`);\n  console.log(` Telemetry endpoint: http://localhost:${PORT}/api/telemetry`);\n  console.log(` Auth service: ${AUTH_SERVICE_URL}`);\n  console.log(` License service: ${LICENSING_SERVICE_URL}`);\n  console.log(` Allowed origins: ${process.env.ALLOWED_ORIGINS || 'localhost:5173'}`);\n});\n\nexport default app;\n\n// TELEMETRY ENDPOINTS (Added for monitoring)\n\n// Public telemetry endpoint (no auth required, rate limited)\napp.post('/api/telemetry', telemetryLimiter, async (req, res) => {\n  try {\n    const telemetryData = req.body;\n\n    // Validate required fields\n    const requiredFields = ['appVersion', 'os'];\n    for (const field of requiredFields) {\n      if (!telemetryData[field]) {\n        return res.status(400).json({ error: `Missing required field: ${field}` });\n      }\n    }\n\n    // Validate data types and sanitize\n    const sanitizedData = {\n      appVersion: String(telemetryData.appVersion).slice(0, 20),\n      os: ['win32', 'darwin', 'linux'].includes(telemetryData.os) ? telemetryData.os : 'unknown',\n      agent: telemetryData.agent\n        ? {\n            status: ['online', 'offline'].includes(telemetryData.agent.status)\n              ? telemetryData.agent.status\n              : 'unknown',\n            pingMs:\n              typeof telemetryData.agent.pingMs === 'number'\n                ? Math.min(telemetryData.agent.pingMs, 60000)\n                : null,\n          }\n        : null,\n      license: telemetryData.license\n        ? {\n            tier: ['free', 'pro', 'enterprise'].includes(telemetryData.license.tier)\n              ? telemetryData.license.tier\n              : 'unknown',\n            offline: Boolean(telemetryData.license.offline),\n          }\n        : null,\n      timestamp: new Date().toISOString(),\n      ip: req.ip,\n    };\n\n    // Store in memory buffer\n    if (typeof telemetryBuffer !== 'undefined') {\n      telemetryBuffer.push(sanitizedData);\n      if (telemetryBuffer.length > 1000) {\n        telemetryBuffer.shift();\n      }\n    }\n\n    console.log(' Telemetry received:', {\n      version: sanitizedData.appVersion,\n      os: sanitizedData.os,\n      agentStatus: sanitizedData.agent?.status,\n      licenseTier: sanitizedData.license?.tier,\n    });\n\n    res.json({\n      success: true,\n      message: 'Telemetry received',\n      timestamp: sanitizedData.timestamp,\n    });\n  } catch (error) {\n    console.error('Telemetry error:', error);\n    res.status(500).json({ error: 'Failed to process telemetry' });\n  }\n});\n\n// Telemetry aggregation endpoint (for dashboard)\napp.get('/api/telemetry/summary', async (req, res) => {\n  try {\n    const now = new Date();\n    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    // Mock data for demonstration\n    const summary = {\n      totalReports: 127,\n      byOS: {\n        linux: 89,\n        darwin: 23,\n        win32: 15,\n      },\n      byVersion: {\n        '1.0.0': 98,\n        '1.0.1': 29,\n      },\n      byAgentStatus: {\n        online: 45,\n        offline: 82,\n      },\n      byLicenseTier: {\n        free: 95,\n        pro: 28,\n        enterprise: 4,\n      },\n      lastReport: new Date().toISOString(),\n      timeRange: {\n        from: last24Hours.toISOString(),\n        to: now.toISOString(),\n      },\n    };\n\n    res.json({\n      success: true,\n      data: summary,\n    });\n  } catch (error) {\n    console.error('Telemetry summary error:', error);\n    res.status(500).json({ error: 'Failed to generate telemetry summary' });\n  }\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/api-gateway/server-enhanced.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'axios' is defined but never used.","line":5,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createProxyMiddleware' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":69,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LICENSING_SERVICE_URL' is assigned a value but never used.","line":74,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":74,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":74,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AUTH_SERVICE_URL' is assigned a value but never used.","line":75,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":75,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":75,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DOMAIN' is assigned a value but never used.","line":76,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":76,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":76,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":77,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":77,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TELEMETRY_SUMMARY_URL' is assigned a value but never used.","line":78,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":78,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":79,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":79,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":80,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":83,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":83,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":102,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":102,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":139,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":139,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":177,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":177,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":233,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":233,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":258,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":258,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":361,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":361,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'next' is defined but never used.","line":377,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":377,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":378,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":378,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":387,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":387,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":388,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":388,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":389,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":389,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":390,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":390,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":391,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":391,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":392,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":392,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":393,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":393,"endColumn":10}],"suppressedMessages":[],"errorCount":29,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport axios from 'axios';\nimport dotenv from 'dotenv';\nimport { createProxyMiddleware } from 'http-proxy-middleware';\nimport { dashboardAuth } from './middleware/dashboardAuth.js';\nimport {\n  processLicenseEvent,\n  getLicenseStatus,\n  getAbuseStatistics,\n} from '../license-abuse-service/abuse-detector.js';\n\n// Load environment variables\ndotenv.config();\n\n// In-memory storage for telemetry data (replace with database in production)\nconst telemetryBuffer = [];\nconst MAX_BUFFER_SIZE = 1000;\n\n// Data retention configuration\nconst RETENTION_DAYS = 30;\nconst MS_PER_DAY = 86400000;\n\n// Schema version validation\nconst SUPPORTED_SCHEMA_VERSIONS = new Set([1]);\n\n// Required fields validation\nconst REQUIRED_FIELDS = ['appVersion', 'os', 'agent', 'license', 'schemaVersion'];\n\n// Schema version validation function\nfunction validateSchemaVersion(payload) {\n  if (typeof payload.schemaVersion !== 'number') {\n    return { ok: false, error: 'schemaVersion required' };\n  }\n\n  if (!SUPPORTED_SCHEMA_VERSIONS.has(payload.schemaVersion)) {\n    return { ok: false, error: `Unsupported schemaVersion ${payload.schemaVersion}` };\n  }\n\n  return { ok: true };\n}\n\n// Required fields validation function\nfunction validateRequiredFields(payload) {\n  for (const field of REQUIRED_FIELDS) {\n    if (payload[field] === undefined || payload[field] === null) {\n      return { ok: false, error: `Missing required field: ${field}` };\n    }\n  }\n  return { ok: true };\n}\n\n// Data retention function\nfunction purgeOldTelemetry() {\n  const cutoff = Date.now() - RETENTION_DAYS * MS_PER_DAY;\n  const originalLength = telemetryBuffer.length;\n\n  // Filter out old records\n  for (let i = telemetryBuffer.length - 1; i >= 0; i--) {\n    if (new Date(telemetryBuffer[i].timestamp).getTime() < cutoff) {\n      telemetryBuffer.splice(i, 1);\n    }\n  }\n\n  const removed = originalLength - telemetryBuffer.length;\n  if (removed > 0) {\n    console.log(` Purged ${removed} old telemetry records (${RETENTION_DAYS} days retention)`);\n  }\n}\n\n// Environment configuration\nconst LICENSING_SERVICE_URL = process.env.LICENSING_SERVICE_URL || 'http://localhost:3003';\nconst AUTH_SERVICE_URL = process.env.AUTH_SERVICE_URL || 'http://localhost:3001';\nconst DOMAIN = process.env.DOMAIN || 'http://localhost:3000';\nconst SLACK_WEBHOOK_URL = process.env.SLACK_WEBHOOK_URL;\nconst TELEMETRY_SUMMARY_URL =\n  process.env.TELEMETRY_SUMMARY_URL ||\n  `http://localhost:${process.env.PORT || 3000}/api/telemetry/summary`;\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(\n  helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        scriptSrc: [\"'self'\"],\n        imgSrc: [\"'self'\", 'data:', 'https:'],\n        connectSrc: [\"'self'\", 'https://api.stripe.com'],\n      },\n    },\n  }),\n);\n\napp.use(\n  cors({\n    origin: process.env.ALLOWED_ORIGINS?.split(',') || [\n      'http://localhost:5173',\n      'https://rinawarptech.com',\n    ],\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'X-Dashboard-Token'],\n  }),\n);\n\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Rate limiting\nconst telemetryLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  max: 10, // Max 10 telemetry reports per IP per 5 minutes\n  message: { error: 'Telemetry rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst licenseLimiter = rateLimit({\n  windowMs: 1 * 60 * 1000, // 1 minute\n  max: 60, // Max 60 license checks per minute per IP\n  message: { error: 'License check rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    gateway: 'api-gateway',\n    version: '1.1.0',\n    uptime: process.uptime(),\n    features: {\n      telemetry: true,\n      licenseAbuseDetection: true,\n      canaryUpdates: true,\n      slackAlerts: !!SLACK_WEBHOOK_URL,\n    },\n  });\n});\n\n// FIXED: Telemetry endpoint with proper validation order\napp.post('/api/telemetry', telemetryLimiter, async (req, res) => {\n  try {\n    // 1. Required fields validation (fail fast)\n    const requiredCheck = validateRequiredFields(req.body);\n    if (!requiredCheck.ok) {\n      return res.status(400).json({ error: requiredCheck.error });\n    }\n\n    // 2. Schema version validation (fail fast)\n    const schemaCheck = validateSchemaVersion(req.body);\n    if (!schemaCheck.ok) {\n      return res.status(400).json({ error: schemaCheck.error });\n    }\n\n    const telemetryData = req.body;\n\n    // 3. Process license abuse detection\n    if (telemetryData.license && telemetryData.license.key) {\n      const abuseStatus = processLicenseEvent(\n        telemetryData.license.key,\n        telemetryData.deviceId || req.ip,\n        req.ip,\n        'valid',\n      );\n\n      // Add abuse status to response\n      if (abuseStatus.quarantined) {\n        console.log(\n          ` Quarantined license detected in telemetry: ${telemetryData.license.key.substring(0, 8)}...`,\n        );\n      }\n    }\n\n    // 4. Validate data types and sanitize\n    const sanitizedData = {\n      appVersion: String(telemetryData.appVersion).slice(0, 20),\n      os: ['win32', 'darwin', 'linux'].includes(telemetryData.os) ? telemetryData.os : 'unknown',\n      schemaVersion: telemetryData.schemaVersion,\n      agent: telemetryData.agent\n        ? {\n            status: ['online', 'offline'].includes(telemetryData.agent.status)\n              ? telemetryData.agent.status\n              : 'unknown',\n            pingMs:\n              typeof telemetryData.agent.pingMs === 'number'\n                ? Math.min(telemetryData.agent.pingMs, 60000)\n                : null,\n          }\n        : null,\n      license: telemetryData.license\n        ? {\n            tier: ['free', 'pro', 'enterprise'].includes(telemetryData.license.tier)\n              ? telemetryData.license.tier\n              : 'unknown',\n            offline: Boolean(telemetryData.license.offline),\n            key: telemetryData.license.key\n              ? telemetryData.license.key.substring(0, 8) + '...'\n              : null, // Don't store full key\n          }\n        : null,\n      updateCohort: telemetryData.updateCohort || 'stable', // Canary update info\n      timestamp: new Date().toISOString(),\n      ip: req.ip,\n    };\n\n    // 5. Store in memory buffer\n    telemetryBuffer.push(sanitizedData);\n\n    // Keep buffer size manageable\n    if (telemetryBuffer.length > MAX_BUFFER_SIZE) {\n      telemetryBuffer.shift();\n    }\n\n    // 6. Apply data retention policy\n    purgeOldTelemetry();\n\n    res.json({\n      success: true,\n      message: 'Telemetry received',\n      timestamp: sanitizedData.timestamp,\n      abuseStatus: telemetryData.license ? getLicenseStatus(telemetryData.license.key) : null,\n    });\n  } catch (error) {\n    console.error('Telemetry error:', error);\n    res.status(500).json({ error: 'Failed to process telemetry' });\n  }\n});\n\n// License abuse detection endpoint\napp.post('/api/license/check', licenseLimiter, async (req, res) => {\n  try {\n    const { licenseKey, deviceId } = req.body;\n\n    if (!licenseKey) {\n      return res.status(400).json({ error: 'License key required' });\n    }\n\n    // Process license event\n    const abuseStatus = processLicenseEvent(licenseKey, deviceId || req.ip, req.ip, 'valid');\n\n    res.json({\n      valid: true,\n      quarantined: abuseStatus.quarantined,\n      abuseScore: abuseStatus.abuseScore,\n      reason: abuseStatus.reason,\n      deviceId: deviceId ? deviceId.substring(0, 8) + '...' : null,\n    });\n  } catch (error) {\n    console.error('License check error:', error);\n    res.status(500).json({ error: 'License check failed' });\n  }\n});\n\n// FIXED: Dashboard authentication endpoint with enhanced telemetry\napp.get('/api/telemetry/summary', dashboardAuth, async (req, res) => {\n  try {\n    const now = new Date();\n    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    // Filter recent telemetry\n    const recentTelemetry = telemetryBuffer.filter(\n      (item) => new Date(item.timestamp) > last24Hours,\n    );\n\n    // Calculate agent health metrics\n    const agentRecords = recentTelemetry.filter((item) => item.agent && item.agent.status);\n    const onlineAgents = agentRecords.filter((item) => item.agent.status === 'online').length;\n    const totalAgentRecords = agentRecords.length;\n    const onlineRate = totalAgentRecords > 0 ? onlineAgents / totalAgentRecords : 1;\n\n    // Calculate canary vs stable metrics\n    const canaryRecords = recentTelemetry.filter((item) => item.updateCohort === 'canary');\n    const stableRecords = recentTelemetry.filter((item) => item.updateCohort === 'stable');\n\n    const canaryOnlineAgents = canaryRecords.filter(\n      (item) => item.agent?.status === 'online',\n    ).length;\n    const stableOnlineAgents = stableRecords.filter(\n      (item) => item.agent?.status === 'online',\n    ).length;\n\n    const canaryOnlineRate =\n      canaryRecords.length > 0 ? canaryOnlineAgents / canaryRecords.length : 1;\n    const stableOnlineRate =\n      stableRecords.length > 0 ? stableOnlineAgents / stableRecords.length : 1;\n\n    // Aggregate statistics\n    const summary = {\n      totalReports: recentTelemetry.length,\n      byOS: {},\n      byVersion: {},\n      byAgentStatus: {},\n      byLicenseTier: {},\n      byUpdateCohort: {\n        canary: canaryRecords.length,\n        stable: stableRecords.length,\n      },\n      agent: {\n        sampleCount: totalAgentRecords,\n        onlineRate: onlineRate,\n        onlineCount: onlineAgents,\n        offlineCount: totalAgentRecords - onlineAgents,\n        windowMinutes: 1440, // 24 hours\n        cohorts: {\n          canary: {\n            sampleCount: canaryRecords.length,\n            onlineRate: canaryOnlineRate,\n            onlineCount: canaryOnlineAgents,\n          },\n          stable: {\n            sampleCount: stableRecords.length,\n            onlineRate: stableOnlineRate,\n            onlineCount: stableOnlineAgents,\n          },\n        },\n      },\n      licenses: getAbuseStatistics(),\n      lastReport:\n        recentTelemetry.length > 0 ? recentTelemetry[recentTelemetry.length - 1].timestamp : null,\n      timeRange: {\n        from: last24Hours.toISOString(),\n        to: now.toISOString(),\n      },\n    };\n\n    // Calculate aggregates\n    recentTelemetry.forEach((item) => {\n      // By OS\n      summary.byOS[item.os] = (summary.byOS[item.os] || 0) + 1;\n\n      // By Version\n      summary.byVersion[item.appVersion] = (summary.byVersion[item.appVersion] || 0) + 1;\n\n      // By Agent Status\n      if (item.agent?.status) {\n        summary.byAgentStatus[item.agent.status] =\n          (summary.byAgentStatus[item.agent.status] || 0) + 1;\n      }\n\n      // By License Tier\n      if (item.license?.tier) {\n        summary.byLicenseTier[item.license.tier] =\n          (summary.byLicenseTier[item.license.tier] || 0) + 1;\n      }\n    });\n\n    res.json({\n      success: true,\n      data: summary,\n    });\n  } catch (error) {\n    console.error('Telemetry summary error:', error);\n    res.status(500).json({ error: 'Failed to generate telemetry summary' });\n  }\n});\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    error: 'Endpoint not found',\n    path: req.path,\n    method: req.method,\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Global error handler\napp.use((error, req, res, next) => {\n  console.error('Gateway error:', error);\n  res.status(500).json({\n    error: 'Internal server error',\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Start server\napp.listen(PORT, () => {\n  console.log(` API Gateway running on port ${PORT}`);\n  console.log(` Health check: http://localhost:${PORT}/health`);\n  console.log(` Telemetry endpoint: http://localhost:${PORT}/api/telemetry`);\n  console.log(` Dashboard: http://localhost:${PORT}/api/telemetry/summary`);\n  console.log(` License abuse detection: ENABLED`);\n  console.log(` Slack alerts: ${SLACK_WEBHOOK_URL ? 'ENABLED' : 'DISABLED'}`);\n  console.log(` Data retention: ${RETENTION_DAYS} days`);\n});\n\nexport default app;\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/api-gateway/server-enterprise.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CRASH_EVENTS_WINDOW' is assigned a value but never used.","line":20,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":31,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TELEMETRY_SUMMARY_URL' is assigned a value but never used.","line":32,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":33,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":34,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":37,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":56,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":126,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":126,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":137,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":185,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":185,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":240,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":240,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":264,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":264,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":288,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":288,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":309,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":309,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":406,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":406,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'next' is defined but never used.","line":422,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":422,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":423,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":423,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":432,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":432,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":433,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":433,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":434,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":434,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":435,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":435,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":436,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":436,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":437,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":437,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":438,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":438,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":439,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":439,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":440,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":440,"endColumn":10}],"suppressedMessages":[],"errorCount":26,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport dotenv from 'dotenv';\nimport { dashboardAuth } from './middleware/dashboardAuth.js';\nimport {\n  processLicenseEvent,\n  getLicenseStatus,\n  getAbuseStatistics,\n} from '../license-abuse-service/abuse-detector.js';\nimport { createResetToken, confirmReset } from '../license-reset-service/reset-handler.js';\n\n// Load environment variables\ndotenv.config();\n\n// In-memory storage for telemetry data\nconst telemetryBuffer = [];\nconst MAX_BUFFER_SIZE = 1000;\nconst CRASH_EVENTS_WINDOW = 60 * 60 * 1000; // 1 hour\n\n// Data retention configuration\nconst RETENTION_DAYS = 30;\nconst MS_PER_DAY = 86400000;\n\n// Schema version validation\nconst SUPPORTED_SCHEMA_VERSIONS = new Set([1]);\nconst REQUIRED_FIELDS = ['appVersion', 'os', 'agent', 'license', 'schemaVersion'];\n\n// Environment configuration\nconst SLACK_WEBHOOK_URL = process.env.SLACK_WEBHOOK_URL;\nconst TELEMETRY_SUMMARY_URL =\n  process.env.TELEMETRY_SUMMARY_URL ||\n  `http://localhost:${process.env.PORT || 3000}/api/telemetry/summary`;\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(\n  helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        scriptSrc: [\"'self'\"],\n        imgSrc: [\"'self'\", 'data:', 'https:'],\n        connectSrc: [\"'self'\", 'https://api.stripe.com'],\n      },\n    },\n  }),\n);\n\napp.use(\n  cors({\n    origin: process.env.ALLOWED_ORIGINS?.split(',') || [\n      'http://localhost:5173',\n      'https://rinawarptech.com',\n    ],\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'X-Dashboard-Token'],\n  }),\n);\n\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Rate limiting\nconst telemetryLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000,\n  max: 10,\n  message: { error: 'Telemetry rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst licenseLimiter = rateLimit({\n  windowMs: 1 * 60 * 1000,\n  max: 60,\n  message: { error: 'License check rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst resetLimiter = rateLimit({\n  windowMs: 10 * 60 * 1000,\n  max: 5,\n  message: { error: 'Reset request rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Validation functions\nfunction validateSchemaVersion(payload) {\n  if (typeof payload.schemaVersion !== 'number') {\n    return { ok: false, error: 'schemaVersion required' };\n  }\n  if (!SUPPORTED_SCHEMA_VERSIONS.has(payload.schemaVersion)) {\n    return { ok: false, error: `Unsupported schemaVersion ${payload.schemaVersion}` };\n  }\n  return { ok: true };\n}\n\nfunction validateRequiredFields(payload) {\n  for (const field of REQUIRED_FIELDS) {\n    if (payload[field] === undefined || payload[field] === null) {\n      return { ok: false, error: `Missing required field: ${field}` };\n    }\n  }\n  return { ok: true };\n}\n\nfunction purgeOldTelemetry() {\n  const cutoff = Date.now() - RETENTION_DAYS * MS_PER_DAY;\n  const originalLength = telemetryBuffer.length;\n\n  for (let i = telemetryBuffer.length - 1; i >= 0; i--) {\n    if (new Date(telemetryBuffer[i].timestamp).getTime() < cutoff) {\n      telemetryBuffer.splice(i, 1);\n    }\n  }\n\n  const removed = originalLength - telemetryBuffer.length;\n  if (removed > 0) {\n    console.log(` Purged ${removed} old telemetry records (${RETENTION_DAYS} days retention)`);\n  }\n}\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    gateway: 'api-gateway',\n    version: '1.2.0',\n    uptime: process.uptime(),\n    features: {\n      telemetry: true,\n      licenseAbuseDetection: true,\n      canaryUpdates: true,\n      licenseReset: true,\n      autoPromotion: true,\n      autoRollback: true,\n      slackAlerts: !!SLACK_WEBHOOK_URL,\n    },\n  });\n});\n\n// Enhanced telemetry endpoint with crash tracking\napp.post('/api/telemetry', telemetryLimiter, async (req, res) => {\n  try {\n    // Validation\n    const requiredCheck = validateRequiredFields(req.body);\n    if (!requiredCheck.ok) {\n      return res.status(400).json({ error: requiredCheck.error });\n    }\n\n    const schemaCheck = validateSchemaVersion(req.body);\n    if (!schemaCheck.ok) {\n      return res.status(400).json({ error: schemaCheck.error });\n    }\n\n    const telemetryData = req.body;\n\n    // Process crash events\n    let crashEvent = null;\n    if (telemetryData.customEvent && telemetryData.customEvent.event === 'app.crash') {\n      crashEvent = {\n        ...telemetryData.customEvent,\n        timestamp: new Date().toISOString(),\n      };\n    }\n\n    // Process license abuse detection\n    if (telemetryData.license && telemetryData.license.key) {\n      const abuseStatus = processLicenseEvent(\n        telemetryData.license.key,\n        telemetryData.deviceId || req.ip,\n        req.ip,\n        'valid',\n      );\n\n      if (abuseStatus.quarantined) {\n        console.log(\n          ` Quarantined license detected in telemetry: ${telemetryData.license.key.substring(0, 8)}...`,\n        );\n      }\n    }\n\n    // Sanitize and store telemetry\n    const sanitizedData = {\n      appVersion: String(telemetryData.appVersion).slice(0, 20),\n      os: ['win32', 'darwin', 'linux'].includes(telemetryData.os) ? telemetryData.os : 'unknown',\n      schemaVersion: telemetryData.schemaVersion,\n      agent: telemetryData.agent\n        ? {\n            status: ['online', 'offline'].includes(telemetryData.agent.status)\n              ? telemetryData.agent.status\n              : 'unknown',\n            pingMs:\n              typeof telemetryData.agent.pingMs === 'number'\n                ? Math.min(telemetryData.agent.pingMs, 60000)\n                : null,\n            crashEvent: telemetryData.agent.crashEvent || false,\n          }\n        : null,\n      license: telemetryData.license\n        ? {\n            tier: ['free', 'pro', 'enterprise'].includes(telemetryData.license.tier)\n              ? telemetryData.license.tier\n              : 'unknown',\n            offline: Boolean(telemetryData.license.offline),\n            key: telemetryData.license.key\n              ? telemetryData.license.key.substring(0, 8) + '...'\n              : null,\n          }\n        : null,\n      updateCohort: telemetryData.updateCohort || 'stable',\n      crashEvent: crashEvent,\n      timestamp: new Date().toISOString(),\n      ip: req.ip,\n    };\n\n    telemetryBuffer.push(sanitizedData);\n\n    if (telemetryBuffer.length > MAX_BUFFER_SIZE) {\n      telemetryBuffer.shift();\n    }\n\n    purgeOldTelemetry();\n\n    res.json({\n      success: true,\n      message: 'Telemetry received',\n      timestamp: sanitizedData.timestamp,\n      abuseStatus: telemetryData.license ? getLicenseStatus(telemetryData.license.key) : null,\n    });\n  } catch (error) {\n    console.error('Telemetry error:', error);\n    res.status(500).json({ error: 'Failed to process telemetry' });\n  }\n});\n\n// License abuse detection endpoint\napp.post('/api/license/check', licenseLimiter, async (req, res) => {\n  try {\n    const { licenseKey, deviceId } = req.body;\n\n    if (!licenseKey) {\n      return res.status(400).json({ error: 'License key required' });\n    }\n\n    const abuseStatus = processLicenseEvent(licenseKey, deviceId || req.ip, req.ip, 'valid');\n\n    res.json({\n      valid: true,\n      quarantined: abuseStatus.quarantined,\n      abuseScore: abuseStatus.abuseScore,\n      reason: abuseStatus.reason,\n      deviceId: deviceId ? deviceId.substring(0, 8) + '...' : null,\n    });\n  } catch (error) {\n    console.error('License check error:', error);\n    res.status(500).json({ error: 'License check failed' });\n  }\n});\n\n// License reset endpoints\napp.post('/api/license/reset/request', resetLimiter, async (req, res) => {\n  try {\n    const { licenseKey, deviceId, email } = req.body;\n\n    if (!licenseKey || !deviceId) {\n      return res.status(400).json({ error: 'License key and device ID required' });\n    }\n\n    const resetData = await createResetToken(licenseKey, deviceId, email);\n\n    res.json({\n      success: true,\n      token: resetData.token,\n      expiresAt: resetData.expiresAt,\n      ttlMinutes: resetData.ttlMinutes,\n      message: 'Reset token generated. Check your email for the token.',\n    });\n  } catch (error) {\n    console.error('License reset request error:', error);\n    res.status(400).json({ error: error.message });\n  }\n});\n\napp.post('/api/license/reset/confirm', resetLimiter, async (req, res) => {\n  try {\n    const { resetToken, deviceId } = req.body;\n\n    if (!resetToken || !deviceId) {\n      return res.status(400).json({ error: 'Reset token and device ID required' });\n    }\n\n    const result = await confirmReset(resetToken, deviceId);\n\n    res.json({\n      success: true,\n      message: result.message,\n      licenseKeyHash: result.licenseKeyHash,\n    });\n  } catch (error) {\n    console.error('License reset confirm error:', error);\n    res.status(400).json({ error: error.message });\n  }\n});\n\n// Enhanced dashboard with promotion/rollback metrics\napp.get('/api/telemetry/summary', dashboardAuth, async (req, res) => {\n  try {\n    const now = new Date();\n    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n    const lastHour = new Date(now.getTime() - 60 * 60 * 1000);\n\n    const recentTelemetry = telemetryBuffer.filter(\n      (item) => new Date(item.timestamp) > last24Hours,\n    );\n\n    const recentCrashEvents = telemetryBuffer.filter(\n      (item) => item.crashEvent && new Date(item.timestamp) > lastHour,\n    );\n\n    // Calculate agent health metrics\n    const agentRecords = recentTelemetry.filter((item) => item.agent && item.agent.status);\n    const onlineAgents = agentRecords.filter((item) => item.agent.status === 'online').length;\n    const totalAgentRecords = agentRecords.length;\n    const onlineRate = totalAgentRecords > 0 ? onlineAgents / totalAgentRecords : 1;\n\n    // Calculate crash rates\n    const crashEventsByCohort = {\n      canary: recentCrashEvents.filter((e) => e.updateCohort === 'canary').length,\n      stable: recentCrashEvents.filter((e) => e.updateCohort === 'stable').length,\n    };\n\n    const canaryRecords = recentTelemetry.filter((item) => item.updateCohort === 'canary');\n    const stableRecords = recentTelemetry.filter((item) => item.updateCohort === 'stable');\n\n    const canaryOnlineAgents = canaryRecords.filter(\n      (item) => item.agent?.status === 'online',\n    ).length;\n    const stableOnlineAgents = stableRecords.filter(\n      (item) => item.agent?.status === 'online',\n    ).length;\n\n    const canaryOnlineRate =\n      canaryRecords.length > 0 ? canaryOnlineAgents / canaryRecords.length : 1;\n    const stableOnlineRate =\n      stableRecords.length > 0 ? stableOnlineAgents / stableRecords.length : 1;\n\n    // Calculate crash rates (per hour)\n    const canaryCrashRate =\n      canaryRecords.length > 0 ? crashEventsByCohort.canary / canaryRecords.length : 0;\n    const stableCrashRate =\n      stableRecords.length > 0 ? crashEventsByCohort.stable / stableRecords.length : 0;\n\n    // Get latest canary version (simplified)\n    const latestCanaryVersion =\n      canaryRecords.length > 0\n        ? [...canaryRecords].reverse().find((r) => r.appVersion)?.appVersion\n        : null;\n\n    const summary = {\n      totalReports: recentTelemetry.length,\n      cohorts: {\n        canary: {\n          sampleCount: canaryRecords.length,\n          agentOnlineRate: canaryOnlineRate,\n          crashRate: canaryCrashRate,\n          crashEvents: crashEventsByCohort.canary,\n        },\n        stable: {\n          sampleCount: stableRecords.length,\n          agentOnlineRate: stableOnlineRate,\n          crashRate: stableCrashRate,\n          crashEvents: crashEventsByCohort.stable,\n        },\n      },\n      latestCanaryVersion: latestCanaryVersion,\n      agent: {\n        sampleCount: totalAgentRecords,\n        onlineRate: onlineRate,\n        onlineCount: onlineAgents,\n        offlineCount: totalAgentRecords - onlineAgents,\n        windowMinutes: 1440,\n      },\n      licenses: getAbuseStatistics(),\n      lastReport:\n        recentTelemetry.length > 0 ? recentTelemetry[recentTelemetry.length - 1].timestamp : null,\n      timeRange: {\n        from: last24Hours.toISOString(),\n        to: now.toISOString(),\n      },\n    };\n\n    res.json({\n      success: true,\n      data: summary,\n    });\n  } catch (error) {\n    console.error('Telemetry summary error:', error);\n    res.status(500).json({ error: 'Failed to generate telemetry summary' });\n  }\n});\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    error: 'Endpoint not found',\n    path: req.path,\n    method: req.method,\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Global error handler\napp.use((error, req, res, next) => {\n  console.error('Gateway error:', error);\n  res.status(500).json({\n    error: 'Internal server error',\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Start server\napp.listen(PORT, () => {\n  console.log(` API Gateway running on port ${PORT}`);\n  console.log(` Health check: http://localhost:${PORT}/health`);\n  console.log(` Telemetry endpoint: http://localhost:${PORT}/api/telemetry`);\n  console.log(` Dashboard: http://localhost:${PORT}/api/telemetry/summary`);\n  console.log(` License reset: http://localhost:${PORT}/api/license/reset/*`);\n  console.log(` License abuse detection: ENABLED`);\n  console.log(` Canary auto-promotion: ENABLED`);\n  console.log(` Auto-rollback: ENABLED`);\n  console.log(` Slack alerts: ${SLACK_WEBHOOK_URL ? 'ENABLED' : 'DISABLED'}`);\n});\n\nexport default app;\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/api-gateway/server-hardened.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":21,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":22,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":23,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":23,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":26,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":27,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":33,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'initialSize' is assigned a value but never used.","line":58,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":64,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":73,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":78,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":83,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":83,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":88,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":88,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":93,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":100,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":100,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":119,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":119,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":189,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":189,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is assigned a value but never used.","line":214,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":214,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":234,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":234,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":242,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":242,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":260,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":260,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":301,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":301,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":328,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":328,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":381,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":381,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":382,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":382,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":398,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":398,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":469,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":469,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":487,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":487,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'res' is defined but never used.","line":490,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":490,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":491,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":491,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":518,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":518,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'res' is defined but never used.","line":521,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":521,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":522,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":522,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":534,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":534,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'res' is defined but never used.","line":537,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":537,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":538,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":538,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":545,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":545,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":578,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":578,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'next' is defined but never used.","line":594,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":594,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":595,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":595,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":604,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":604,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":605,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":605,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":606,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":606,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":607,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":607,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":608,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":608,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":609,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":609,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":610,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":610,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":611,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":611,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":615,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":615,"endColumn":12}],"suppressedMessages":[],"errorCount":48,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport axios from 'axios';\nimport dotenv from 'dotenv';\nimport { createProxyMiddleware } from 'http-proxy-middleware';\n\n// Load environment variables\ndotenv.config();\n\n// In-memory storage for telemetry data with growth caps\nconst telemetryBuffer = [];\nconst MAX_BUFFER_SIZE = 1000;\nconst RETENTION_DAYS = 30; //  Storage growth cap: 30 days\n\n// Schema versioning for future-proofing\nconst CURRENT_SCHEMA_VERSION = 1;\n\n// Environment configuration\nconst LICENSING_SERVICE_URL = process.env.LICENSING_SERVICE_URL || 'http://localhost:3003';\nconst AUTH_SERVICE_URL = process.env.AUTH_SERVICE_URL || 'http://localhost:3001';\nconst DOMAIN = process.env.DOMAIN || 'http://localhost:3000';\n\n// Simple dashboard auth (basic token)\nconst DASHBOARD_TOKEN = process.env.DASHBOARD_TOKEN || 'demo-token-123';\nconst DASHBOARD_AUTH_ENABLED = process.env.DASHBOARD_AUTH_ENABLED === 'true';\n\n// Telemetry aggregation function with schema validation\nfunction aggregateTelemetry(data) {\n  // SCHEMA VALIDATION: Reject incompatible versions\n  if (data.schemaVersion && data.schemaVersion !== CURRENT_SCHEMA_VERSION) {\n    console.warn(\n      `Schema version mismatch: expected ${CURRENT_SCHEMA_VERSION}, got ${data.schemaVersion}`,\n    );\n    return null; // Silently reject incompatible data\n  }\n\n  const now = new Date();\n  const hour = Math.floor(now.getHours() / 6) * 6; // Group by 6-hour windows\n\n  return {\n    timestamp: now.toISOString(),\n    hour: hour,\n    schemaVersion: data.schemaVersion || 0,\n    appVersion: data.appVersion,\n    os: data.os,\n    agent: data.agent,\n    license: data.license,\n  };\n}\n\n// Storage cleanup: Remove old data to prevent DB creep\nfunction cleanupOldTelemetry() {\n  const cutoffDate = new Date();\n  cutoffDate.setDate(cutoffDate.getDate() - RETENTION_DAYS);\n\n  const initialSize = telemetryBuffer.length;\n  const filteredData = telemetryBuffer.filter((item) => new Date(item.timestamp) > cutoffDate);\n\n  if (filteredData.length < telemetryBuffer.length) {\n    const removed = telemetryBuffer.length - filteredData.length;\n    telemetryBuffer.splice(0, telemetryBuffer.length, ...filteredData);\n    console.log(\n      ` Storage cleanup: removed ${removed} old telemetry records (${RETENTION_DAYS} day retention)`,\n    );\n  }\n}\n\n// Enhanced Service registry\nconst SERVICE_REGISTRY = {\n  'auth-service': {\n    url: process.env.AUTH_SERVICE_URL || 'http://localhost:3001',\n    timeout: 5000,\n    healthCheck: '/health',\n  },\n  'revenue-service': {\n    url: process.env.REVENUE_SERVICE_URL || 'http://localhost:3002',\n    timeout: 10000,\n    healthCheck: '/health',\n  },\n  'licensing-service': {\n    url: process.env.LICENSING_SERVICE_URL || 'http://localhost:3003',\n    timeout: 5000,\n    healthCheck: '/health',\n  },\n  'ai-music-video-service': {\n    url: process.env.AI_MUSIC_VIDEO_SERVICE_URL || 'http://localhost:3004',\n    timeout: 30000,\n    healthCheck: '/health',\n  },\n  'ai-service': {\n    url: process.env.AI_SERVICE_URL || 'http://localhost:3004',\n    timeout: 30000,\n    healthCheck: '/health',\n  },\n};\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(\n  helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        scriptSrc: [\"'self'\"],\n        imgSrc: [\"'self'\", 'data:', 'https:'],\n        connectSrc: [\"'self'\", 'https://api.stripe.com'],\n      },\n    },\n  }),\n);\n\napp.use(\n  cors({\n    origin: process.env.ALLOWED_ORIGINS?.split(',') || [\n      'http://localhost:5173',\n      'https://rinawarptech.com',\n    ],\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],\n  }),\n);\n\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Rate limiting\nconst generalLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 1000,\n  message: { error: 'Too many requests' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst strictLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  message: { error: 'Rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst telemetryLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  max: 10, // Max 10 telemetry reports per IP per 5 minutes\n  message: { error: 'Telemetry rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use('/api/', generalLimiter);\n\n// Authentication middleware\nconst authenticateToken = async (req, res, next) => {\n  try {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1];\n\n    if (!token) {\n      return res.status(401).json({ error: 'Access token required' });\n    }\n\n    // Verify token with auth service\n    const response = await axios.post(\n      `${AUTH_SERVICE_URL}/auth/verify`,\n      {},\n      {\n        headers: {\n          Authorization: `Bearer ${token}`,\n          'Content-Type': 'application/json',\n        },\n        timeout: 5000,\n      },\n    );\n\n    if (response.data.valid) {\n      req.user = response.data.user;\n      next();\n    } else {\n      res.status(403).json({ error: 'Invalid or expired token' });\n    }\n  } catch (error) {\n    console.error('Auth verification error:', error.message);\n    res.status(403).json({ error: 'Authentication failed' });\n  }\n};\n\n// Dashboard authentication middleware\nconst authenticateDashboard = (req, res, next) => {\n  if (!DASHBOARD_AUTH_ENABLED) {\n    return next(); // Auth disabled for development\n  }\n\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token || token !== DASHBOARD_TOKEN) {\n    return res.status(401).json({\n      error: 'Unauthorized',\n      message: 'Valid dashboard token required',\n    });\n  }\n\n  next();\n};\n\n// Service proxy function\nconst proxyToService = (serviceName, options = {}) => {\n  return async (req, res) => {\n    try {\n      const service = SERVICE_REGISTRY[serviceName];\n\n      if (!service) {\n        return res.status(503).json({ error: `Service ${serviceName} not available` });\n      }\n\n      let targetPath = req.path;\n      let queryString = req.url.split('?')[1] || '';\n\n      if (serviceName === 'auth-service') {\n        targetPath = targetPath.replace(/^\\/auth/, '');\n      } else if (serviceName === 'ai-service') {\n        targetPath = targetPath.replace(/^\\/ai/, '');\n      }\n\n      const targetUrl = `${service.url}${targetPath}${queryString ? '?' + queryString : ''}`;\n\n      console.log(`Proxying ${req.method} ${req.path} to ${serviceName}: ${targetUrl}`);\n\n      const config = {\n        method: req.method,\n        url: targetUrl,\n        data: req.body,\n        headers: {\n          ...req.headers,\n          host: new URL(service.url).host,\n          'x-forwarded-for': req.ip,\n          'x-forwarded-proto': req.protocol,\n        },\n        timeout: service.timeout,\n        validateStatus: () => true,\n      };\n\n      const response = await axios(config);\n\n      Object.entries(response.headers).forEach(([key, value]) => {\n        if (key.toLowerCase() !== 'transfer-encoding') {\n          res.setHeader(key, value);\n        }\n      });\n\n      res.status(response.status).send(response.data);\n    } catch (error) {\n      console.error(`Service ${serviceName} error:`, error.message);\n\n      if (error.code === 'ECONNREFUSED') {\n        res.status(503).json({ error: `Service ${serviceName} is unavailable` });\n      } else if (error.code === 'ENOTFOUND') {\n        res.status(503).json({ error: `Service ${serviceName} host not found` });\n      } else {\n        res.status(500).json({ error: `Service ${serviceName} request failed` });\n      }\n    }\n  };\n};\n\n// Health check endpoint\napp.get('/health', async (req, res) => {\n  const healthChecks = {};\n\n  for (const [serviceName, service] of Object.entries(SERVICE_REGISTRY)) {\n    try {\n      const response = await axios.get(`${service.url}${service.healthCheck}`, {\n        timeout: 3000,\n        validateStatus: () => true,\n      });\n      healthChecks[serviceName] = {\n        status: response.status === 200 ? 'healthy' : 'unhealthy',\n        responseTime: response.headers['x-response-time'] || 'unknown',\n      };\n    } catch (error) {\n      healthChecks[serviceName] = {\n        status: 'unhealthy',\n        error: error.message,\n      };\n    }\n  }\n\n  res.json({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    gateway: 'api-gateway-hardened',\n    version: '1.0.2',\n    services: healthChecks,\n    uptime: process.uptime(),\n    telemetry: {\n      retentionDays: RETENTION_DAYS,\n      currentRecords: telemetryBuffer.length,\n      schemaVersion: CURRENT_SCHEMA_VERSION,\n      dashboardAuth: DASHBOARD_AUTH_ENABLED,\n    },\n  });\n});\n\n// HARDENED TELEMETRY ENDPOINTS\n\n// Public telemetry endpoint with schema validation and storage caps\napp.post('/api/telemetry', telemetryLimiter, async (req, res) => {\n  try {\n    const telemetryData = req.body;\n\n    // Validate required fields\n    const requiredFields = ['appVersion', 'os'];\n    for (const field of requiredFields) {\n      if (!telemetryData[field]) {\n        return res.status(400).json({ error: `Missing required field: ${field}` });\n      }\n    }\n\n    // SCHEMA VALIDATION: Future-proof against breaking changes\n    if (telemetryData.schemaVersion && telemetryData.schemaVersion !== CURRENT_SCHEMA_VERSION) {\n      console.warn(\n        `Schema version rejected: expected ${CURRENT_SCHEMA_VERSION}, got ${telemetryData.schemaVersion}`,\n      );\n      return res.status(204).send(); // Silent rejection for incompatible versions\n    }\n\n    // Validate data types and sanitize\n    const sanitizedData = {\n      schemaVersion: telemetryData.schemaVersion || 0,\n      appVersion: String(telemetryData.appVersion).slice(0, 20),\n      os: ['win32', 'darwin', 'linux'].includes(telemetryData.os) ? telemetryData.os : 'unknown',\n      agent: telemetryData.agent\n        ? {\n            status: ['online', 'offline'].includes(telemetryData.agent.status)\n              ? telemetryData.agent.status\n              : 'unknown',\n            pingMs:\n              typeof telemetryData.agent.pingMs === 'number'\n                ? Math.min(telemetryData.agent.pingMs, 60000)\n                : null,\n          }\n        : null,\n      license: telemetryData.license\n        ? {\n            tier: ['free', 'pro', 'enterprise'].includes(telemetryData.license.tier)\n              ? telemetryData.license.tier\n              : 'unknown',\n            offline: Boolean(telemetryData.license.offline),\n          }\n        : null,\n      timestamp: new Date().toISOString(),\n      ip: req.ip, // For basic rate limiting, not stored permanently\n    };\n\n    const aggregatedData = aggregateTelemetry(sanitizedData);\n    if (!aggregatedData) {\n      return res.status(204).send(); // Silent rejection for schema mismatch\n    }\n\n    // STORAGE GROWTH CAP: Prevent database creep\n    telemetryBuffer.push(aggregatedData);\n\n    // Keep buffer size manageable\n    if (telemetryBuffer.length > MAX_BUFFER_SIZE) {\n      telemetryBuffer.shift();\n    }\n\n    // Periodic cleanup (every 100 records)\n    if (telemetryBuffer.length % 100 === 0) {\n      cleanupOldTelemetry();\n    }\n\n    // Log for monitoring (development)\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(' Telemetry received:', {\n        version: sanitizedData.appVersion,\n        os: sanitizedData.os,\n        agentStatus: sanitizedData.agent?.status,\n        licenseTier: sanitizedData.license?.tier,\n        schemaVersion: sanitizedData.schemaVersion,\n      });\n    }\n\n    res.json({\n      success: true,\n      message: 'Telemetry received',\n      timestamp: sanitizedData.timestamp,\n      retentionDays: RETENTION_DAYS,\n    });\n  } catch (error) {\n    console.error('Telemetry error:', error);\n    res.status(500).json({ error: 'Failed to process telemetry' });\n  }\n});\n\n// Telemetry aggregation endpoint with authentication\napp.get('/api/telemetry/summary', authenticateDashboard, async (req, res) => {\n  try {\n    const now = new Date();\n    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    // STORAGE CAPS: Filter recent telemetry with retention policy\n    const recentTelemetry = telemetryBuffer.filter((item) => {\n      const itemDate = new Date(item.timestamp);\n      return (\n        itemDate > last24Hours &&\n        itemDate > new Date(Date.now() - RETENTION_DAYS * 24 * 60 * 60 * 1000)\n      );\n    });\n\n    // Aggregate statistics\n    const summary = {\n      totalReports: recentTelemetry.length,\n      byOS: {},\n      byVersion: {},\n      byAgentStatus: {},\n      byLicenseTier: {},\n      bySchemaVersion: {},\n      lastReport:\n        recentTelemetry.length > 0 ? recentTelemetry[recentTelemetry.length - 1].timestamp : null,\n      timeRange: {\n        from: last24Hours.toISOString(),\n        to: now.toISOString(),\n      },\n      storageInfo: {\n        retentionDays: RETENTION_DAYS,\n        totalStored: telemetryBuffer.length,\n        currentSchema: CURRENT_SCHEMA_VERSION,\n      },\n    };\n\n    // Calculate aggregates\n    recentTelemetry.forEach((item) => {\n      // By OS\n      summary.byOS[item.os] = (summary.byOS[item.os] || 0) + 1;\n\n      // By Version\n      summary.byVersion[item.appVersion] = (summary.byVersion[item.appVersion] || 0) + 1;\n\n      // By Agent Status\n      if (item.agent?.status) {\n        summary.byAgentStatus[item.agent.status] =\n          (summary.byAgentStatus[item.agent.status] || 0) + 1;\n      }\n\n      // By License Tier\n      if (item.license?.tier) {\n        summary.byLicenseTier[item.license.tier] =\n          (summary.byLicenseTier[item.license.tier] || 0) + 1;\n      }\n\n      // By Schema Version (for migration tracking)\n      const schemaVer = item.schemaVersion || 0;\n      summary.bySchemaVersion[schemaVer] = (summary.bySchemaVersion[schemaVer] || 0) + 1;\n    });\n\n    res.json({\n      success: true,\n      data: summary,\n    });\n  } catch (error) {\n    console.error('Telemetry summary error:', error);\n    res.status(500).json({ error: 'Failed to generate telemetry summary' });\n  }\n});\n\n// Public endpoints\napp.use('/health', generalLimiter);\n\n// Authentication routes\napp.use(\n  '/auth',\n  createProxyMiddleware({\n    target: AUTH_SERVICE_URL,\n    changeOrigin: true,\n    pathRewrite: {\n      '^/auth': '',\n    },\n    onError: (err, req, res) => {\n      console.error('Auth service proxy error:', err);\n      res.status(503).json({ error: 'Authentication service unavailable' });\n    },\n    onProxyReq: (proxyReq, req, res) => {\n      console.log(\n        `[AUTH] ${req.method} ${req.path} -> ${AUTH_SERVICE_URL}${req.path.replace('/auth', '')}`,\n      );\n    },\n  }),\n);\n\n// AI service routes\napp.use('/ai', proxyToService('ai-service'));\n\n// Protected API routes\napp.use('/api/revenue', authenticateToken, strictLimiter, proxyToService('revenue-service'));\napp.use('/api/licensing', authenticateToken, strictLimiter, proxyToService('licensing-service'));\napp.use(\n  '/api/ai-music-video',\n  authenticateToken,\n  strictLimiter,\n  proxyToService('ai-music-video-service'),\n);\n\n// License check proxy\napp.use(\n  '/license/check',\n  createProxyMiddleware({\n    target: LICENSING_SERVICE_URL,\n    changeOrigin: true,\n    onError: (err, req, res) => {\n      console.error('License service proxy error:', err);\n      res.status(503).json({ error: 'License service unavailable' });\n    },\n    onProxyReq: (proxyReq, req, res) => {\n      console.log(`[LICENSE] ${req.method} ${req.path} -> ${LICENSING_SERVICE_URL}${req.path}`);\n    },\n  }),\n);\n\n// Auth verify proxy\napp.use(\n  '/auth/verify',\n  createProxyMiddleware({\n    target: AUTH_SERVICE_URL,\n    changeOrigin: true,\n    onError: (err, req, res) => {\n      console.error('Auth verify proxy error:', err);\n      res.status(200).json({ valid: false, user: null });\n    },\n    onProxyReq: (proxyReq, req, res) => {\n      console.log(`[AUTH-VERIFY] ${req.method} ${req.path} -> ${AUTH_SERVICE_URL}${req.path}`);\n    },\n  }),\n);\n\n// Stripe webhook endpoint\napp.post('/api/stripe/webhook', express.raw({ type: 'application/json' }), (req, res) => {\n  console.log('Stripe webhook received:', req.headers['stripe-signature']);\n  res.status(200).json({ received: true });\n});\n\n// Checkout endpoint\napp.post('/api/checkout-v2', express.json({ limit: '1mb' }), async (req, res) => {\n  try {\n    const { plan, successUrl, cancelUrl } = req.body;\n\n    if (!plan) {\n      return res.status(400).json({ error: 'Plan is required' });\n    }\n\n    const validPlans = [\n      'starter-monthly',\n      'creator-monthly',\n      'pro-monthly',\n      'enterprise-yearly',\n      'pioneer-lifetime',\n      'founder-lifetime',\n    ];\n\n    if (!validPlans.includes(plan)) {\n      return res.status(400).json({ error: 'Invalid plan code' });\n    }\n\n    res.json({\n      sessionId: `cs_test_${Date.now()}`,\n      plan,\n      successUrl: successUrl || `${DOMAIN}/success.html`,\n      cancelUrl: cancelUrl || `${DOMAIN}/cancel.html`,\n    });\n  } catch (error) {\n    console.error('Checkout error:', error);\n    res.status(500).json({ error: 'Checkout failed' });\n  }\n});\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    error: 'Endpoint not found',\n    path: req.path,\n    method: req.method,\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Global error handler\napp.use((error, req, res, next) => {\n  console.error('Gateway error:', error);\n  res.status(500).json({\n    error: 'Internal server error',\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Start server\napp.listen(PORT, () => {\n  console.log(` Hardened API Gateway running on port ${PORT}`);\n  console.log(` Health check: http://localhost:${PORT}/health`);\n  console.log(` Telemetry endpoint: http://localhost:${PORT}/api/telemetry`);\n  console.log(` Dashboard auth: ${DASHBOARD_AUTH_ENABLED ? 'ENABLED' : 'DISABLED'}`);\n  console.log(`  Data retention: ${RETENTION_DAYS} days`);\n  console.log(` Schema version: ${CURRENT_SCHEMA_VERSION}`);\n  console.log(` Auth service: ${AUTH_SERVICE_URL}`);\n  console.log(` License service: ${LICENSING_SERVICE_URL}`);\n});\n\n// Cleanup old telemetry every hour\nsetInterval(cleanupOldTelemetry, 60 * 60 * 1000);\n\nexport default app;\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/api-gateway/server-telemetry.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'aggregateTelemetry' is defined but never used.","line":17,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":34,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":39,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":44,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":49,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":54,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":54,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":59,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":66,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":67,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":68,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":71,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":90,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":160,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":160,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is assigned a value but never used.","line":166,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":166,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":188,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":188,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":197,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":197,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":216,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":216,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":258,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":258,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":313,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":313,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":314,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":314,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":328,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":328,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":385,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":385,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":403,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":403,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'res' is defined but never used.","line":406,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":406,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":407,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":407,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":434,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":434,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'res' is defined but never used.","line":437,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":437,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":438,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":438,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":450,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":450,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'res' is defined but never used.","line":453,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":453,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":454,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":454,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":463,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":463,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":499,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":499,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'next' is defined but never used.","line":515,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":515,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":516,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":516,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":525,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":525,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":526,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":526,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":527,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":527,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":528,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":528,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":529,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":529,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":530,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":530,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":530,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":530,"endColumn":45}],"suppressedMessages":[],"errorCount":42,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport axios from 'axios';\nimport dotenv from 'dotenv';\nimport { createProxyMiddleware } from 'http-proxy-middleware';\n\n// Load environment variables\ndotenv.config();\n\n// In-memory storage for telemetry data (replace with database in production)\nconst telemetryBuffer = [];\nconst MAX_BUFFER_SIZE = 1000;\n\n// Telemetry aggregation function\nfunction aggregateTelemetry(data) {\n  const now = new Date();\n  const hour = Math.floor(now.getHours() / 6) * 6; // Group by 6-hour windows\n\n  return {\n    timestamp: now.toISOString(),\n    hour: hour,\n    appVersion: data.appVersion,\n    os: data.os,\n    agent: data.agent,\n    license: data.license,\n  };\n}\n\n// Enhanced Service registry with telemetry service\nconst SERVICE_REGISTRY = {\n  'auth-service': {\n    url: process.env.AUTH_SERVICE_URL || 'http://localhost:3001',\n    timeout: 5000,\n    healthCheck: '/health',\n  },\n  'revenue-service': {\n    url: process.env.REVENUE_SERVICE_URL || 'http://localhost:3002',\n    timeout: 10000,\n    healthCheck: '/health',\n  },\n  'licensing-service': {\n    url: process.env.LICENSING_SERVICE_URL || 'http://localhost:3003',\n    timeout: 5000,\n    healthCheck: '/health',\n  },\n  'ai-music-video-service': {\n    url: process.env.AI_MUSIC_VIDEO_SERVICE_URL || 'http://localhost:3004',\n    timeout: 30000,\n    healthCheck: '/health',\n  },\n  'ai-service': {\n    url: process.env.AI_SERVICE_URL || 'http://localhost:3004',\n    timeout: 30000,\n    healthCheck: '/health',\n  },\n  'telemetry-service': {\n    url: process.env.TELEMETRY_SERVICE_URL || 'http://localhost:3006',\n    timeout: 3000,\n    healthCheck: '/health',\n  },\n};\n\n// Environment configuration\nconst LICENSING_SERVICE_URL = process.env.LICENSING_SERVICE_URL || 'http://localhost:3003';\nconst AUTH_SERVICE_URL = process.env.AUTH_SERVICE_URL || 'http://localhost:3001';\nconst DOMAIN = process.env.DOMAIN || 'http://localhost:3000';\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(\n  helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        scriptSrc: [\"'self'\"],\n        imgSrc: [\"'self'\", 'data:', 'https:'],\n        connectSrc: [\"'self'\", 'https://api.stripe.com'],\n      },\n    },\n  }),\n);\n\napp.use(\n  cors({\n    origin: process.env.ALLOWED_ORIGINS?.split(',') || [\n      'http://localhost:5173',\n      'https://rinawarptech.com',\n    ],\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],\n  }),\n);\n\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Rate limiting with more specific rules\nconst generalLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 1000,\n  message: { error: 'Too many requests' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst strictLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  message: { error: 'Rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst telemetryLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  max: 10, // Max 10 telemetry reports per IP per 5 minutes\n  message: { error: 'Telemetry rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use('/api/', generalLimiter);\n\n// FIXED: Real Authentication middleware\nconst authenticateToken = async (req, res, next) => {\n  try {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1];\n\n    if (!token) {\n      return res.status(401).json({ error: 'Access token required' });\n    }\n\n    // Verify token with auth service\n    const response = await axios.post(\n      `${AUTH_SERVICE_URL}/auth/verify`,\n      {},\n      {\n        headers: {\n          Authorization: `Bearer ${token}`,\n          'Content-Type': 'application/json',\n        },\n        timeout: 5000,\n      },\n    );\n\n    if (response.data.valid) {\n      req.user = response.data.user;\n      next();\n    } else {\n      res.status(403).json({ error: 'Invalid or expired token' });\n    }\n  } catch (error) {\n    console.error('Auth verification error:', error.message);\n    res.status(403).json({ error: 'Authentication failed' });\n  }\n};\n\n// Service proxy function with improved error handling\nconst proxyToService = (serviceName, options = {}) => {\n  return async (req, res) => {\n    try {\n      const service = SERVICE_REGISTRY[serviceName];\n\n      if (!service) {\n        return res.status(503).json({ error: `Service ${serviceName} not available` });\n      }\n\n      // Determine target path\n      let targetPath = req.path;\n      let queryString = req.url.split('?')[1] || '';\n\n      // Handle path rewriting based on service type\n      if (serviceName === 'auth-service') {\n        targetPath = targetPath.replace(/^\\/auth/, '');\n      } else if (serviceName === 'ai-service') {\n        targetPath = targetPath.replace(/^\\/ai/, '');\n      }\n\n      const targetUrl = `${service.url}${targetPath}${queryString ? '?' + queryString : ''}`;\n\n      console.log(`Proxying ${req.method} ${req.path} to ${serviceName}: ${targetUrl}`);\n\n      // Prepare request configuration\n      const config = {\n        method: req.method,\n        url: targetUrl,\n        data: req.body,\n        headers: {\n          ...req.headers,\n          host: new URL(service.url).host,\n          'x-forwarded-for': req.ip,\n          'x-forwarded-proto': req.protocol,\n        },\n        timeout: service.timeout,\n        validateStatus: () => true, // Don't throw on non-2xx status codes\n      };\n\n      const response = await axios(config);\n\n      // Forward response with proper status and headers\n      Object.entries(response.headers).forEach(([key, value]) => {\n        if (key.toLowerCase() !== 'transfer-encoding') {\n          res.setHeader(key, value);\n        }\n      });\n\n      res.status(response.status).send(response.data);\n    } catch (error) {\n      console.error(`Service ${serviceName} error:`, error.message);\n\n      if (error.code === 'ECONNREFUSED') {\n        res.status(503).json({ error: `Service ${serviceName} is unavailable` });\n      } else if (error.code === 'ENOTFOUND') {\n        res.status(503).json({ error: `Service ${serviceName} host not found` });\n      } else {\n        res.status(500).json({ error: `Service ${serviceName} request failed` });\n      }\n    }\n  };\n};\n\n// Health check endpoint\napp.get('/health', async (req, res) => {\n  const healthChecks = {};\n\n  // Check each service\n  for (const [serviceName, service] of Object.entries(SERVICE_REGISTRY)) {\n    try {\n      const response = await axios.get(`${service.url}${service.healthCheck}`, {\n        timeout: 3000,\n        validateStatus: () => true,\n      });\n      healthChecks[serviceName] = {\n        status: response.status === 200 ? 'healthy' : 'unhealthy',\n        responseTime: response.headers['x-response-time'] || 'unknown',\n      };\n    } catch (error) {\n      healthChecks[serviceName] = {\n        status: 'unhealthy',\n        error: error.message,\n      };\n    }\n  }\n\n  res.json({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    gateway: 'api-gateway',\n    version: '1.0.1',\n    services: healthChecks,\n    uptime: process.uptime(),\n  });\n});\n\n// TELEMETRY ENDPOINTS\n\n// Public telemetry endpoint (no auth required, rate limited)\napp.post('/api/telemetry', telemetryLimiter, async (req, res) => {\n  try {\n    const telemetryData = req.body;\n\n    // Validate required fields\n    const requiredFields = ['appVersion', 'os'];\n    for (const field of requiredFields) {\n      if (!telemetryData[field]) {\n        return res.status(400).json({ error: `Missing required field: ${field}` });\n      }\n    }\n\n    // Validate data types and sanitize\n    const sanitizedData = {\n      appVersion: String(telemetryData.appVersion).slice(0, 20), // Prevent oversized data\n      os: ['win32', 'darwin', 'linux'].includes(telemetryData.os) ? telemetryData.os : 'unknown',\n      agent: telemetryData.agent\n        ? {\n            status: ['online', 'offline'].includes(telemetryData.agent.status)\n              ? telemetryData.agent.status\n              : 'unknown',\n            pingMs:\n              typeof telemetryData.agent.pingMs === 'number'\n                ? Math.min(telemetryData.agent.pingMs, 60000)\n                : null,\n          }\n        : null,\n      license: telemetryData.license\n        ? {\n            tier: ['free', 'pro', 'enterprise'].includes(telemetryData.license.tier)\n              ? telemetryData.license.tier\n              : 'unknown',\n            offline: Boolean(telemetryData.license.offline),\n          }\n        : null,\n      timestamp: new Date().toISOString(),\n      ip: req.ip, // For basic rate limiting, not stored permanently\n    };\n\n    // Store in memory buffer (replace with database in production)\n    telemetryBuffer.push(sanitizedData);\n\n    // Keep buffer size manageable\n    if (telemetryBuffer.length > MAX_BUFFER_SIZE) {\n      telemetryBuffer.shift();\n    }\n\n    // Log for monitoring (development)\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(' Telemetry received:', {\n        version: sanitizedData.appVersion,\n        os: sanitizedData.os,\n        agentStatus: sanitizedData.agent?.status,\n        licenseTier: sanitizedData.license?.tier,\n      });\n    }\n\n    res.json({\n      success: true,\n      message: 'Telemetry received',\n      timestamp: sanitizedData.timestamp,\n    });\n  } catch (error) {\n    console.error('Telemetry error:', error);\n    res.status(500).json({ error: 'Failed to process telemetry' });\n  }\n});\n\n// Telemetry aggregation endpoint (for dashboard)\napp.get('/api/telemetry/summary', authenticateToken, async (req, res) => {\n  try {\n    const now = new Date();\n    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    // Filter recent telemetry\n    const recentTelemetry = telemetryBuffer.filter(\n      (item) => new Date(item.timestamp) > last24Hours,\n    );\n\n    // Aggregate statistics\n    const summary = {\n      totalReports: recentTelemetry.length,\n      byOS: {},\n      byVersion: {},\n      byAgentStatus: {},\n      byLicenseTier: {},\n      lastReport:\n        recentTelemetry.length > 0 ? recentTelemetry[recentTelemetry.length - 1].timestamp : null,\n      timeRange: {\n        from: last24Hours.toISOString(),\n        to: now.toISOString(),\n      },\n    };\n\n    // Calculate aggregates\n    recentTelemetry.forEach((item) => {\n      // By OS\n      summary.byOS[item.os] = (summary.byOS[item.os] || 0) + 1;\n\n      // By Version\n      summary.byVersion[item.appVersion] = (summary.byVersion[item.appVersion] || 0) + 1;\n\n      // By Agent Status\n      if (item.agent?.status) {\n        summary.byAgentStatus[item.agent.status] =\n          (summary.byAgentStatus[item.agent.status] || 0) + 1;\n      }\n\n      // By License Tier\n      if (item.license?.tier) {\n        summary.byLicenseTier[item.license.tier] =\n          (summary.byLicenseTier[item.license.tier] || 0) + 1;\n      }\n    });\n\n    res.json({\n      success: true,\n      data: summary,\n    });\n  } catch (error) {\n    console.error('Telemetry summary error:', error);\n    res.status(500).json({ error: 'Failed to generate telemetry summary' });\n  }\n});\n\n// Public endpoints (no authentication required)\napp.use('/health', generalLimiter);\n\n// FIXED: Authentication routes - using createProxyMiddleware for consistency\napp.use(\n  '/auth',\n  createProxyMiddleware({\n    target: AUTH_SERVICE_URL,\n    changeOrigin: true,\n    pathRewrite: {\n      '^/auth': '', // Remove /auth prefix when forwarding to auth service\n    },\n    onError: (err, req, res) => {\n      console.error('Auth service proxy error:', err);\n      res.status(503).json({ error: 'Authentication service unavailable' });\n    },\n    onProxyReq: (proxyReq, req, res) => {\n      console.log(\n        `[AUTH] ${req.method} ${req.path} -> ${AUTH_SERVICE_URL}${req.path.replace('/auth', '')}`,\n      );\n    },\n  }),\n);\n\n// AI service routes (public for now)\napp.use('/ai', proxyToService('ai-service'));\n\n// FIXED: Protected API routes with real authentication\napp.use('/api/revenue', authenticateToken, strictLimiter, proxyToService('revenue-service'));\napp.use('/api/licensing', authenticateToken, strictLimiter, proxyToService('licensing-service'));\napp.use(\n  '/api/ai-music-video',\n  authenticateToken,\n  strictLimiter,\n  proxyToService('ai-music-video-service'),\n);\n\n// License check proxy (may be public or require different auth)\napp.use(\n  '/license/check',\n  createProxyMiddleware({\n    target: LICENSING_SERVICE_URL,\n    changeOrigin: true,\n    onError: (err, req, res) => {\n      console.error('License service proxy error:', err);\n      res.status(503).json({ error: 'License service unavailable' });\n    },\n    onProxyReq: (proxyReq, req, res) => {\n      console.log(`[LICENSE] ${req.method} ${req.path} -> ${LICENSING_SERVICE_URL}${req.path}`);\n    },\n  }),\n);\n\n// Auth verify proxy (dedicated endpoint)\napp.use(\n  '/auth/verify',\n  createProxyMiddleware({\n    target: AUTH_SERVICE_URL,\n    changeOrigin: true,\n    onError: (err, req, res) => {\n      console.error('Auth verify proxy error:', err);\n      res.status(200).json({ valid: false, user: null });\n    },\n    onProxyReq: (proxyReq, req, res) => {\n      console.log(`[AUTH-VERIFY] ${req.method} ${req.path} -> ${AUTH_SERVICE_URL}${req.path}`);\n    },\n  }),\n);\n\n// Stripe webhook endpoint (special handling)\napp.post('/api/stripe/webhook', express.raw({ type: 'application/json' }), (req, res) => {\n  // This endpoint should handle Stripe webhooks directly\n  // For now, just acknowledge receipt\n  console.log('Stripe webhook received:', req.headers['stripe-signature']);\n  res.status(200).json({ received: true });\n});\n\n// FIXED: Checkout endpoint with plan validation\napp.post('/api/checkout-v2', express.json({ limit: '1mb' }), async (req, res) => {\n  try {\n    const { plan, successUrl, cancelUrl } = req.body;\n\n    if (!plan) {\n      return res.status(400).json({ error: 'Plan is required' });\n    }\n\n    // Validate plan against known plans\n    const validPlans = [\n      'starter-monthly',\n      'creator-monthly',\n      'pro-monthly',\n      'enterprise-yearly',\n      'pioneer-lifetime',\n      'founder-lifetime',\n    ];\n\n    if (!validPlans.includes(plan)) {\n      return res.status(400).json({ error: 'Invalid plan code' });\n    }\n\n    // This would integrate with Stripe checkout\n    // For now, return a mock response\n    res.json({\n      sessionId: `cs_test_${Date.now()}`,\n      plan,\n      successUrl: successUrl || `${DOMAIN}/success.html`,\n      cancelUrl: cancelUrl || `${DOMAIN}/cancel.html`,\n    });\n  } catch (error) {\n    console.error('Checkout error:', error);\n    res.status(500).json({ error: 'Checkout failed' });\n  }\n});\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    error: 'Endpoint not found',\n    path: req.path,\n    method: req.method,\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Global error handler\napp.use((error, req, res, next) => {\n  console.error('Gateway error:', error);\n  res.status(500).json({\n    error: 'Internal server error',\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Start server\napp.listen(PORT, () => {\n  console.log(` API Gateway running on port ${PORT}`);\n  console.log(` Health check: http://localhost:${PORT}/health`);\n  console.log(` Telemetry endpoint: http://localhost:${PORT}/api/telemetry`);\n  console.log(` Auth service: ${AUTH_SERVICE_URL}`);\n  console.log(` License service: ${LICENSING_SERVICE_URL}`);\n  console.log(` Allowed origins: ${process.env.ALLOWED_ORIGINS || 'localhost:5173'}`);\n});\n\nexport default app;\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/api-gateway/server-with-abuse.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'axios' is defined but never used.","line":5,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createProxyMiddleware' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":64,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LICENSING_SERVICE_URL' is assigned a value but never used.","line":69,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":69,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AUTH_SERVICE_URL' is assigned a value but never used.","line":70,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":70,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":70,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DOMAIN' is assigned a value but never used.","line":71,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":71,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":71,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":72,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TELEMETRY_SUMMARY_URL' is assigned a value but never used.","line":73,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":74,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":75,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":78,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":97,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":97,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":126,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":126,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":192,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":192,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":262,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":262,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'next' is defined but never used.","line":278,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":278,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":279,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":279,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":288,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":288,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":289,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":289,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":290,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":290,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":291,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":291,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":292,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":292,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":293,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":293,"endColumn":10}],"suppressedMessages":[],"errorCount":26,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport axios from 'axios';\nimport dotenv from 'dotenv';\nimport { createProxyMiddleware } from 'http-proxy-middleware';\nimport { dashboardAuth } from './middleware/dashboardAuth.js';\n\n// Load environment variables\ndotenv.config();\n\n// In-memory storage for telemetry data (replace with database in production)\nconst telemetryBuffer = [];\nconst MAX_BUFFER_SIZE = 1000;\n\n// Data retention configuration\nconst RETENTION_DAYS = 30;\nconst MS_PER_DAY = 86400000;\n\n// Schema version validation\nconst SUPPORTED_SCHEMA_VERSIONS = new Set([1]);\n\n// Required fields validation\nconst REQUIRED_FIELDS = ['appVersion', 'os', 'agent', 'license', 'schemaVersion'];\n\n// Schema version validation function\nfunction validateSchemaVersion(payload) {\n  if (typeof payload.schemaVersion !== 'number') {\n    return { ok: false, error: 'schemaVersion required' };\n  }\n\n  if (!SUPPORTED_SCHEMA_VERSIONS.has(payload.schemaVersion)) {\n    return { ok: false, error: `Unsupported schemaVersion ${payload.schemaVersion}` };\n  }\n\n  return { ok: true };\n}\n\n// Required fields validation function\nfunction validateRequiredFields(payload) {\n  for (const field of REQUIRED_FIELDS) {\n    if (payload[field] === undefined || payload[field] === null) {\n      return { ok: false, error: `Missing required field: ${field}` };\n    }\n  }\n  return { ok: true };\n}\n\n// Data retention function\nfunction purgeOldTelemetry() {\n  const cutoff = Date.now() - RETENTION_DAYS * MS_PER_DAY;\n  const originalLength = telemetryBuffer.length;\n\n  // Filter out old records\n  for (let i = telemetryBuffer.length - 1; i >= 0; i--) {\n    if (new Date(telemetryBuffer[i].timestamp).getTime() < cutoff) {\n      telemetryBuffer.splice(i, 1);\n    }\n  }\n\n  const removed = originalLength - telemetryBuffer.length;\n  if (removed > 0) {\n    console.log(` Purged ${removed} old telemetry records (${RETENTION_DAYS} days retention)`);\n  }\n}\n\n// Environment configuration\nconst LICENSING_SERVICE_URL = process.env.LICENSING_SERVICE_URL || 'http://localhost:3003';\nconst AUTH_SERVICE_URL = process.env.AUTH_SERVICE_URL || 'http://localhost:3001';\nconst DOMAIN = process.env.DOMAIN || 'http://localhost:3000';\nconst SLACK_WEBHOOK_URL = process.env.SLACK_WEBHOOK_URL;\nconst TELEMETRY_SUMMARY_URL =\n  process.env.TELEMETRY_SUMMARY_URL ||\n  `http://localhost:${process.env.PORT || 3000}/api/telemetry/summary`;\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(\n  helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        scriptSrc: [\"'self'\"],\n        imgSrc: [\"'self'\", 'data:', 'https:'],\n        connectSrc: [\"'self'\", 'https://api.stripe.com'],\n      },\n    },\n  }),\n);\n\napp.use(\n  cors({\n    origin: process.env.ALLOWED_ORIGINS?.split(',') || [\n      'http://localhost:5173',\n      'https://rinawarptech.com',\n    ],\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'X-Dashboard-Token'],\n  }),\n);\n\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Rate limiting\nconst telemetryLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  max: 10, // Max 10 telemetry reports per IP per 5 minutes\n  message: { error: 'Telemetry rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    gateway: 'api-gateway',\n    version: '1.0.2',\n    uptime: process.uptime(),\n  });\n});\n\n// FIXED: Telemetry endpoint with proper validation order\napp.post('/api/telemetry', telemetryLimiter, async (req, res) => {\n  try {\n    // 1. Required fields validation (fail fast)\n    const requiredCheck = validateRequiredFields(req.body);\n    if (!requiredCheck.ok) {\n      return res.status(400).json({ error: requiredCheck.error });\n    }\n\n    // 2. Schema version validation (fail fast)\n    const schemaCheck = validateSchemaVersion(req.body);\n    if (!schemaCheck.ok) {\n      return res.status(400).json({ error: schemaCheck.error });\n    }\n\n    const telemetryData = req.body;\n\n    // 3. Validate data types and sanitize\n    const sanitizedData = {\n      appVersion: String(telemetryData.appVersion).slice(0, 20),\n      os: ['win32', 'darwin', 'linux'].includes(telemetryData.os) ? telemetryData.os : 'unknown',\n      schemaVersion: telemetryData.schemaVersion,\n      agent: telemetryData.agent\n        ? {\n            status: ['online', 'offline'].includes(telemetryData.agent.status)\n              ? telemetryData.agent.status\n              : 'unknown',\n            pingMs:\n              typeof telemetryData.agent.pingMs === 'number'\n                ? Math.min(telemetryData.agent.pingMs, 60000)\n                : null,\n          }\n        : null,\n      license: telemetryData.license\n        ? {\n            tier: ['free', 'pro', 'enterprise'].includes(telemetryData.license.tier)\n              ? telemetryData.license.tier\n              : 'unknown',\n            offline: Boolean(telemetryData.license.offline),\n          }\n        : null,\n      timestamp: new Date().toISOString(),\n      ip: req.ip,\n    };\n\n    // 4. Store in memory buffer\n    telemetryBuffer.push(sanitizedData);\n\n    // Keep buffer size manageable\n    if (telemetryBuffer.length > MAX_BUFFER_SIZE) {\n      telemetryBuffer.shift();\n    }\n\n    // 5. Apply data retention policy\n    purgeOldTelemetry();\n\n    res.json({\n      success: true,\n      message: 'Telemetry received',\n      timestamp: sanitizedData.timestamp,\n    });\n  } catch (error) {\n    console.error('Telemetry error:', error);\n    res.status(500).json({ error: 'Failed to process telemetry' });\n  }\n});\n\n// FIXED: Dashboard authentication endpoint\napp.get('/api/telemetry/summary', dashboardAuth, async (req, res) => {\n  try {\n    const now = new Date();\n    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    // Filter recent telemetry\n    const recentTelemetry = telemetryBuffer.filter(\n      (item) => new Date(item.timestamp) > last24Hours,\n    );\n\n    // Calculate agent health metrics\n    const agentRecords = recentTelemetry.filter((item) => item.agent && item.agent.status);\n    const onlineAgents = agentRecords.filter((item) => item.agent.status === 'online').length;\n    const totalAgentRecords = agentRecords.length;\n    const onlineRate = totalAgentRecords > 0 ? onlineAgents / totalAgentRecords : 1;\n\n    // Aggregate statistics\n    const summary = {\n      totalReports: recentTelemetry.length,\n      byOS: {},\n      byVersion: {},\n      byAgentStatus: {},\n      byLicenseTier: {},\n      agent: {\n        sampleCount: totalAgentRecords,\n        onlineRate: onlineRate,\n        onlineCount: onlineAgents,\n        offlineCount: totalAgentRecords - onlineAgents,\n        windowMinutes: 1440, // 24 hours\n      },\n      lastReport:\n        recentTelemetry.length > 0 ? recentTelemetry[recentTelemetry.length - 1].timestamp : null,\n      timeRange: {\n        from: last24Hours.toISOString(),\n        to: now.toISOString(),\n      },\n    };\n\n    // Calculate aggregates\n    recentTelemetry.forEach((item) => {\n      // By OS\n      summary.byOS[item.os] = (summary.byOS[item.os] || 0) + 1;\n\n      // By Version\n      summary.byVersion[item.appVersion] = (summary.byVersion[item.appVersion] || 0) + 1;\n\n      // By Agent Status\n      if (item.agent?.status) {\n        summary.byAgentStatus[item.agent.status] =\n          (summary.byAgentStatus[item.agent.status] || 0) + 1;\n      }\n\n      // By License Tier\n      if (item.license?.tier) {\n        summary.byLicenseTier[item.license.tier] =\n          (summary.byLicenseTier[item.license.tier] || 0) + 1;\n      }\n    });\n\n    res.json({\n      success: true,\n      data: summary,\n    });\n  } catch (error) {\n    console.error('Telemetry summary error:', error);\n    res.status(500).json({ error: 'Failed to generate telemetry summary' });\n  }\n});\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    error: 'Endpoint not found',\n    path: req.path,\n    method: req.method,\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Global error handler\napp.use((error, req, res, next) => {\n  console.error('Gateway error:', error);\n  res.status(500).json({\n    error: 'Internal server error',\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Start server\napp.listen(PORT, () => {\n  console.log(` API Gateway running on port ${PORT}`);\n  console.log(` Health check: http://localhost:${PORT}/health`);\n  console.log(` Telemetry endpoint: http://localhost:${PORT}/api/telemetry`);\n  console.log(` Dashboard: http://localhost:${PORT}/api/telemetry/summary`);\n  console.log(` Slack alerts: ${SLACK_WEBHOOK_URL ? 'ENABLED' : 'DISABLED'}`);\n  console.log(` Data retention: ${RETENTION_DAYS} days`);\n});\n\nexport default app;\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/api-gateway/server.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'axios' is defined but never used.","line":5,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createProxyMiddleware' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":64,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LICENSING_SERVICE_URL' is assigned a value but never used.","line":69,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":69,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AUTH_SERVICE_URL' is assigned a value but never used.","line":70,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":70,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":70,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DOMAIN' is assigned a value but never used.","line":71,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":71,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":71,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":72,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TELEMETRY_SUMMARY_URL' is assigned a value but never used.","line":73,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":74,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":74,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":75,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":78,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":97,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":97,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":126,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":126,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":192,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":192,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":262,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":262,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'next' is defined but never used.","line":278,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":278,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":279,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":279,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":288,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":288,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":289,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":289,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":290,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":290,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":291,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":291,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":292,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":292,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":293,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":293,"endColumn":10}],"suppressedMessages":[],"errorCount":26,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport axios from 'axios';\nimport dotenv from 'dotenv';\nimport { createProxyMiddleware } from 'http-proxy-middleware';\nimport { dashboardAuth } from './middleware/dashboardAuth.js';\n\n// Load environment variables\ndotenv.config();\n\n// In-memory storage for telemetry data (replace with database in production)\nconst telemetryBuffer = [];\nconst MAX_BUFFER_SIZE = 1000;\n\n// Data retention configuration\nconst RETENTION_DAYS = 30;\nconst MS_PER_DAY = 86400000;\n\n// Schema version validation\nconst SUPPORTED_SCHEMA_VERSIONS = new Set([1]);\n\n// Required fields validation\nconst REQUIRED_FIELDS = ['appVersion', 'os', 'agent', 'license', 'schemaVersion'];\n\n// Schema version validation function\nfunction validateSchemaVersion(payload) {\n  if (typeof payload.schemaVersion !== 'number') {\n    return { ok: false, error: 'schemaVersion required' };\n  }\n\n  if (!SUPPORTED_SCHEMA_VERSIONS.has(payload.schemaVersion)) {\n    return { ok: false, error: `Unsupported schemaVersion ${payload.schemaVersion}` };\n  }\n\n  return { ok: true };\n}\n\n// Required fields validation function\nfunction validateRequiredFields(payload) {\n  for (const field of REQUIRED_FIELDS) {\n    if (payload[field] === undefined || payload[field] === null) {\n      return { ok: false, error: `Missing required field: ${field}` };\n    }\n  }\n  return { ok: true };\n}\n\n// Data retention function\nfunction purgeOldTelemetry() {\n  const cutoff = Date.now() - RETENTION_DAYS * MS_PER_DAY;\n  const originalLength = telemetryBuffer.length;\n\n  // Filter out old records\n  for (let i = telemetryBuffer.length - 1; i >= 0; i--) {\n    if (new Date(telemetryBuffer[i].timestamp).getTime() < cutoff) {\n      telemetryBuffer.splice(i, 1);\n    }\n  }\n\n  const removed = originalLength - telemetryBuffer.length;\n  if (removed > 0) {\n    console.log(` Purged ${removed} old telemetry records (${RETENTION_DAYS} days retention)`);\n  }\n}\n\n// Environment configuration\nconst LICENSING_SERVICE_URL = process.env.LICENSING_SERVICE_URL || 'http://localhost:3003';\nconst AUTH_SERVICE_URL = process.env.AUTH_SERVICE_URL || 'http://localhost:3001';\nconst DOMAIN = process.env.DOMAIN || 'http://localhost:3000';\nconst SLACK_WEBHOOK_URL = process.env.SLACK_WEBHOOK_URL;\nconst TELEMETRY_SUMMARY_URL =\n  process.env.TELEMETRY_SUMMARY_URL ||\n  `http://localhost:${process.env.PORT || 3000}/api/telemetry/summary`;\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(\n  helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        scriptSrc: [\"'self'\"],\n        imgSrc: [\"'self'\", 'data:', 'https:'],\n        connectSrc: [\"'self'\", 'https://api.stripe.com'],\n      },\n    },\n  }),\n);\n\napp.use(\n  cors({\n    origin: process.env.ALLOWED_ORIGINS?.split(',') || [\n      'http://localhost:5173',\n      'https://rinawarptech.com',\n    ],\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'X-Dashboard-Token'],\n  }),\n);\n\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Rate limiting\nconst telemetryLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  max: 10, // Max 10 telemetry reports per IP per 5 minutes\n  message: { error: 'Telemetry rate limit exceeded' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    gateway: 'api-gateway',\n    version: '1.0.2',\n    uptime: process.uptime(),\n  });\n});\n\n// FIXED: Telemetry endpoint with proper validation order\napp.post('/api/telemetry', telemetryLimiter, async (req, res) => {\n  try {\n    // 1. Required fields validation (fail fast)\n    const requiredCheck = validateRequiredFields(req.body);\n    if (!requiredCheck.ok) {\n      return res.status(400).json({ error: requiredCheck.error });\n    }\n\n    // 2. Schema version validation (fail fast)\n    const schemaCheck = validateSchemaVersion(req.body);\n    if (!schemaCheck.ok) {\n      return res.status(400).json({ error: schemaCheck.error });\n    }\n\n    const telemetryData = req.body;\n\n    // 3. Validate data types and sanitize\n    const sanitizedData = {\n      appVersion: String(telemetryData.appVersion).slice(0, 20),\n      os: ['win32', 'darwin', 'linux'].includes(telemetryData.os) ? telemetryData.os : 'unknown',\n      schemaVersion: telemetryData.schemaVersion,\n      agent: telemetryData.agent\n        ? {\n            status: ['online', 'offline'].includes(telemetryData.agent.status)\n              ? telemetryData.agent.status\n              : 'unknown',\n            pingMs:\n              typeof telemetryData.agent.pingMs === 'number'\n                ? Math.min(telemetryData.agent.pingMs, 60000)\n                : null,\n          }\n        : null,\n      license: telemetryData.license\n        ? {\n            tier: ['free', 'pro', 'enterprise'].includes(telemetryData.license.tier)\n              ? telemetryData.license.tier\n              : 'unknown',\n            offline: Boolean(telemetryData.license.offline),\n          }\n        : null,\n      timestamp: new Date().toISOString(),\n      ip: req.ip,\n    };\n\n    // 4. Store in memory buffer\n    telemetryBuffer.push(sanitizedData);\n\n    // Keep buffer size manageable\n    if (telemetryBuffer.length > MAX_BUFFER_SIZE) {\n      telemetryBuffer.shift();\n    }\n\n    // 5. Apply data retention policy\n    purgeOldTelemetry();\n\n    res.json({\n      success: true,\n      message: 'Telemetry received',\n      timestamp: sanitizedData.timestamp,\n    });\n  } catch (error) {\n    console.error('Telemetry error:', error);\n    res.status(500).json({ error: 'Failed to process telemetry' });\n  }\n});\n\n// FIXED: Dashboard authentication endpoint\napp.get('/api/telemetry/summary', dashboardAuth, async (req, res) => {\n  try {\n    const now = new Date();\n    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    // Filter recent telemetry\n    const recentTelemetry = telemetryBuffer.filter(\n      (item) => new Date(item.timestamp) > last24Hours,\n    );\n\n    // Calculate agent health metrics\n    const agentRecords = recentTelemetry.filter((item) => item.agent && item.agent.status);\n    const onlineAgents = agentRecords.filter((item) => item.agent.status === 'online').length;\n    const totalAgentRecords = agentRecords.length;\n    const onlineRate = totalAgentRecords > 0 ? onlineAgents / totalAgentRecords : 1;\n\n    // Aggregate statistics\n    const summary = {\n      totalReports: recentTelemetry.length,\n      byOS: {},\n      byVersion: {},\n      byAgentStatus: {},\n      byLicenseTier: {},\n      agent: {\n        sampleCount: totalAgentRecords,\n        onlineRate: onlineRate,\n        onlineCount: onlineAgents,\n        offlineCount: totalAgentRecords - onlineAgents,\n        windowMinutes: 1440, // 24 hours\n      },\n      lastReport:\n        recentTelemetry.length > 0 ? recentTelemetry[recentTelemetry.length - 1].timestamp : null,\n      timeRange: {\n        from: last24Hours.toISOString(),\n        to: now.toISOString(),\n      },\n    };\n\n    // Calculate aggregates\n    recentTelemetry.forEach((item) => {\n      // By OS\n      summary.byOS[item.os] = (summary.byOS[item.os] || 0) + 1;\n\n      // By Version\n      summary.byVersion[item.appVersion] = (summary.byVersion[item.appVersion] || 0) + 1;\n\n      // By Agent Status\n      if (item.agent?.status) {\n        summary.byAgentStatus[item.agent.status] =\n          (summary.byAgentStatus[item.agent.status] || 0) + 1;\n      }\n\n      // By License Tier\n      if (item.license?.tier) {\n        summary.byLicenseTier[item.license.tier] =\n          (summary.byLicenseTier[item.license.tier] || 0) + 1;\n      }\n    });\n\n    res.json({\n      success: true,\n      data: summary,\n    });\n  } catch (error) {\n    console.error('Telemetry summary error:', error);\n    res.status(500).json({ error: 'Failed to generate telemetry summary' });\n  }\n});\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    error: 'Endpoint not found',\n    path: req.path,\n    method: req.method,\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Global error handler\napp.use((error, req, res, next) => {\n  console.error('Gateway error:', error);\n  res.status(500).json({\n    error: 'Internal server error',\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Start server\napp.listen(PORT, () => {\n  console.log(` API Gateway running on port ${PORT}`);\n  console.log(` Health check: http://localhost:${PORT}/health`);\n  console.log(` Telemetry endpoint: http://localhost:${PORT}/api/telemetry`);\n  console.log(` Dashboard: http://localhost:${PORT}/api/telemetry/summary`);\n  console.log(` Slack alerts: ${SLACK_WEBHOOK_URL ? 'ENABLED' : 'DISABLED'}`);\n  console.log(` Data retention: ${RETENTION_DAYS} days`);\n});\n\nexport default app;\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/api-gateway/test-hardened-telemetry.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":15,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":265,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":265,"endColumn":17}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\n\nconst BASE_URL = 'http://localhost:3000';\nconst DASHBOARD_TOKEN = 'test-dashboard-token-12345';\n\nconst tests = {\n  passed: 0,\n  failed: 0,\n  total: 0,\n};\n\nfunction log(message, type = 'info') {\n  const timestamp = new Date().toISOString();\n  const prefix = type === 'error' ? '' : type === 'success' ? '' : '';\n  console.log(`[${timestamp}] ${prefix} ${message}`);\n}\n\nfunction assert(condition, testName, expected, actual) {\n  tests.total++;\n  if (condition) {\n    tests.passed++;\n    log(`PASS: ${testName}`, 'success');\n    return true;\n  } else {\n    tests.failed++;\n    log(`FAIL: ${testName} - Expected: ${expected}, Got: ${actual}`, 'error');\n    return false;\n  }\n}\n\nasync function testSchemaVersionValidation() {\n  log('Testing Schema Version Validation...');\n\n  // Test 1: Missing schemaVersion\n  try {\n    const response = await axios.post(`${BASE_URL}/api/telemetry`, {\n      appVersion: '1.0.0',\n      os: 'linux',\n      agent: { status: 'online', pingMs: 100 },\n      license: { tier: 'pro', offline: false },\n    });\n\n    assert(\n      response.status === 400 && response.data.error.includes('schemaVersion'),\n      'Missing schemaVersion should return 400',\n      '400 error',\n      `Status: ${response.status}`,\n    );\n  } catch (error) {\n    assert(\n      error.response?.status === 400,\n      'Missing schemaVersion HTTP status',\n      '400',\n      error.response?.status,\n    );\n  }\n\n  // Test 2: Invalid schemaVersion\n  try {\n    const response = await axios.post(`${BASE_URL}/api/telemetry`, {\n      schemaVersion: 999,\n      appVersion: '1.0.0',\n      os: 'linux',\n      agent: { status: 'online', pingMs: 100 },\n      license: { tier: 'pro', offline: false },\n    });\n\n    assert(\n      response.status === 400 && response.data.error.includes('Unsupported schemaVersion'),\n      'Invalid schemaVersion should return 400',\n      '400 error',\n      `Status: ${response.status}`,\n    );\n  } catch (error) {\n    assert(\n      error.response?.status === 400,\n      'Invalid schemaVersion HTTP status',\n      '400',\n      error.response?.status,\n    );\n  }\n\n  // Test 3: Valid schemaVersion\n  try {\n    const response = await axios.post(`${BASE_URL}/api/telemetry`, {\n      schemaVersion: 1,\n      appVersion: '1.0.0',\n      os: 'linux',\n      agent: { status: 'online', pingMs: 100 },\n      license: { tier: 'pro', offline: false },\n    });\n\n    assert(\n      response.status === 200 && response.data.success === true,\n      'Valid schemaVersion should return 200',\n      '200 success',\n      `Status: ${response.status}`,\n    );\n  } catch (error) {\n    assert(false, 'Valid schemaVersion should not error', 'Success', error.message);\n  }\n}\n\nasync function testRequiredFieldsValidation() {\n  log('Testing Required Fields Validation...');\n\n  const requiredFields = ['appVersion', 'os', 'agent', 'license', 'schemaVersion'];\n\n  for (const field of requiredFields) {\n    const testPayload = {\n      schemaVersion: 1,\n      appVersion: '1.0.0',\n      os: 'linux',\n      agent: { status: 'online', pingMs: 100 },\n      license: { tier: 'pro', offline: false },\n    };\n    delete testPayload[field];\n\n    try {\n      const response = await axios.post(`${BASE_URL}/api/telemetry`, testPayload);\n      assert(\n        false,\n        `Missing ${field} should return 400`,\n        '400 error',\n        `Status: ${response.status}`,\n      );\n    } catch (error) {\n      assert(\n        error.response?.status === 400 &&\n          error.response?.data?.error?.includes(`Missing required field: ${field}`),\n        `Missing ${field} validation`,\n        '400 error with correct message',\n        `Status: ${error.response?.status}, Error: ${error.response?.data?.error}`,\n      );\n    }\n  }\n}\n\nasync function testDashboardAuthentication() {\n  log('Testing Dashboard Authentication...');\n\n  // Test 1: No token\n  try {\n    const response = await axios.get(`${BASE_URL}/api/telemetry/summary`);\n    assert(false, 'No token should return 401', '401', `Status: ${response.status}`);\n  } catch (error) {\n    assert(error.response?.status === 401, 'No token HTTP status', '401', error.response?.status);\n  }\n\n  // Test 2: Invalid token\n  try {\n    const response = await axios.get(`${BASE_URL}/api/telemetry/summary`, {\n      headers: { 'X-Dashboard-Token': 'invalid-token' },\n    });\n    assert(false, 'Invalid token should return 403', '403', `Status: ${response.status}`);\n  } catch (error) {\n    assert(\n      error.response?.status === 403,\n      'Invalid token HTTP status',\n      '403',\n      error.response?.status,\n    );\n  }\n\n  // Test 3: Valid token (will fail without proper env setup, but should reach auth check)\n  try {\n    const response = await axios.get(`${BASE_URL}/api/telemetry/summary`, {\n      headers: { 'X-Dashboard-Token': DASHBOARD_TOKEN },\n    });\n    // This might succeed or fail depending on env setup, but shouldn't be auth error\n    assert(\n      response.status !== 401 && response.status !== 403,\n      'Valid token should not return auth errors',\n      'Not 401/403',\n      `Status: ${response.status}`,\n    );\n  } catch (error) {\n    assert(\n      error.response?.status !== 401 && error.response?.status !== 403,\n      'Valid token should not return auth errors',\n      'Not 401/403',\n      `Status: ${error.response?.status}`,\n    );\n  }\n}\n\nasync function testTelemetryEndpointStructure() {\n  log('Testing Telemetry Endpoint Structure...');\n\n  const validPayload = {\n    schemaVersion: 1,\n    appVersion: '1.0.0',\n    os: 'linux',\n    agent: { status: 'online', pingMs: 100 },\n    license: { tier: 'pro', offline: false },\n  };\n\n  try {\n    const response = await axios.post(`${BASE_URL}/api/telemetry`, validPayload);\n\n    assert(response.status === 200, 'Valid telemetry should return 200', '200', response.status);\n    assert(\n      response.data.success === true,\n      'Response should have success: true',\n      'true',\n      response.data.success,\n    );\n    assert(\n      response.data.message === 'Telemetry received',\n      'Response should have correct message',\n      'Telemetry received',\n      response.data.message,\n    );\n    assert(\n      response.data.timestamp,\n      'Response should include timestamp',\n      'timestamp present',\n      response.data.timestamp ? 'present' : 'missing',\n    );\n  } catch (error) {\n    assert(false, 'Valid telemetry should not error', 'Success', error.message);\n  }\n}\n\nasync function testRateLimiting() {\n  log('Testing Rate Limiting...');\n\n  const validPayload = {\n    schemaVersion: 1,\n    appVersion: '1.0.0',\n    os: 'linux',\n    agent: { status: 'online', pingMs: 100 },\n    license: { tier: 'pro', offline: false },\n  };\n\n  // Send multiple requests to test rate limiting\n  const promises = [];\n  for (let i = 0; i < 15; i++) {\n    promises.push(axios.post(`${BASE_URL}/api/telemetry`, validPayload).catch((err) => err));\n  }\n\n  try {\n    const results = await Promise.all(promises);\n    const rateLimited = results.filter((r) => r.response?.status === 429).length;\n\n    assert(\n      rateLimited > 0,\n      'Rate limiting should trigger',\n      'Some requests limited',\n      `${rateLimited}/15 requests limited`,\n    );\n  } catch (error) {\n    log('Rate limiting test encountered error: ' + error.message);\n  }\n}\n\nasync function runAllTests() {\n  log(' Starting Hardened Telemetry Tests');\n  log('====================================');\n\n  try {\n    // Test if server is running\n    await axios.get(`${BASE_URL}/health`);\n    log(' Server is running');\n  } catch (error) {\n    log(' Server is not running. Please start the server first.', 'error');\n    return;\n  }\n\n  await testSchemaVersionValidation();\n  await testRequiredFieldsValidation();\n  await testDashboardAuthentication();\n  await testTelemetryEndpointStructure();\n  await testRateLimiting();\n\n  log('====================================');\n  log(` Test Results: ${tests.passed}/${tests.total} passed, ${tests.failed} failed`);\n\n  if (tests.failed === 0) {\n    log(' ALL TESTS PASSED! System is production ready.', 'success');\n  } else {\n    log(' Some tests failed. Please review the issues above.', 'error');\n  }\n}\n\n// Run tests\nrunAllTests().catch((error) => {\n  log('Test suite error: ' + error.message, 'error');\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/auth-service/server.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":12,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":19,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":19,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":20,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'supabase' is assigned a value but never used.","line":22,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":31,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userData' is assigned a value but never used.","line":54,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":54,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":72,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":81,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":105,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":105,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":114,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":114,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":128,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":128,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":141,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":141,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":156,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":156,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used.","line":167,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":167,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":183,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":183,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":184,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":184,"endColumn":10}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport cors from 'cors';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\nconst app = express();\nconst PORT = process.env.AUTH_SERVICE_PORT || 3001;\n\n// Middleware\napp.use(cors());\napp.use(express.json());\n\n// Initialize Supabase (with fallback for development)\nconst supabaseUrl = process.env.SUPABASE_URL || 'http://localhost:54321';\nconst supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || 'your-service-role-key';\n\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\n// JWT utility functions\nconst generateToken = (user) => {\n  return jwt.sign(\n    {\n      userId: user.id,\n      email: user.email,\n    },\n    process.env.JWT_SECRET || 'fallback-secret',\n    { expiresIn: '24h' },\n  );\n};\n\n// User registration (handles /auth/register from gateway)\napp.post('/register', async (req, res) => {\n  try {\n    const { email, password, firstName, lastName } = req.body;\n\n    if (!email || !password) {\n      return res.status(400).json({ error: 'Email and password required' });\n    }\n\n    // Simple password validation\n    if (password.length < 6) {\n      return res.status(400).json({ error: 'Password too short' });\n    }\n\n    // Hash password\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    // Create user (simplified for testing)\n    const userData = {\n      email,\n      password_hash: hashedPassword,\n      first_name: firstName || '',\n      last_name: lastName || '',\n      created_at: new Date().toISOString(),\n    };\n\n    // For now, return success without actual database storage\n    const mockUser = {\n      id: 'user_' + Date.now(),\n      email,\n      first_name: firstName,\n      last_name: lastName,\n    };\n\n    const token = generateToken(mockUser);\n\n    console.log('User registered:', email);\n\n    res.status(201).json({\n      message: 'User registered successfully',\n      user: mockUser,\n      accessToken: token,\n      refreshToken: 'refresh_' + token,\n    });\n  } catch (error) {\n    console.error('Registration error:', error);\n    res.status(500).json({ error: 'Registration failed' });\n  }\n});\n\n// User login\napp.post('/login', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n\n    if (!email || !password) {\n      return res.status(400).json({ error: 'Email and password required' });\n    }\n\n    // Mock user for testing\n    const mockUser = {\n      id: 'user_' + Date.now(),\n      email,\n      first_name: 'Test',\n      last_name: 'User',\n    };\n\n    const token = generateToken(mockUser);\n\n    console.log('User logged in:', email);\n\n    res.json({\n      user: mockUser,\n      license: null,\n      accessToken: token,\n      refreshToken: 'refresh_' + token,\n    });\n  } catch (error) {\n    console.error('Login error:', error);\n    res.status(500).json({ error: 'Login failed' });\n  }\n});\n\n// Token verification (legacy - body-based)\napp.post('/verify', async (req, res) => {\n  try {\n    const { token } = req.body;\n\n    if (!token) {\n      return res.json({ valid: false });\n    }\n\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret');\n\n    res.json({\n      valid: true,\n      user: {\n        id: decoded.userId,\n        email: decoded.email,\n        firstName: 'Test',\n        lastName: 'User',\n      },\n      license: null,\n    });\n  } catch (error) {\n    console.error('Token verification error:', error);\n    res.json({ valid: false });\n  }\n});\n\n//  Standard auth verification endpoint\napp.post('/auth/verify', async (req, res) => {\n  const auth = req.headers.authorization || '';\n  if (!auth.startsWith('Bearer ')) {\n    return res.status(200).json({ valid: false, user: null });\n  }\n\n  const token = auth.slice('Bearer '.length).trim();\n\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret');\n\n    // Enrich user data from token\n    const user = {\n      id: decoded.userId || decoded.sub || decoded.id || 'unknown',\n      email: decoded.email || null,\n      plan: decoded.plan || 'free',\n      roles: decoded.roles || ['user'],\n    };\n\n    return res.json({ valid: true, user });\n  } catch (err) {\n    return res.status(200).json({ valid: false, user: null });\n  }\n});\n\n// Health check\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'healthy',\n    service: 'auth-service',\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Start server\napp.listen(PORT, () => {\n  console.log(` Auth service running on port ${PORT}`);\n  console.log(`  Health check: http://localhost:${PORT}/health`);\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/billing-service/entitlements.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/billing-service/license-db.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":12,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":38,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":39,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":10}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\n// Mock database for testing - replace with real DB in production\nconst licenses = {};\nconst processedEvents = new Set();\n\n// License database operations\nexport async function updateLicensePlan(licenseKey, licenseData) {\n  console.log(` Updating license ${licenseKey} with plan: ${licenseData.plan}`);\n\n  licenses[licenseKey] = {\n    ...licenseData,\n    updatedAt: new Date().toISOString(),\n    licenseKey,\n  };\n\n  return licenses[licenseKey];\n}\n\nexport async function getLicenseByKey(licenseKey) {\n  return licenses[licenseKey] || null;\n}\n\n// Idempotency tracking\nexport const saveProcessedEvent = {\n  check: async (eventId) => processedEvents.has(eventId),\n  store: async (eventId) => {\n    processedEvents.add(eventId);\n    return true;\n  },\n};\n\n// Mock function to simulate real database operations\nexport async function simulateDatabaseOperations() {\n  console.log('  Database operations would go here in production');\n  console.log('  Current licenses in memory:', Object.keys(licenses).length);\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/billing-service/server.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getLicenseByKey' is defined but never used.","line":5,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'saveProcessedEvent' is defined but never used.","line":5,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":64},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":11,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":15,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":47,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":48,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":62,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":65,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":65,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'handleCheckoutCompleted' is defined but never used.","line":77,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":78,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":84,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":84,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":98,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":98,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'handleSubscriptionUpdate' is defined but never used.","line":102,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":103,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":103,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":109,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":109,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":122,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":122,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'handleSubscriptionCancelled' is defined but never used.","line":125,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":125,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":137,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":142,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":142,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":143,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":143,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":144,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":144,"endColumn":10}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport cors from 'cors';\nimport Stripe from 'stripe';\nimport dotenv from 'dotenv';\nimport { updateLicensePlan, getLicenseByKey, saveProcessedEvent } from './license-db.js';\n\n// Load environment variables\ndotenv.config();\n\nconst app = express();\nconst PORT = process.env.BILLING_SERVICE_PORT || 3005;\n\n// NOTE: Stripe operations moved to canonical webhook at backend/stripe-secure/webhook.js\n// This service focuses on license management and checkout session creation only\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n\n// Middleware\napp.use(cors());\napp.use(express.json());\n\n// Health check\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'healthy',\n    service: 'billing-service',\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// Create checkout session for upgrades\napp.post('/api/billing/create-checkout-session', express.json(), async (req, res) => {\n  const { tier, licenseKey, success_url, cancel_url } = req.body;\n\n  if (!tier || !licenseKey) {\n    return res.status(400).json({ error: 'Missing tier or licenseKey' });\n  }\n\n  try {\n    // Create Stripe checkout session with required metadata\n    const session = await stripe.checkout.sessions.create({\n      payment_method_types: ['card'],\n      client_reference_id: licenseKey, // Required by audit\n      line_items: [\n        {\n          price:\n            tier === 'pro-monthly'\n              ? process.env.STRIPE_PRO_PRICE_ID\n              : process.env.STRIPE_LIFETIME_PRICE_ID,\n          quantity: 1,\n        },\n      ],\n      mode: tier === 'pro-monthly' ? 'subscription' : 'payment',\n      success_url: success_url || 'rinawarp-terminal-pro://upgrade-success',\n      cancel_url: cancel_url || 'rinawarp-terminal-pro://upgrade-cancel',\n      metadata: {\n        tier,\n        licenseKey,\n        user_id: licenseKey, // Required by audit\n      },\n    });\n\n    console.log(` Checkout session created: ${session.id} for ${tier}`);\n    res.json({ url: session.url, sessionId: session.id });\n  } catch (err) {\n    console.error(' Stripe checkout error:', err.message);\n    res.status(500).json({ error: 'Failed to create checkout session', details: err.message });\n  }\n});\n\n// NOTE: Stripe webhooks are handled ONLY by backend/stripe-secure/webhook.js\n// This service must not verify Stripe signatures or parse webhook raw bodies.\n\n// -------------------------------\n// HANDLERS\n// -------------------------------\n\nasync function handleCheckoutCompleted(session) {\n  console.log(' Checkout Completed:', session.id);\n\n  const tier = session.metadata?.tier;\n  const licenseKey = session.metadata?.licenseKey;\n\n  if (!licenseKey || !tier) {\n    console.error(' Missing metadata: licenseKey or tier');\n    return;\n  }\n\n  if (tier.startsWith('lifetime')) {\n    await updateLicensePlan(licenseKey, {\n      plan: 'lifetime',\n      features: {\n        premiumMode: true,\n        maxDailyMessages: Infinity,\n      },\n      timestamp: Date.now(),\n    });\n\n    console.log(` Lifetime license activated for ${licenseKey}`);\n  }\n}\n\nasync function handleSubscriptionUpdate(subscription) {\n  console.log(' Subscription Update:', subscription.id);\n\n  const metadata = subscription.metadata || {};\n  const licenseKey = metadata.licenseKey;\n\n  if (!licenseKey) {\n    console.error(' No license key in metadata');\n    return;\n  }\n\n  await updateLicensePlan(licenseKey, {\n    plan: 'pro',\n    features: {\n      premiumMode: true,\n      maxDailyMessages: 200,\n    },\n    subscription_end: subscription.current_period_end,\n  });\n\n  console.log(` PRO subscription active for ${licenseKey}`);\n}\n\nasync function handleSubscriptionCancelled(subscription) {\n  const licenseKey = subscription.metadata?.licenseKey;\n  if (!licenseKey) return;\n\n  await updateLicensePlan(licenseKey, {\n    plan: 'free',\n    features: {\n      premiumMode: false,\n      maxDailyMessages: 20,\n    },\n  });\n\n  console.log(` Subscription canceled  license downgraded for ${licenseKey}`);\n}\n\n// Start server\napp.listen(PORT, () => {\n  console.log(` Billing service running on port ${PORT}`);\n  console.log(`  Health check: http://localhost:${PORT}/health`);\n  console.log(` Webhook endpoint: http://localhost:${PORT}/webhook`);\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/entitlements.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'module' is not defined.","line":160,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":160,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'module' is not defined.","line":161,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":161,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":170,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":9}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * RinaWarp Terminal Pro - Entitlement Truth Table\n *\n * This is the final gate between money and features.\n * Do not modify without careful consideration of pricing power.\n */\n\nfunction entitlementsFromTier(tier) {\n  switch (tier) {\n    case 'free':\n      return {\n        agent: false,\n        ai: false,\n        voice: false,\n        terminal: true,\n        memory: false,\n        automation: false,\n        modules: false,\n        priority_support: false,\n      };\n\n    case 'basic':\n      return {\n        agent: 'basic',\n        ai: 'limited',\n        voice: false,\n        terminal: true,\n        memory: true,\n        automation: false,\n        modules: false,\n        priority_support: false,\n      };\n\n    case 'starter':\n      return {\n        agent: 'pro',\n        ai: 'medium',\n        voice: false,\n        terminal: true,\n        memory: true,\n        automation: 'basic',\n        modules: false,\n        priority_support: false,\n      };\n\n    case 'creator':\n      return {\n        agent: 'fast',\n        ai: 'high',\n        voice: true,\n        terminal: true,\n        memory: true,\n        automation: 'advanced',\n        modules: true,\n        priority_support: false,\n      };\n\n    case 'pro':\n      return {\n        agent: 'unlimited',\n        ai: 'unlimited',\n        voice: true,\n        terminal: true,\n        memory: true,\n        automation: 'full',\n        modules: true,\n        priority_support: true,\n      };\n\n    case 'founder_lifetime':\n    case 'pioneer_lifetime':\n    case 'evergreen_lifetime':\n      return {\n        agent: 'unlimited',\n        ai: 'included',\n        voice: true,\n        terminal: true,\n        memory: true,\n        automation: 'full',\n        modules: true,\n        priority_support: tier === 'founder_lifetime' || tier === 'pioneer_lifetime',\n      };\n\n    default:\n      // Unknown tier - default to free\n      return {\n        agent: false,\n        ai: false,\n        voice: false,\n        terminal: true,\n        memory: false,\n        automation: false,\n        modules: false,\n        priority_support: false,\n      };\n  }\n}\n\n/**\n * Validate license key format and extract tier\n */\nfunction validateLicenseKey(licenseKey) {\n  // Expected format: RWTP1-{TIER}-{EMAIL}-{TIMESTAMP}\n  const pattern = /^RWTP1-(.+)-(.+)-(\\d+)$/;\n  const match = licenseKey.match(pattern);\n\n  if (!match) {\n    return { valid: false, tier: null };\n  }\n\n  const [, tier, email, timestamp] = match;\n\n  // Validate tier is known\n  const validTiers = [\n    'free',\n    'basic',\n    'starter',\n    'creator',\n    'pro',\n    'founder_lifetime',\n    'pioneer_lifetime',\n    'evergreen_lifetime',\n  ];\n  if (!validTiers.includes(tier)) {\n    return { valid: false, tier: null };\n  }\n\n  return {\n    valid: true,\n    tier,\n    email,\n    timestamp: parseInt(timestamp),\n    entitlements: entitlementsFromTier(tier),\n  };\n}\n\n/**\n * Get pricing power justification\n */\nfunction getPricingJustification(tier) {\n  switch (tier) {\n    case 'basic':\n      return 'Local terminal + persistent memory + limited AI agent';\n    case 'starter':\n      return 'Basic + advanced agent modes + medium AI usage + basic automation';\n    case 'creator':\n      return 'Starter + voice AI + faster reasoning + higher limits + more modules';\n    case 'pro':\n      return 'Creator + unlimited AI agent + full automation suite + all modules + priority support';\n    case 'founder_lifetime':\n    case 'pioneer_lifetime':\n    case 'evergreen_lifetime':\n      return 'Pro + lifetime license + no recurring fees + full access forever';\n    default:\n      return 'Free tier with basic terminal functionality';\n  }\n}\n\n// Export for Node.js\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = {\n    entitlementsFromTier,\n    validateLicenseKey,\n    getPricingJustification,\n  };\n}\n\n// Export for browser\nif (typeof window !== 'undefined') {\n  window.RinaWarpEntitlements = {\n    entitlementsFromTier,\n    validateLicenseKey,\n    getPricingJustification,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/jobs/canary-promote.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Numeric separators are not allowed here.","line":18,"column":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fetch from 'node-fetch';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Configuration\nconst SUMMARY_URL = process.env.TELEMETRY_SUMMARY_URL || 'http://localhost:3000/api/telemetry/summary';\nconst DASHBOARD_TOKEN = process.env.DASHBOARD_TOKEN || 'test-dashboard-token-12345';\nconst SLACK_WEBHOOK_URL = process.env.SLACK_WEBHOOK_URL;\nconst DRY_RUN = process.env.CANARY_PROMOTE_DRY_RUN === 'true';\n\n// Promotion criteria\nconst MIN_SAMPLES = 200;\nconst ONLINE_RATE_DIFF_THRESHOLD = 0.02; // 2%\nconst CRASH_RATE = 0._DIFF_THRESHOLD002; // 0.2%\n\n// File paths (generic - works with SSH/Nginx or local filesystem)\nconst RELEASES_DIR = process.env.RELEASES_DIR || '/var/www/downloads/rinawarp/releases';\nconst CANARY_DIR = path.join(RELEASES_DIR, 'canary');\nconst STABLE_DIR = path.join(RELEASES_DIR, 'stable');\n\n/**\n * Send Slack notification\n */\nasync function postSlack(message) {\n  if (!SLACK_WEBHOOK_URL) {\n    console.log(' Slack webhook URL not configured, skipping alert');\n    return;\n  }\n\n  try {\n    await fetch(SLACK_WEBHOOK_URL, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ text: message })\n    });\n    console.log(' Slack notification sent');\n  } catch (error) {\n    console.error('Failed to send Slack notification:', error);\n  }\n}\n\n/**\n * Promote canary to stable (generic implementation)\n */\nasync function promoteCanaryToStable(version) {\n  try {\n    console.log(` Promoting canary ${version} to stable...`);\n    \n    // Read canary metadata files\n    const canaryYml = path.join(CANARY_DIR, 'latest.yml');\n    const canaryMacYml = path.join(CANARY_DIR, 'latest-mac.yml');\n    \n    // Check if files exist\n    try {\n      await fs.access(canaryYml);\n      await fs.access(canaryMacYml);\n    } catch (error) {\n      throw new Error(`Canary files not found for version ${version}`);\n    }\n\n    // Copy files from canary to stable\n    const stableYml = path.join(STABLE_DIR, 'latest.yml');\n    const stableMacYml = path.join(STABLE_DIR, 'latest-mac.yml');\n    \n    // Read and write files\n    const canaryYmlContent = await fs.readFile(canaryYml, 'utf8');\n    const canaryMacYmlContent = await fs.readFile(canaryMacYml, 'utf8');\n    \n    // Update version in metadata\n    const stableYmlContent = canaryYmlContent.replace(\n      /version: .*/,\n      `version: ${version}`\n    );\n    const stableMacYmlContent = canaryMacYmlContent.replace(\n      /version: .*/,\n      `version: ${version}`\n    );\n    \n    await fs.writeFile(stableYml, stableYmlContent);\n    await fs.writeFile(stableMacYml, stableMacYmlContent);\n    \n    console.log(` Promoted ${version} to stable`);\n    \n    // TODO: Add cache purge for latest*.yml files\n    // This depends on hosting method (CDN, nginx, etc.)\n    \n  } catch (error) {\n    console.error('Failed to promote canary to stable:', error);\n    throw error;\n  }\n}\n\n/**\n * Check if canary meets promotion criteria\n */\nfunction canaryMeetsPromotionCriteria(canary, stable) {\n  // Check minimum sample size\n  if (canary.sampleCount < MIN_SAMPLES) {\n    console.log(` Canary sample count too low: ${canary.sampleCount} < ${MIN_SAMPLES}`);\n    return false;\n  }\n\n  // Check online rate (canary should be within 2% of stable)\n  const onlineRateDiff = stable.agentOnlineRate - canary.agentOnlineRate;\n  if (onlineRateDiff >_THRESHOLD) {\n ONLINE_RATE_DIFF    console.log(` Canary online rate too low: ${canary.agentOnlineRate} vs stable ${stable.agentOnlineRate} (diff: ${onlineRateDiff})`);\n    return false;\n  }\n\n  // Check crash rate (canary should not exceed stable by more than 0.2%)\n  const crashRateDiff = canary.crashRate - stable.crashRate;\n  if (crashRateDiff > CRASH_RATE_DIFF_THRESHOLD) {\n    console.log(` Canary crash rate too high: ${canary.crashRate} vs stable ${stable.crashRate} (diff: ${crashRateDiff})`);\n    return false;\n  }\n\n  console.log(` Canary meets all promotion criteria`);\n  return true;\n}\n\n/**\n * Main canary promotion job\n */\nexport async function runCanaryPromotion() {\n  try {\n    console.log(' Checking canary promotion eligibility...');\n    \n    // Fetch telemetry summary\n    const response = await fetch(SUMMARY_URL, {\n      headers: { 'X-Dashboard-Token': DASHBOARD_TOKEN }\n    });\n    \n    if (!response.ok) {\n      console.error(`Failed to fetch telemetry: ${response.status}`);\n      return;\n    }\n\n    const data = await response.json();\n    const cohorts = data.cohorts;\n    const latestCanaryVersion = data.latestCanaryVersion;\n\n    if (!cohorts || !latestCanaryVersion) {\n      console.log(' Missing required telemetry data');\n      return;\n    }\n\n    const canary = cohorts.canary;\n    const stable = cohorts.stable;\n\n    if (!canary || !stable) {\n      console.log(' Missing cohort data');\n      return;\n    }\n\n    console.log(` Canary: ${canary.sampleCount} samples, ${(canary.agentOnlineRate * 100).toFixed(1)}% online, ${(canary.crashRate * 100).toFixed(3)}% crash`);\n    console.log(` Stable: ${stable.sampleCount} samples, ${(stable.agentOnlineRate * 100).toFixed(1)}% online, ${(stable.crashRate * 100).toFixed(3)}% crash`);\n\n    // Check promotion criteria\n    if (!canaryMeetsPromotionCriteria(canary, stable)) {\n      console.log(' Canary does not meet promotion criteria');\n      return;\n    }\n\n    // Prepare promotion message\n    const msg = ` Canary eligible for promotion: ${latestCanaryVersion}\\n` +\n                `Canary online: ${(canary.agentOnlineRate * 100).toFixed(1)}% vs Stable: ${(stable.agentOnlineRate * 100).toFixed(1)}%\\n` +\n                `Crash rate - Canary: ${(canary.crashRate * 100).toFixed(3)}% vs Stable: ${(stable.crashRate * 100).toFixed(3)}%\\n` +\n                `Samples - Canary: ${canary.sampleCount} vs Stable: ${stable.sampleCount}`;\n\n    await postSlack(msg);\n\n    // Execute promotion\n    if (DRY_RUN) {\n      console.log(' DRY RUN: Would promote canary to stable');\n      await postSlack(`(dry-run) Would promote canary ${latestCanaryVersion}  stable`);\n    } else {\n      await promoteCanaryToStable(latestCanaryVersion);\n      await postSlack(` Promoted canary ${latestCanaryVersion}  stable`);\n      console.log(' Canary promotion completed successfully');\n    }\n\n  } catch (error) {\n    console.error('Canary promotion job failed:', error);\n    await postSlack(` Canary promotion failed: ${error.message}`);\n  }\n}\n\n// Run if called directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  runCanaryPromotion().catch(console.error);\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/jobs/canary-rollback.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'__dirname' is assigned a value but never used.","line":7,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":11,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":12,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":13,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":13,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":14,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":15,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":18,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":28,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":38,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":40,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":49,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":59,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":59,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":91,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":96,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":96,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":108,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":108,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":123,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":123,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":131,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":131,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":137,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":148,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":148,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":156,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":156,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":165,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":165,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":172,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":172,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":176,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":176,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":182,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":182,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":189,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":189,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":202,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":202,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":204,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":204,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":210,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":210,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":211,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":211,"endColumn":36}],"suppressedMessages":[],"errorCount":29,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fetch from 'node-fetch';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Configuration\nconst SUMMARY_URL =\n  process.env.TELEMETRY_SUMMARY_URL || 'http://localhost:3000/api/telemetry/summary';\nconst DASHBOARD_TOKEN = process.env.DASHBOARD_TOKEN || 'test-dashboard-token-12345';\nconst SLACK_WEBHOOK_URL = process.env.SLACK_WEBHOOK_URL;\nconst CRASH_SPIKE_THRESHOLD = Number(process.env.CANARY_CRASH_SPIKE || 0.005); // 0.5%\nconst MIN_SAMPLES = Number(process.env.CANARY_MIN_SAMPLES || 200);\n\n// File paths (generic - works with SSH/Nginx or local filesystem)\nconst RELEASES_DIR = process.env.RELEASES_DIR || '/var/www/downloads/rinawarp/releases';\nconst CANARY_DIR = path.join(RELEASES_DIR, 'canary');\nconst STABLE_DIR = path.join(RELEASES_DIR, 'stable');\nconst ROLLBACK_VERSION_FILE = path.join(RELEASES_DIR, 'rollback-version.json');\n\n/**\n * Send Slack notification\n */\nasync function postSlack(message) {\n  if (!SLACK_WEBHOOK_URL) {\n    console.log(' Slack webhook URL not configured, skipping alert');\n    return;\n  }\n\n  try {\n    await fetch(SLACK_WEBHOOK_URL, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ text: message }),\n    });\n    console.log(' Slack notification sent');\n  } catch (error) {\n    console.error('Failed to send Slack notification:', error);\n  }\n}\n\n/**\n * Pin canary feed to a specific version (rollback)\n */\nasync function pinCanaryToVersion(version) {\n  try {\n    console.log(` Pinning canary to version ${version}...`);\n\n    // Read stable metadata files to use as rollback target\n    const stableYml = path.join(STABLE_DIR, 'latest.yml');\n    const stableMacYml = path.join(STABLE_DIR, 'latest-mac.yml');\n\n    // Check if stable files exist\n    try {\n      await fs.access(stableYml);\n      await fs.access(stableMacYml);\n    } catch (error) {\n      throw new Error(`Stable files not found for rollback to ${version}`);\n    }\n\n    // Copy stable files to canary (effectively rolling back)\n    const canaryYml = path.join(CANARY_DIR, 'latest.yml');\n    const canaryMacYml = path.join(CANARY_DIR, 'latest-mac.yml');\n\n    const stableYmlContent = await fs.readFile(stableYml, 'utf8');\n    const stableMacYmlContent = await fs.readFile(stableMacYml, 'utf8');\n\n    // Update version in metadata to show it's a rollback\n    const canaryYmlContent = stableYmlContent.replace(\n      /version: .*/,\n      `version: ${version} (rollback)`,\n    );\n    const canaryMacYmlContent = stableMacYmlContent.replace(\n      /version: .*/,\n      `version: ${version} (rollback)`,\n    );\n\n    await fs.writeFile(canaryYml, canaryYmlContent);\n    await fs.writeFile(canaryMacYml, canaryMacYmlContent);\n\n    // Save rollback version for future reference\n    const rollbackData = {\n      version: version,\n      rollbackTime: new Date().toISOString(),\n      reason: 'crash spike',\n    };\n    await fs.writeFile(ROLLBACK_VERSION_FILE, JSON.stringify(rollbackData, null, 2));\n\n    console.log(` Rolled back canary to ${version}`);\n\n    // TODO: Add cache purge for latest*.yml files\n    // This depends on hosting method (CDN, nginx, etc.)\n  } catch (error) {\n    console.error('Failed to rollback canary:', error);\n    throw error;\n  }\n}\n\n/**\n * Get last known good canary version\n */\nasync function getLastKnownGoodVersion() {\n  try {\n    const rollbackData = JSON.parse(await fs.readFile(ROLLBACK_VERSION_FILE, 'utf8'));\n    return rollbackData.version;\n  } catch (error) {\n    // If no rollback file, fallback to current stable version\n    const stableYml = path.join(STABLE_DIR, 'latest.yml');\n    const stableContent = await fs.readFile(stableYml, 'utf8');\n    const versionMatch = stableContent.match(/version:\\s*(.+)/);\n    return versionMatch ? versionMatch[1].trim() : null;\n  }\n}\n\n/**\n * Check if canary has crash spike requiring rollback\n */\nfunction canaryHasCrashSpike(canary) {\n  // Check minimum sample size\n  if (canary.sampleCount < MIN_SAMPLES) {\n    console.log(\n      ` Canary sample count too low for crash analysis: ${canary.sampleCount} < ${MIN_SAMPLES}`,\n    );\n    return false;\n  }\n\n  // Check crash rate threshold\n  if (canary.crashRate >= CRASH_SPIKE_THRESHOLD) {\n    console.log(\n      ` Canary crash spike detected: ${(canary.crashRate * 100).toFixed(2)}% >= ${(CRASH_SPIKE_THRESHOLD * 100).toFixed(2)}%`,\n    );\n    return true;\n  }\n\n  console.log(\n    ` Canary crash rate acceptable: ${(canary.crashRate * 100).toFixed(3)}% < ${(CRASH_SPIKE_THRESHOLD * 100).toFixed(2)}%`,\n  );\n  return false;\n}\n\n/**\n * Main canary rollback job\n */\nexport async function runCanaryRollback() {\n  try {\n    console.log(' Checking canary crash spike...');\n\n    // Fetch telemetry summary\n    const response = await fetch(SUMMARY_URL, {\n      headers: { 'X-Dashboard-Token': DASHBOARD_TOKEN },\n    });\n\n    if (!response.ok) {\n      console.error(`Failed to fetch telemetry: ${response.status}`);\n      return;\n    }\n\n    const data = await response.json();\n    const cohorts = data.cohorts;\n    const latestCanaryVersion = data.latestCanaryVersion;\n\n    if (!cohorts || !latestCanaryVersion) {\n      console.log(' Missing required telemetry data');\n      return;\n    }\n\n    const canary = cohorts.canary;\n\n    if (!canary) {\n      console.log(' Missing canary cohort data');\n      return;\n    }\n\n    console.log(\n      ` Canary: ${canary.sampleCount} samples, ${(canary.crashRate * 100).toFixed(3)}% crash rate`,\n    );\n\n    // Check for crash spike\n    if (!canaryHasCrashSpike(canary)) {\n      console.log(' No crash spike detected');\n      return;\n    }\n\n    // Get rollback version\n    const rollbackTo = await getLastKnownGoodVersion();\n    if (!rollbackTo) {\n      console.error(' No rollback version available');\n      return;\n    }\n\n    // Execute rollback\n    const msg =\n      ` Canary crash spike detected (${(canary.crashRate * 100).toFixed(2)}%). ` +\n      `Rolling back ${latestCanaryVersion}  ${rollbackTo}`;\n\n    await postSlack(msg);\n    await pinCanaryToVersion(rollbackTo);\n\n    await postSlack(` Rolled back canary ${latestCanaryVersion}  ${rollbackTo}`);\n    console.log(' Canary rollback completed successfully');\n  } catch (error) {\n    console.error('Canary rollback job failed:', error);\n    await postSlack(` Canary rollback failed: ${error.message}`);\n  }\n}\n\n// Run if called directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  runCanaryRollback().catch(console.error);\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/license-abuse-service/abuse-detector.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'EventEmitter' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":11,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":138,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":138,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":145,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":145,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":158,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":158,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":174,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":174,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":180,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":180,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":238,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":238,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":242,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":242,"endColumn":12}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import crypto from 'crypto';\nimport { EventEmitter } from 'events';\n\n// In-memory storage (replace with database in production)\nconst licenseEvents = new Map(); // licenseKeyHash -> array of events\nconst licenseStates = new Map(); // licenseKeyHash -> state\n\n// Configuration\nconst ABUSE_THRESHOLD = 10;\nconst CLEAR_THRESHOLD = 5;\nconst SLACK_WEBHOOK_URL = process.env.SLACK_WEBHOOK_URL;\n\n// Abuse scoring rules (conservative)\nconst ABUSE_RULES = {\n  uniqueDevices24h: { threshold: 3, score: 4 },\n  uniqueIPs1h: { threshold: 5, score: 3 },\n  failedValidations10m: { threshold: 10, score: 5 },\n  totalDevicesLifetime: { threshold: 20, score: 10 },\n};\n\n// Privacy-safe hashing function\nfunction hashData(data) {\n  return crypto.createHash('sha256').update(data).digest('hex');\n}\n\n// Calculate abuse score based on behavior patterns\nfunction calculateAbuseScore(stats) {\n  let score = 0;\n\n  if (stats.uniqueDevices24h > ABUSE_RULES.uniqueDevices24h.threshold) {\n    score += ABUSE_RULES.uniqueDevices24h.score;\n  }\n\n  if (stats.uniqueIPs1h > ABUSE_RULES.uniqueIPs1h.threshold) {\n    score += ABUSE_RULES.uniqueIPs1h.score;\n  }\n\n  if (stats.failedValidations10m > ABUSE_RULES.failedValidations10m.threshold) {\n    score += ABUSE_RULES.failedValidations10m.score;\n  }\n\n  if (stats.totalDevicesLifetime > ABUSE_RULES.totalDevicesLifetime.threshold) {\n    score += ABUSE_RULES.totalDevicesLifetime.score;\n  }\n\n  return score;\n}\n\n// Get or create license state\nfunction getLicenseState(licenseKeyHash) {\n  if (!licenseStates.has(licenseKeyHash)) {\n    licenseStates.set(licenseKeyHash, {\n      licenseKeyHash,\n      abuseScore: 0,\n      quarantined: false,\n      quarantinedAt: null,\n      lastUpdated: new Date().toISOString(),\n    });\n  }\n  return licenseStates.get(licenseKeyHash);\n}\n\n// Calculate statistics for a license\nfunction calculateStats(licenseKeyHash) {\n  const events = licenseEvents.get(licenseKeyHash) || [];\n  const now = new Date();\n\n  // Time windows\n  const last24h = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n  const last1h = new Date(now.getTime() - 60 * 60 * 1000);\n  const last10m = new Date(now.getTime() - 10 * 60 * 1000);\n\n  // Filter events by time windows\n  const events24h = events.filter((e) => new Date(e.timestamp) > last24h);\n  const events1h = events.filter((e) => new Date(e.timestamp) > last1h);\n  const events10m = events.filter((e) => new Date(e.timestamp) > last10m);\n\n  // Calculate unique counts (privacy-safe with hashing)\n  const uniqueDevices24h = new Set(events24h.map((e) => e.deviceHash)).size;\n  const uniqueIPs1h = new Set(events1h.map((e) => e.ipHash)).size;\n  const totalDevicesLifetime = new Set(events.map((e) => e.deviceHash)).size;\n  const failedValidations10m = events10m.filter((e) => e.outcome === 'invalid').length;\n\n  return {\n    uniqueDevices24h,\n    uniqueIPs1h,\n    failedValidations10m,\n    totalDevicesLifetime,\n    totalEvents: events.length,\n  };\n}\n\n// Process license validation event\nexport function processLicenseEvent(licenseKey, deviceId, ip, outcome) {\n  const licenseKeyHash = hashData(licenseKey);\n  const deviceHash = hashData(deviceId);\n  const ipHash = hashData(ip);\n\n  // Store event\n  if (!licenseEvents.has(licenseKeyHash)) {\n    licenseEvents.set(licenseKeyHash, []);\n  }\n\n  const event = {\n    licenseKeyHash,\n    deviceHash,\n    ipHash,\n    outcome, // 'valid' | 'invalid' | 'offline'\n    timestamp: new Date().toISOString(),\n  };\n\n  licenseEvents.get(licenseKeyHash).push(event);\n\n  // Keep only recent events (30 days)\n  const cutoff = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n  const recentEvents = licenseEvents\n    .get(licenseKeyHash)\n    .filter((e) => new Date(e.timestamp) > cutoff);\n  licenseEvents.set(licenseKeyHash, recentEvents);\n\n  // Calculate stats and score\n  const stats = calculateStats(licenseKeyHash);\n  const abuseScore = calculateAbuseScore(stats);\n\n  // Update license state\n  const state = getLicenseState(licenseKeyHash);\n  state.abuseScore = abuseScore;\n  state.lastUpdated = new Date().toISOString();\n\n  // Check quarantine conditions\n  const shouldQuarantine = abuseScore >= ABUSE_THRESHOLD && !state.quarantined;\n  const shouldClear = abuseScore < CLEAR_THRESHOLD && state.quarantined;\n\n  if (shouldQuarantine) {\n    state.quarantined = true;\n    state.quarantinedAt = new Date().toISOString();\n    sendSlackAlert(licenseKeyHash, abuseScore, 'QUARANTINED', stats);\n    console.log(\n      ` License quarantined: ${licenseKeyHash.substring(0, 8)}... (Score: ${abuseScore})`,\n    );\n  } else if (shouldClear) {\n    state.quarantined = false;\n    state.quarantinedAt = null;\n    sendSlackAlert(licenseKeyHash, abuseScore, 'CLEARED', stats);\n    console.log(` License cleared: ${licenseKeyHash.substring(0, 8)}... (Score: ${abuseScore})`);\n  }\n\n  return {\n    quarantined: state.quarantined,\n    abuseScore: abuseScore,\n    reason: state.quarantined ? 'Suspicious usage detected' : null,\n  };\n}\n\n// Send Slack alert for quarantine events\nasync function sendSlackAlert(licenseKeyHash, score, action, stats) {\n  if (!SLACK_WEBHOOK_URL) {\n    console.log(' Slack webhook URL not configured, skipping alert');\n    return;\n  }\n\n  try {\n    const message = {\n      text:\n        ` *RinaWarp License ${action}*\\n` +\n        `License: \\`${licenseKeyHash.substring(0, 8)}...\\`\\n` +\n        `Score: ${score}\\n` +\n        `Devices (24h): ${stats.uniqueDevices24h}\\n` +\n        `IPs (1h): ${stats.uniqueIPs1h}\\n` +\n        `Failed (10m): ${stats.failedValidations10m}\\n` +\n        `Total devices: ${stats.totalDevicesLifetime}`,\n    };\n\n    await fetch(SLACK_WEBHOOK_URL, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(message),\n    });\n  } catch (error) {\n    console.error('Slack alert error:', error);\n  }\n}\n\n// Get license status for API response\nexport function getLicenseStatus(licenseKey) {\n  const licenseKeyHash = hashData(licenseKey);\n  const state = getLicenseState(licenseKeyHash);\n\n  return {\n    quarantined: state.quarantined,\n    abuseScore: state.abuseScore,\n    reason: state.quarantined ? 'Suspicious usage detected' : null,\n    lastUpdated: state.lastUpdated,\n  };\n}\n\n// Get abuse statistics for dashboard\nexport function getAbuseStatistics() {\n  const totalLicenses = licenseStates.size;\n  const quarantinedLicenses = Array.from(licenseStates.values()).filter(\n    (state) => state.quarantined,\n  ).length;\n\n  // Calculate cleared in last 24h\n  const now = new Date();\n  const last24h = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n  const cleared24h = Array.from(licenseStates.values()).filter(\n    (state) =>\n      state.quarantined &&\n      state.quarantinedAt &&\n      new Date(state.quarantinedAt) < last24h &&\n      state.abuseScore < CLEAR_THRESHOLD,\n  ).length;\n\n  return {\n    total: totalLicenses,\n    quarantined: quarantinedLicenses,\n    cleared24h: cleared24h,\n    quarantineRate:\n      totalLicenses > 0 ? ((quarantinedLicenses / totalLicenses) * 100).toFixed(2) : '0.00',\n  };\n}\n\n// Cleanup old data periodically\nexport function cleanupOldData() {\n  const cutoff = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n\n  for (const [licenseKeyHash, events] of licenseEvents.entries()) {\n    const recentEvents = events.filter((e) => new Date(e.timestamp) > cutoff);\n    if (recentEvents.length === 0) {\n      licenseEvents.delete(licenseKeyHash);\n      licenseStates.delete(licenseKeyHash);\n    } else {\n      licenseEvents.set(licenseKeyHash, recentEvents);\n    }\n  }\n\n  console.log(` Cleanup: ${licenseEvents.size} active licenses`);\n}\n\n// Run cleanup every hour\nsetInterval(cleanupOldData, 60 * 60 * 1000);\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/license-abuse-service/test-abuse-detection.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":12,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'status' is assigned a value but never used.","line":129,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":15}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { processLicenseEvent, getLicenseStatus, getAbuseStatistics } from './abuse-detector.js';\n\nconst tests = {\n  passed: 0,\n  failed: 0,\n  total: 0,\n};\n\nfunction log(message, type = 'info') {\n  const timestamp = new Date().toISOString();\n  const prefix = type === 'error' ? '' : type === 'success' ? '' : '';\n  console.log(`[${timestamp}] ${prefix} ${message}`);\n}\n\nfunction assert(condition, testName, expected, actual) {\n  tests.total++;\n  if (condition) {\n    tests.passed++;\n    log(`PASS: ${testName}`, 'success');\n    return true;\n  } else {\n    tests.failed++;\n    log(`FAIL: ${testName} - Expected: ${expected}, Got: ${actual}`, 'error');\n    return false;\n  }\n}\n\nasync function testLicenseAbuseDetection() {\n  log(' Testing License Abuse Detection System');\n  log('==========================================');\n\n  // Test 1: Normal license usage should not be quarantined\n  const normalLicense = 'test-license-normal-12345';\n  const status1 = processLicenseEvent(normalLicense, 'device1', '192.168.1.1', 'valid');\n  assert(\n    !status1.quarantined,\n    'Normal license usage should not be quarantined',\n    'not quarantined',\n    status1.quarantined ? 'quarantined' : 'not quarantined',\n  );\n  assert(\n    status1.abuseScore < 10,\n    'Normal usage should have low abuse score',\n    '< 10',\n    status1.abuseScore,\n  );\n\n  // Test 2: Multiple devices in 24h should increase score\n  for (let i = 2; i <= 5; i++) {\n    processLicenseEvent(normalLicense, `device${i}`, `192.168.1.${i}`, 'valid');\n  }\n  const status2 = getLicenseStatus(normalLicense);\n  assert(\n    status2.abuseScore >= 4,\n    'Multiple devices should increase score',\n    '>= 4',\n    status2.abuseScore,\n  );\n\n  // Test 3: Multiple IPs in 1h should increase score\n  for (let i = 1; i <= 6; i++) {\n    processLicenseEvent(normalLicense, 'device1', `10.0.0.${i}`, 'valid');\n  }\n  const status3 = getLicenseStatus(normalLicense);\n  assert(status3.abuseScore >= 7, 'Multiple IPs should increase score', '>= 7', status3.abuseScore);\n\n  // Test 4: Failed validations should increase score\n  for (let i = 1; i <= 11; i++) {\n    processLicenseEvent(normalLicense, 'device1', '192.168.1.1', 'invalid');\n  }\n  const status4 = getLicenseStatus(normalLicense);\n  assert(\n    status4.abuseScore >= 12,\n    'Failed validations should trigger quarantine',\n    '>= 12',\n    status4.abuseScore,\n  );\n  assert(\n    status4.quarantined,\n    'License should be quarantined with high score',\n    'quarantined',\n    status4.quarantined ? 'quarantined' : 'not quarantined',\n  );\n\n  // Test 5: Auto-clear should work when score drops\n  // Simulate time passing and score decreasing (this would normally happen with time-based decay)\n  const status5 = getLicenseStatus(normalLicense);\n  assert(\n    status5.quarantined === true,\n    'License should still be quarantined',\n    'true',\n    status5.quarantined,\n  );\n\n  // Test 6: Statistics should be accurate\n  const stats = getAbuseStatistics();\n  assert(stats.total >= 1, 'Statistics should count licenses', '>= 1', stats.total);\n  assert(\n    stats.quarantined >= 1,\n    'Statistics should count quarantined licenses',\n    '>= 1',\n    stats.quarantined,\n  );\n\n  log('==========================================');\n  log(\n    ` Abuse Detection Test Results: ${tests.passed}/${tests.total} passed, ${tests.failed} failed`,\n  );\n\n  if (tests.failed === 0) {\n    log(' ALL ABUSE DETECTION TESTS PASSED!', 'success');\n  } else {\n    log(' Some abuse detection tests failed.', 'error');\n  }\n}\n\n// Test privacy-safe hashing\nfunction testPrivacySafety() {\n  log(' Testing Privacy Safety');\n\n  const licenseKey = 'test-license-12345';\n  const deviceId = 'device-abc-123';\n  const ip = '192.168.1.100';\n\n  // These should all be hashed (no raw values should be stored)\n  processLicenseEvent(licenseKey, deviceId, ip, 'valid');\n\n  // Verify that raw values are not easily guessable from hashes\n  const status = getLicenseStatus(licenseKey);\n  log(`Privacy test: License status retrieved successfully without exposing raw data`);\n\n  return true;\n}\n\n// Run tests\nasync function runAllTests() {\n  try {\n    await testLicenseAbuseDetection();\n    testPrivacySafety();\n\n    log(' License Abuse Detection System Tests Complete');\n  } catch (error) {\n    log('Test suite error: ' + error.message, 'error');\n  }\n}\n\nrunAllTests();\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/license-reset-service/reset-handler.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":9,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":118,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":118,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":128,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":128,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":145,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":145,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":151,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":151,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":170,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":175,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":175,"endColumn":12}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import crypto from 'crypto';\nimport { processLicenseEvent, getLicenseStatus } from '../license-abuse-service/abuse-detector.js';\n\n// In-memory storage for reset tokens (replace with database in production)\nconst resetTokens = new Map(); // token -> { licenseKeyHash, expiresAt, used }\n\n// Configuration\nconst TOKEN_TTL_MINUTES = 15;\nconst SLACK_WEBHOOK_URL = process.env.SLACK_WEBHOOK_URL;\n\n/**\n * Privacy-safe hashing function\n */\nfunction hashData(data) {\n  return crypto.createHash('sha256').update(data).digest('hex');\n}\n\n/**\n * Generate secure reset token\n */\nfunction generateResetToken() {\n  return crypto.randomBytes(32).toString('hex');\n}\n\n/**\n * Create reset token for license\n */\nexport async function createResetToken(licenseKey, deviceId, email = null) {\n  const licenseKeyHash = hashData(licenseKey);\n\n  // Check if license exists and is quarantined\n  const licenseStatus = getLicenseStatus(licenseKey);\n  if (!licenseStatus.quarantined && licenseStatus.abuseScore < 5) {\n    throw new Error('License is not eligible for reset');\n  }\n\n  // Generate token\n  const token = generateResetToken();\n  const expiresAt = new Date(Date.now() + TOKEN_TTL_MINUTES * 60 * 1000);\n\n  // Store token\n  resetTokens.set(token, {\n    licenseKeyHash,\n    deviceHash: hashData(deviceId),\n    email: email ? hashData(email) : null,\n    expiresAt: expiresAt.toISOString(),\n    used: false,\n  });\n\n  // Send Slack notification\n  await sendSlackNotification('reset_requested', licenseKeyHash, email);\n\n  return {\n    token,\n    expiresAt: expiresAt.toISOString(),\n    ttlMinutes: TOKEN_TTL_MINUTES,\n  };\n}\n\n/**\n * Confirm and execute license reset\n */\nexport async function confirmReset(resetToken, deviceId) {\n  const tokenData = resetTokens.get(resetToken);\n\n  if (!tokenData) {\n    throw new Error('Invalid or expired reset token');\n  }\n\n  // Check expiration\n  if (new Date(tokenData.expiresAt) < new Date()) {\n    resetTokens.delete(resetToken);\n    throw new Error('Reset token has expired');\n  }\n\n  // Check if already used\n  if (tokenData.used) {\n    throw new Error('Reset token has already been used');\n  }\n\n  // Verify device matches (security check)\n  const currentDeviceHash = hashData(deviceId);\n  if (currentDeviceHash !== tokenData.deviceHash) {\n    throw new Error('Device mismatch - reset token is device-specific');\n  }\n\n  try {\n    // Mark token as used\n    tokenData.used = true;\n    tokenData.usedAt = new Date().toISOString();\n\n    // Execute license reset\n    // In a real implementation, you would:\n    // 1. Clear device bindings for this license\n    // 2. Reset abuse score\n    // 3. Remove from quarantine\n\n    // For now, we'll simulate by creating a \"reset\" event and clearing state\n    await processLicenseEvent(\n      'RESET-LICENSE-' + tokenData.licenseKeyHash, // Special marker\n      deviceId,\n      '127.0.0.1', // Reset source\n      'valid',\n    );\n\n    // Send Slack notification\n    await sendSlackNotification('reset_completed', tokenData.licenseKeyHash, tokenData.email);\n\n    // Clean up used token\n    resetTokens.delete(resetToken);\n\n    return {\n      success: true,\n      message: 'License reset completed successfully',\n      licenseKeyHash: tokenData.licenseKeyHash,\n    };\n  } catch (error) {\n    console.error('License reset failed:', error);\n    throw new Error('Failed to execute license reset');\n  }\n}\n\n/**\n * Send Slack notification\n */\nasync function sendSlackNotification(type, licenseKeyHash, emailHash) {\n  if (!SLACK_WEBHOOK_URL) {\n    console.log(' Slack webhook URL not configured, skipping notification');\n    return;\n  }\n\n  try {\n    let message;\n    switch (type) {\n      case 'reset_requested':\n        message = ` License reset requested\\nLicense: \\`${licenseKeyHash.substring(0, 8)}...\\`\\nEmail: ${emailHash ? `${emailHash.substring(0, 8)}...` : 'not provided'}\\nToken TTL: ${TOKEN_TTL_MINUTES} minutes`;\n        break;\n      case 'reset_completed':\n        message = ` License reset completed\\nLicense: \\`${licenseKeyHash.substring(0, 8)}...\\`\\nDevice: ${emailHash ? 'verified' : 'unverified'}`;\n        break;\n      default:\n        message = `License reset event: ${type}\\nLicense: \\`${licenseKeyHash.substring(0, 8)}...\\``;\n    }\n\n    await fetch(SLACK_WEBHOOK_URL, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ text: message }),\n    });\n  } catch (error) {\n    console.error('Failed to send Slack notification:', error);\n  }\n}\n\n/**\n * Clean up expired tokens periodically\n */\nexport function cleanupExpiredTokens() {\n  const now = new Date();\n  let cleaned = 0;\n\n  for (const [token, data] of resetTokens.entries()) {\n    if (new Date(data.expiresAt) < now || data.used) {\n      resetTokens.delete(token);\n      cleaned++;\n    }\n  }\n\n  if (cleaned > 0) {\n    console.log(` Cleaned up ${cleaned} expired/used reset tokens`);\n  }\n}\n\n// Run cleanup every 10 minutes\nsetInterval(cleanupExpiredTokens, 10 * 60 * 1000);\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/licensing-service/server.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":10,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":26,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":30,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":42,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used.","line":44,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":183,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":183,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":184,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":184,"endColumn":10}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport cors from 'cors';\nimport jwt from 'jsonwebtoken';\nimport dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\nconst app = express();\nconst PORT = process.env.LICENSE_SERVICE_PORT || 3003;\n\n// Middleware\napp.use(cors());\napp.use(express.json());\n\n// JWT verification middleware\nconst authenticateToken = (req, res, next) => {\n  try {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1];\n\n    if (!token) {\n      return res.status(401).json({ error: 'Token required' });\n    }\n\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret');\n    req.userId = decoded.userId;\n    next();\n  } catch (error) {\n    console.error('Token verification failed:', error.message);\n    res.status(403).json({ error: 'Invalid token' });\n  }\n};\n\n// Optional auth middleware for license check\nfunction optionalAuth(req, res, next) {\n  const auth = req.headers.authorization || '';\n  if (!auth.startsWith('Bearer ')) return next(); // allow anonymous for now\n\n  const token = auth.slice('Bearer '.length);\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret');\n    req.user = decoded;\n  } catch (err) {\n    // don't block, just mark invalid auth\n    req.user = null;\n  }\n  next();\n}\n\n// Mock license data for testing\nconst MOCK_LICENSE = {\n  id: 'license_123',\n  user_id: 'user_123',\n  license_type: 'pro',\n  status: 'active',\n  features: ['unlimited_videos', 'no_watermark', 'priority_support'],\n  expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days\n  created_at: new Date().toISOString(),\n};\n\n// Get user license\napp.get('/license', authenticateToken, (req, res) => {\n  // Return mock license for testing\n  res.json({ license: MOCK_LICENSE });\n});\n\n// Verify user has specific feature\napp.post('/verify-feature', authenticateToken, (req, res) => {\n  const { feature } = req.body;\n\n  if (!feature) {\n    return res.status(400).json({ error: 'Feature name required' });\n  }\n\n  const hasFeature = MOCK_LICENSE.features.includes(feature);\n\n  res.json({\n    hasFeature,\n    licenseType: MOCK_LICENSE.license_type,\n    features: MOCK_LICENSE.features,\n    expiresAt: MOCK_LICENSE.expires_at,\n  });\n});\n\n// Get license statistics\napp.get('/stats', authenticateToken, (req, res) => {\n  const stats = {\n    licenseType: MOCK_LICENSE.license_type,\n    features: MOCK_LICENSE.features,\n    expiresAt: MOCK_LICENSE.expires_at,\n    daysUntilExpiry: Math.ceil(\n      (new Date(MOCK_LICENSE.expires_at) - new Date()) / (1000 * 60 * 60 * 24),\n    ),\n    isExpiringSoon: new Date(MOCK_LICENSE.expires_at) - new Date() < 7 * 24 * 60 * 60 * 1000,\n  };\n\n  res.json({\n    hasActiveLicense: true,\n    stats,\n  });\n});\n\n// Health check\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'healthy',\n    service: 'license-service',\n    timestamp: new Date().toISOString(),\n  });\n});\n\n// License check endpoint\napp.post('/license/check', optionalAuth, express.json(), (req, res) => {\n  const { licenseKey } = req.body || {};\n\n  if (!licenseKey) {\n    return res.status(400).json({ error: \"Missing 'licenseKey' field\" });\n  }\n\n  //  TODO: replace this stub with real DB / Supabase lookup\n  // For now, simple pattern-based logic:\n  let status = 'invalid';\n  let plan = null;\n  let features = {\n    premiumMode: false,\n    maxDailyMessages: 0,\n  };\n\n  if (licenseKey.startsWith('DEV-LIFETIME')) {\n    status = 'valid';\n    plan = 'lifetime';\n    features = {\n      premiumMode: true,\n      maxDailyMessages: 2000,\n    };\n  } else if (licenseKey.startsWith('DEV-PRO')) {\n    status = 'valid';\n    plan = 'pro';\n    features = {\n      premiumMode: true,\n      maxDailyMessages: 999,\n    };\n  } else if (licenseKey.startsWith('DEV-CREATOR')) {\n    status = 'valid';\n    plan = 'creator';\n    features = {\n      premiumMode: true,\n      maxDailyMessages: 500,\n    };\n  } else if (licenseKey.startsWith('DEV-STARTER')) {\n    status = 'valid';\n    plan = 'starter';\n    features = {\n      premiumMode: true,\n      maxDailyMessages: 150,\n    };\n  } else if (licenseKey.startsWith('DEV-BASIC')) {\n    status = 'valid';\n    plan = 'basic';\n    features = {\n      premiumMode: false,\n      maxDailyMessages: 50,\n    };\n  } else if (licenseKey.startsWith('DEV-FREE')) {\n    status = 'valid';\n    plan = 'free';\n    features = {\n      premiumMode: false,\n      maxDailyMessages: 20,\n    };\n  }\n\n  return res.json({\n    status,\n    plan,\n    features,\n  });\n});\n\n// Start server\napp.listen(PORT, () => {\n  console.log(` License service running on port ${PORT}`);\n  console.log(`  Health check: http://localhost:${PORT}/health`);\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/live-sessions/worker.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":3,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":3,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":40,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":49,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":73,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used.","line":86,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":86,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":108,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":108,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":293,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":293,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":348,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":348,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":351,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":351,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":353,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":353,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'Request' is not defined.","line":365,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":365,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'user' is assigned a value but never used.","line":369,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":369,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used.","line":370,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":370,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":371,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":371,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'WebSocketPair' is not defined.","line":374,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":374,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":388,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":388,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":413,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":413,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":418,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":418,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":441,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":441,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":475,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":475,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":516,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":516,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":530,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":530,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":609,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":609,"endColumn":22}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    const { pathname } = url;\n\n    // Simple health check\n    if (pathname === '/api/live-session/health') {\n      return json({ ok: true, service: 'live-session-worker' });\n    }\n\n    // WebSocket endpoint\n    if (pathname.startsWith('/ws/live-session/')) {\n      return handleWebSocket(request, env, ctx);\n    }\n\n    // REST: create a new shared session (host)\n    if (pathname === '/api/live-session/create' && request.method === 'POST') {\n      return handleCreateSession(request, env);\n    }\n\n    // REST: join an existing session (guest)\n    if (pathname === '/api/live-session/join' && request.method === 'POST') {\n      return handleJoinSession(request, env);\n    }\n\n    // REST: get session summary\n    if (pathname.startsWith('/api/live-session/') && request.method === 'GET') {\n      const [, , , sessionId] = pathname.split('/');\n      if (!sessionId) return json({ error: 'Missing sessionId' }, 400);\n      return handleGetSession(sessionId, env);\n    }\n\n    // REST: get replayable events\n    if (pathname.startsWith('/api/live-session-events/') && request.method === 'GET') {\n      const [, , , sessionId] = pathname.split('/');\n      if (!sessionId) return json({ error: 'Missing sessionId' }, 400);\n      return handleGetSessionEvents(sessionId, request, env);\n    }\n\n    return new Response('Not found', { status: 404 });\n  },\n};\n\n/* \n * Helpers\n *  */\n\nfunction json(body, status = 200) {\n  return new Response(JSON.stringify(body, null, 2), {\n    status,\n    headers: { 'Content-Type': 'application/json' },\n  });\n}\n\nfunction nowMs() {\n  return Date.now();\n}\n\nclass AuthError extends Error {}\n\n//  TEMP: minimal JWT decode (no signature verify)\n// You can replace this with real verification later.\nfunction parseAuthOrThrow(request) {\n  const auth = request.headers.get('Authorization') || '';\n  if (!auth.startsWith('Bearer ')) {\n    throw new AuthError('Missing bearer token');\n  }\n  const token = auth.slice('Bearer '.length).trim();\n  const parts = token.split('.');\n  if (parts.length < 2) throw new AuthError('Invalid token');\n\n  try {\n    const payloadStr = atob(parts[1].replace(/-/g, '+').replace(/_/g, '/'));\n    const payload = JSON.parse(payloadStr);\n\n    if (!payload.sub || !payload.teamId) {\n      throw new AuthError('Missing user/team claims');\n    }\n\n    return {\n      userId: payload.sub,\n      teamId: payload.teamId,\n      name: payload.name || 'Unknown',\n      raw: payload,\n    };\n  } catch (err) {\n    throw new AuthError('Failed to decode token');\n  }\n}\n\n/* \n * REST: Create Session (host)\n *  */\n\nasync function handleCreateSession(request, env) {\n  let user;\n  try {\n    user = parseAuthOrThrow(request);\n  } catch (err) {\n    if (err instanceof AuthError) return json({ error: err.message }, 401);\n    throw err;\n  }\n\n  const body = await safeJson(request);\n  const title = body.title || 'Shared Terminal Session';\n  const description = body.description || '';\n  const settings = body.settings || {};\n  const sessionId = crypto.randomUUID();\n  const ts = nowMs();\n\n  // Insert session row\n  await env.DB.prepare(\n    `\n    INSERT INTO live_sessions (\n      id, team_id, host_user_id, host_name,\n      status, title, description, created_at, last_activity_at\n    )\n    VALUES (?, ?, ?, ?, 'active', ?, ?, ?, ?)\n  `,\n  )\n    .bind(sessionId, user.teamId, user.userId, user.name, title, description, ts, ts)\n    .run();\n\n  // Insert host participant\n  await env.DB.prepare(\n    `\n    INSERT INTO live_session_participants (\n      session_id, user_id, name, role, joined_at, last_seen_at\n    )\n    VALUES (?, ?, ?, 'host', ?, ?)\n  `,\n  )\n    .bind(sessionId, user.userId, user.name, ts, ts)\n    .run();\n\n  // Cache session state in KV\n  await env.LIVE_SESSIONS.put(\n    `session:${sessionId}`,\n    JSON.stringify({\n      sessionId,\n      teamId: user.teamId,\n      hostUserId: user.userId,\n      hostName: user.name,\n      status: 'active',\n      lastActivityAt: ts,\n    }),\n    { expirationTtl: 60 * 60 },\n  );\n\n  // Log event\n  await logEvent(env, sessionId, {\n    kind: 'meta',\n    actorUserId: user.userId,\n    actorName: user.name,\n    payload: {\n      type: 'session_created',\n      title,\n      description,\n      settings,\n    },\n  });\n\n  const wsUrl = buildWsUrl(\n    request,\n    sessionId,\n    'host',\n    request.headers.get('Authorization')?.replace('Bearer ', ''),\n  );\n\n  return json({\n    ok: true,\n    sessionId,\n    role: 'host',\n    wsUrl,\n  });\n}\n\n/* \n * REST: Join Session (guest)\n *  */\n\nasync function handleJoinSession(request, env) {\n  let user;\n  try {\n    user = parseAuthOrThrow(request);\n  } catch (err) {\n    if (err instanceof AuthError) return json({ error: err.message }, 401);\n    throw err;\n  }\n\n  const body = await safeJson(request);\n  const sessionId = body.sessionId;\n  if (!sessionId) return json({ error: 'Missing sessionId' }, 400);\n\n  const session = await env.DB.prepare(`SELECT * FROM live_sessions WHERE id = ?`)\n    .bind(sessionId)\n    .first();\n\n  if (!session) return json({ error: 'Session not found' }, 404);\n  if (session.status !== 'active') return json({ error: 'Session is not active' }, 400);\n\n  // Enforce same team\n  if (session.team_id !== user.teamId) {\n    return json({ error: 'Not authorized for this team session' }, 403);\n  }\n\n  const ts = nowMs();\n\n  await env.DB.prepare(\n    `\n    INSERT INTO live_session_participants (\n      session_id, user_id, name, role, joined_at, last_seen_at\n    )\n    VALUES (?, ?, ?, 'guest', ?, ?)\n  `,\n  )\n    .bind(sessionId, user.userId, user.name, ts, ts)\n    .run();\n\n  await env.DB.prepare(`UPDATE live_sessions SET last_activity_at = ? WHERE id = ?`)\n    .bind(ts, sessionId)\n    .run();\n\n  await env.LIVE_SESSIONS.put(\n    `session:${sessionId}`,\n    JSON.stringify({\n      sessionId,\n      teamId: session.team_id,\n      hostUserId: session.host_user_id,\n      hostName: session.host_name,\n      status: 'active',\n      lastActivityAt: ts,\n    }),\n    { expirationTtl: 60 * 60 },\n  );\n\n  await logEvent(env, sessionId, {\n    kind: 'join',\n    actorUserId: user.userId,\n    actorName: user.name,\n    payload: { role: 'guest' },\n  });\n\n  const wsUrl = buildWsUrl(\n    request,\n    sessionId,\n    'guest',\n    request.headers.get('Authorization')?.replace('Bearer ', ''),\n  );\n\n  return json({\n    ok: true,\n    sessionId,\n    role: 'guest',\n    wsUrl,\n  });\n}\n\n/* \n * REST: Get Session Summary\n *  */\n\nasync function handleGetSession(sessionId, env) {\n  const session = await env.DB.prepare(`SELECT * FROM live_sessions WHERE id = ?`)\n    .bind(sessionId)\n    .first();\n\n  if (!session) return json({ error: 'Session not found' }, 404);\n\n  const participants = await env.DB.prepare(\n    `\n    SELECT user_id, name, role, joined_at, last_seen_at, left_at\n    FROM live_session_participants\n    WHERE session_id = ?\n    ORDER BY joined_at ASC\n  `,\n  )\n    .bind(sessionId)\n    .all();\n\n  return json({\n    ok: true,\n    session,\n    participants: participants.results || [],\n  });\n}\n\n/* \n * REST: Get Session Events (replay)\n *  */\n\nasync function handleGetSessionEvents(sessionId, request, env) {\n  const url = new URL(request.url);\n  const limit = Math.min(parseInt(url.searchParams.get('limit') || '200', 10), 1000);\n  const beforeTs = parseInt(url.searchParams.get('beforeTs') || '0', 10);\n\n  let query = `\n    SELECT id, ts, actor_user_id, actor_name, kind, payload\n    FROM live_session_events\n    WHERE session_id = ?\n  `;\n  const params = [sessionId];\n\n  if (beforeTs > 0) {\n    query += ' AND ts < ? ';\n    params.push(beforeTs);\n  }\n\n  query += ' ORDER BY ts DESC LIMIT ? ';\n  params.push(limit);\n\n  const events = await env.DB.prepare(query)\n    .bind(...params)\n    .all();\n\n  return json({\n    ok: true,\n    sessionId,\n    events: (events.results || []).map((e) => ({\n      id: e.id,\n      ts: e.ts,\n      actorUserId: e.actor_user_id,\n      actorName: e.actor_name,\n      kind: e.kind,\n      payload: safeParseJson(e.payload),\n    })),\n  });\n}\n\n/* \n * WebSocket: live stream\n *  */\n\n// In-memory registry per worker instance\n// For true global state youd move this to Durable Objects\nconst sessionSockets = new Map(); // sessionId  { host: WebSocket|null, guests: Set<WebSocket> }\n\nfunction getSessionState(sessionId) {\n  if (!sessionSockets.has(sessionId)) {\n    sessionSockets.set(sessionId, { host: null, guests: new Set() });\n  }\n  return sessionSockets.get(sessionId);\n}\n\nfunction handleWebSocket(request, env, ctx) {\n  const upgradeHeader = request.headers.get('Upgrade') || '';\n  if (upgradeHeader.toLowerCase() !== 'websocket') {\n    return new Response('Expected WebSocket', { status: 426 });\n  }\n\n  const url = new URL(request.url);\n  const [, , , sessionId] = url.pathname.split('/');\n  if (!sessionId) return new Response('Missing sessionId', { status: 400 });\n\n  const role = url.searchParams.get('role') || 'guest';\n\n  // --- AUTH CHECK FOR WEBSOCKET -------------------------------------\n  let user;\n  try {\n    // WS connections can't send Authorization header reliably,\n    // so we accept token in query param: ?token=XYZ\n    const token = url.searchParams.get('token');\n    if (!token) throw new AuthError('Missing auth token');\n\n    const fakeAuthHeader = new Request(request.url, {\n      headers: { Authorization: `Bearer ${token}` },\n    });\n\n    user = parseAuthOrThrow(fakeAuthHeader);\n  } catch (err) {\n    return new Response('Unauthorized WebSocket', { status: 401 });\n  }\n\n  const pair = new WebSocketPair();\n  const client = pair[0];\n  const server = pair[1];\n\n  const ts = nowMs();\n\n  server.accept();\n\n  const state = getSessionState(sessionId);\n\n  if (role === 'host') {\n    if (state.host) {\n      server.send(JSON.stringify({ type: 'error', message: 'Host already connected' }));\n      server.close(1013, 'Host already connected');\n      return new Response(null, { status: 101, webSocket: client });\n    }\n    state.host = server;\n  } else {\n    state.guests.add(server);\n  }\n\n  server.send(JSON.stringify({ type: 'hello', sessionId, role, ts }));\n\n  server.addEventListener('message', (event) =>\n    handleWsMessage(event, { server, role, sessionId, env }),\n  );\n\n  server.addEventListener('close', () => handleWsClose({ server, role, sessionId }));\n\n  // Lightweight keepalive marker in KV\n  ctx.waitUntil(\n    (async () => {\n      try {\n        await env.LIVE_SESSIONS.put(\n          `session:${sessionId}`,\n          JSON.stringify({ sessionId, lastPing: nowMs() }),\n          { expirationTtl: 60 * 60 },\n        );\n      } catch (err) {\n        console.error('KV keepalive error', err);\n      }\n    })(),\n  );\n\n  return new Response(null, { status: 101, webSocket: client });\n}\n\nasync function handleWsMessage(event, { server, role, sessionId, env }) {\n  let msg;\n  try {\n    msg = JSON.parse(event.data);\n  } catch {\n    server.send(JSON.stringify({ type: 'error', message: 'Invalid JSON' }));\n    return;\n  }\n\n  const kind = msg.type;\n\n  // Host sends PTY output  broadcast to guests\n  if (kind === 'pty_output' && role === 'host') {\n    const data = msg.data || '';\n    const state = getSessionState(sessionId);\n\n    for (const guest of state.guests) {\n      try {\n        guest.send(JSON.stringify({ type: 'pty_output', data }));\n      } catch (err) {\n        console.error('Broadcast to guest failed', err);\n      }\n    }\n\n    await logEvent(env, sessionId, {\n      kind: 'pty_output',\n      actorUserId: msg.actorUserId || null,\n      actorName: msg.actorName || null,\n      payload: { data },\n    });\n\n    await env.DB.prepare(`UPDATE live_sessions SET last_activity_at = ? WHERE id = ?`)\n      .bind(nowMs(), sessionId)\n      .run();\n\n    return;\n  }\n\n  // Guest sends PTY input  forward to host\n  if (kind === 'pty_input' && role === 'guest') {\n    const data = msg.data || '';\n    const state = getSessionState(sessionId);\n\n    if (state.host) {\n      try {\n        state.host.send(\n          JSON.stringify({\n            type: 'pty_input',\n            data,\n            fromUserId: msg.actorUserId || null,\n            fromUserName: msg.actorName || null,\n          }),\n        );\n      } catch (err) {\n        console.error('Forward to host failed', err);\n      }\n\n      await logEvent(env, sessionId, {\n        kind: 'pty_input',\n        actorUserId: msg.actorUserId || null,\n        actorName: msg.actorName || null,\n        payload: { data },\n      });\n\n      await env.DB.prepare(`UPDATE live_sessions SET last_activity_at = ? WHERE id = ?`)\n        .bind(nowMs(), sessionId)\n        .run();\n    } else {\n      server.send(\n        JSON.stringify({\n          type: 'error',\n          message: 'Host is not connected',\n        }),\n      );\n    }\n\n    return;\n  }\n\n  // Meta messages (cursor, typing, presence etc.)\n  if (kind === 'meta') {\n    const state = getSessionState(sessionId);\n    const payload = msg.payload || {};\n\n    if (role === 'host') {\n      for (const guest of state.guests) {\n        try {\n          guest.send(\n            JSON.stringify({\n              type: 'meta',\n              payload,\n              from: 'host',\n            }),\n          );\n        } catch (err) {\n          console.error('Meta to guest failed', err);\n        }\n      }\n    } else {\n      if (state.host) {\n        try {\n          state.host.send(\n            JSON.stringify({\n              type: 'meta',\n              payload,\n              from: 'guest',\n            }),\n          );\n        } catch (err) {\n          console.error('Meta to host failed', err);\n        }\n      }\n    }\n\n    await logEvent(env, sessionId, {\n      kind: 'meta',\n      actorUserId: msg.actorUserId || null,\n      actorName: msg.actorName || null,\n      payload,\n    });\n\n    return;\n  }\n\n  server.send(\n    JSON.stringify({\n      type: 'error',\n      message: `Unknown message type: ${kind}`,\n    }),\n  );\n}\n\nfunction handleWsClose({ server, role, sessionId }) {\n  const state = getSessionState(sessionId);\n  if (role === 'host') {\n    if (state.host === server) {\n      state.host = null;\n    }\n  } else {\n    state.guests.delete(server);\n  }\n\n  if (!state.host && state.guests.size === 0) {\n    sessionSockets.delete(sessionId);\n  }\n}\n\n/* \n * Event logging to D1\n *  */\n\nasync function logEvent(env, sessionId, { kind, actorUserId, actorName, payload }) {\n  const ts = nowMs();\n  const payloadJson = JSON.stringify(payload || {});\n\n  await env.DB.prepare(\n    `\n    INSERT INTO live_session_events (\n      session_id, ts, actor_user_id, actor_name, kind, payload\n    )\n    VALUES (?, ?, ?, ?, ?, ?)\n  `,\n  )\n    .bind(sessionId, ts, actorUserId || null, actorName || null, kind, payloadJson)\n    .run();\n}\n\n/* \n * Misc utils\n *  */\n\nasync function safeJson(request) {\n  try {\n    return await request.json();\n  } catch {\n    return {};\n  }\n}\n\nfunction safeParseJson(str) {\n  try {\n    return JSON.parse(str);\n  } catch {\n    return null;\n  }\n}\n\nfunction buildWsUrl(request, sessionId, role, token) {\n  const url = new URL(request.url);\n  const wsProto = url.protocol === 'https:' ? 'wss:' : 'ws:';\n  return `${wsProto}//${url.host}/ws/live-session/${sessionId}?role=${role}&token=${token}`;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/stripe-secure/licenses.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Buffer' is not defined.","line":30,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'iv' is assigned a value but never used.","line":47,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Buffer' is not defined.","line":50,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":50,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'Buffer' is not defined.","line":51,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'Buffer' is not defined.","line":53,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":41}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import crypto from 'crypto';\n\n/**\n * Generate a tamper-resistant license key\n * Format: RWTP-XXXX-XXXX-XXXX-XXXX-XXXX\n */\nexport function generateLicenseKey() {\n  // 20 bytes => 40 hex chars => strong entropy\n  const raw = crypto.randomBytes(20).toString('hex').toUpperCase();\n  // Split into 5 groups of 4 characters\n  return `RWTP-${raw\n    .match(/.{1,4}/g)\n    .slice(0, 5)\n    .join('-')}`;\n}\n\n/**\n * Hash license key for secure storage\n */\nexport function hashLicenseKey(key) {\n  return crypto.createHash('sha256').update(key).digest('hex');\n}\n\n/**\n * Encrypt license key for storage (AES-256-GCM)\n */\nexport function encryptLicenseKey(key, secret) {\n  const iv = crypto.randomBytes(12);\n  const cipher = crypto.createCipher('aes-256-gcm', secret);\n  cipher.setAAD(Buffer.from('rinawarp-license'));\n\n  let encrypted = cipher.update(key, 'utf8');\n  cipher.final();\n  const authTag = cipher.getAuthTag();\n\n  return {\n    encrypted: encrypted.toString('hex'),\n    iv: iv.toString('hex'),\n    authTag: authTag.toString('hex'),\n  };\n}\n\n/**\n * Decrypt license key from storage\n */\nexport function decryptLicenseKey(encryptedData, secret) {\n  const { encrypted, iv, authTag } = encryptedData;\n\n  const decipher = crypto.createDecipher('aes-256-gcm', secret);\n  decipher.setAAD(Buffer.from('rinawarp-license'));\n  decipher.setAuthTag(Buffer.from(authTag, 'hex'));\n\n  let decrypted = decipher.update(Buffer.from(encrypted, 'hex'));\n  decipher.final();\n\n  return decrypted.toString('utf8');\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/stripe-secure/webhook.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":5,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":9,"column":6,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":12,"column":6,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'eventId' is defined but never used.","line":30,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":42,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'encryptedLicense' is defined but never used.","line":50,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'tier' is defined but never used.","line":51,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":51,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'stripePaymentIntentId' is defined but never used.","line":53,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":53,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":57,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sessionId' is defined but never used.","line":63,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":63,"endColumn":47},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":78,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":85,"column":59,"nodeType":"Identifier","messageId":"undef","endLine":85,"endColumn":66},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":87,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":87,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":93,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":100,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":100,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":111,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":111,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":121,"column":62,"nodeType":"Identifier","messageId":"undef","endLine":121,"endColumn":69},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":132,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":132,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":143,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":143,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":150,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":156,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":156,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":162,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":162,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":168,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":168,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":174,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":174,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":185,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":185,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":221,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":221,"endColumn":12}],"suppressedMessages":[],"errorCount":26,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Stripe from 'stripe';\nimport express from 'express';\nimport { generateLicenseKey, hashLicenseKey, encryptLicenseKey } from './licenses.js';\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\nconst router = express.Router();\n\n// CRITICAL: Environment validation - fail fast if missing\nif (!process.env.STRIPE_WEBHOOK_SECRET) {\n  throw new Error('Missing STRIPE_WEBHOOK_SECRET - webhook verification impossible');\n}\nif (!process.env.STRIPE_SECRET_KEY) {\n  throw new Error('Missing STRIPE_SECRET_KEY - Stripe operations impossible');\n}\n\n// Allowed event types - strict allowlist\nconst ALLOWED_EVENTS = new Set([\n  'checkout.session.completed',\n  'checkout.session.expired',\n  'customer.subscription.created',\n  'customer.subscription.updated',\n  'customer.subscription.deleted',\n  'invoice.paid',\n  'invoice.payment_failed',\n]);\n\n/**\n * Check if event was already processed (idempotency)\n */\nasync function wasEventProcessed(eventId) {\n  // Implement with your database\n  // Return true if eventId exists in processed_events table\n  return false; // Placeholder\n}\n\n/**\n * Mark event as processed\n */\nasync function markEventProcessed(eventId) {\n  // Insert eventId into processed_events table\n  // Use unique constraint to prevent duplicates\n  console.log(`Marking event ${eventId} as processed`);\n}\n\n/**\n * Create license record with encrypted key\n */\nasync function createLicense({\n  licenseHash,\n  encryptedLicense,\n  tier,\n  stripeSessionId,\n  stripePaymentIntentId,\n}) {\n  // Insert into licenses table\n  // Fields: license_hash, license_key_encrypted, tier, stripe_session_id, created_at\n  console.log(`Creating license: ${licenseHash} for session ${stripeSessionId}`);\n}\n\n/**\n * Get license by Stripe session ID for reveal\n */\nasync function getLicenseBySessionId(sessionId) {\n  // Query licenses table by stripe_session_id\n  // Return: { licenseKey, tier, licenseHash }\n  return null; // Placeholder\n}\n\n/**\n * HARDENED WEBHOOK ENDPOINT\n * This implements all security requirements\n */\nrouter.post('/webhook', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n\n  // Validate signature header exists\n  if (!sig) {\n    console.error('Missing Stripe-Signature header');\n    return res.status(400).send('Missing Stripe-Signature header');\n  }\n\n  let event;\n  try {\n    // Verify webhook signature using raw body\n    event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET);\n  } catch (err) {\n    console.error('Webhook signature verification failed:', err.message);\n    return res.status(400).send(`Webhook signature verification failed: ${err.message}`);\n  }\n\n  // IDEMPOTENCY: Check if we've already processed this event\n  if (await wasEventProcessed(event.id)) {\n    console.log(`Duplicate event ignored: ${event.id}`);\n    return res.status(200).json({ received: true, deduped: true });\n  }\n\n  try {\n    // STRICT ALLOWLIST: Only handle expected event types\n    if (!ALLOWED_EVENTS.has(event.type)) {\n      console.log(`Ignoring unhandled event type: ${event.type}`);\n      await markEventProcessed(event.id);\n      return res.status(200).json({ received: true, ignored: event.type });\n    }\n\n    // Handle checkout completion\n    if (event.type === 'checkout.session.completed') {\n      const session = event.data.object;\n\n      // CRITICAL: Verify payment status - only fulfill paid sessions\n      if (session.payment_status !== 'paid') {\n        console.log(`Skipping unpaid session: ${session.id}`);\n        await markEventProcessed(event.id);\n        return res.status(200).json({ received: true, skipped: 'not_paid' });\n      }\n\n      // Generate secure license key\n      const licenseKey = generateLicenseKey();\n      const licenseHash = hashLicenseKey(licenseKey);\n\n      // Encrypt license key for storage\n      const encryptedLicense = encryptLicenseKey(licenseKey, process.env.LICENSE_ENCRYPTION_SECRET);\n\n      // Create license record\n      await createLicense({\n        licenseHash,\n        encryptedLicense,\n        tier: 'pro',\n        stripeSessionId: session.id,\n        stripePaymentIntentId: session.payment_intent || null,\n      });\n\n      console.log(` License created for session ${session.id}: ${licenseKey}`);\n\n      // Mark event as processed (prevents Stripe retries)\n      await markEventProcessed(event.id);\n\n      // Return 200 immediately - don't do slow work\n      return res.status(200).json({ received: true });\n    }\n\n    // Handle expired sessions\n    if (event.type === 'checkout.session.expired') {\n      console.log(`Session expired: ${event.data.object.id}`);\n      await markEventProcessed(event.id);\n      return res.status(200).json({ received: true, expired: true });\n    }\n\n    // Handle subscription events\n    if (event.type === 'customer.subscription.created') {\n      console.log(`Subscription created: ${event.data.object.id}`);\n      await markEventProcessed(event.id);\n      return res.status(200).json({ received: true, subscription_created: true });\n    }\n\n    if (event.type === 'customer.subscription.updated') {\n      console.log(`Subscription updated: ${event.data.object.id}`);\n      await markEventProcessed(event.id);\n      return res.status(200).json({ received: true, subscription_updated: true });\n    }\n\n    if (event.type === 'customer.subscription.deleted') {\n      console.log(`Subscription deleted: ${event.data.object.id}`);\n      await markEventProcessed(event.id);\n      return res.status(200).json({ received: true, subscription_deleted: true });\n    }\n\n    if (event.type === 'invoice.paid') {\n      console.log(`Invoice paid: ${event.data.object.id}`);\n      await markEventProcessed(event.id);\n      return res.status(200).json({ received: true, invoice_paid: true });\n    }\n\n    if (event.type === 'invoice.payment_failed') {\n      console.log(`Invoice payment failed: ${event.data.object.id}`);\n      await markEventProcessed(event.id);\n      return res.status(200).json({ received: true, payment_failed: true });\n    }\n\n    // Mark all other events as processed to prevent retries\n    await markEventProcessed(event.id);\n    return res.status(200).json({ received: true, handled: event.type });\n  } catch (err) {\n    // CRITICAL: Log error but return 500 to trigger Stripe retries\n    // This ensures we don't lose events if there's a temporary failure\n    console.error('Webhook handler error:', err);\n    return res.status(500).send('Webhook handler error');\n  }\n});\n\n/**\n * License reveal endpoint for success page\n */\nrouter.get('/license/reveal', async (req, res) => {\n  const { session_id } = req.query;\n\n  if (!session_id) {\n    return res.status(400).json({ error: 'Missing session_id' });\n  }\n\n  try {\n    // Verify session exists and is paid in Stripe\n    const session = await stripe.checkout.sessions.retrieve(session_id);\n\n    if (!session || session.payment_status !== 'paid') {\n      return res.status(403).json({ error: 'Invalid or unpaid session' });\n    }\n\n    // Get license from database\n    const license = await getLicenseBySessionId(session_id);\n\n    if (!license) {\n      return res.status(404).json({ error: 'License not found' });\n    }\n\n    // Return license key for display\n    return res.json({\n      licenseKey: license.licenseKey,\n      tier: license.tier,\n    });\n  } catch (err) {\n    console.error('License reveal error:', err);\n    return res.status(500).json({ error: 'Failed to retrieve license' });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/backend/website-integration/hooks/useAuth.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":14,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":22,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":38,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":39,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":59,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":75,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":75,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":76,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":93,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":94,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":94,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":97,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":97,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":108,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":108,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":109,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":109,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":117,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":117,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":119,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":119,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":120,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":120,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":131,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":131,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":137,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":152,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":152,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":153,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":153,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":183,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":183,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":191,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":191,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":209,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":209,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":213,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":213,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'refreshError' is defined but never used.","line":223,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":223,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":229,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":229,"endColumn":16}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useContext, createContext } from 'react';\n\n// Auth context\nconst AuthContext = createContext();\n\n// Auth provider component\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [license, setLicense] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // API base URL - this should match your API gateway URL\n  const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000';\n\n  // Login function\n  const login = async (email, password) => {\n    try {\n      setError(null);\n      setLoading(true);\n\n      const response = await fetch(`${API_BASE_URL}/auth/login`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        credentials: 'include',\n        body: JSON.stringify({ email, password }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new Error(data.error || 'Login failed');\n      }\n\n      // Store tokens\n      localStorage.setItem('accessToken', data.accessToken);\n      localStorage.setItem('refreshToken', data.refreshToken);\n\n      setUser(data.user);\n      setLicense(data.license);\n\n      return { success: true };\n    } catch (error) {\n      setError(error.message);\n      return { success: false, error: error.message };\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Register function\n  const register = async (email, password, firstName, lastName) => {\n    try {\n      setError(null);\n      setLoading(true);\n\n      const response = await fetch(`${API_BASE_URL}/auth/register`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        credentials: 'include',\n        body: JSON.stringify({ email, password, firstName, lastName }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new Error(data.error || 'Registration failed');\n      }\n\n      // Store tokens\n      localStorage.setItem('accessToken', data.accessToken);\n      localStorage.setItem('refreshToken', data.refreshToken);\n\n      setUser(data.user);\n      setLicense(data.license);\n\n      return { success: true };\n    } catch (error) {\n      setError(error.message);\n      return { success: false, error: error.message };\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Logout function\n  const logout = async () => {\n    try {\n      const accessToken = localStorage.getItem('accessToken');\n      const refreshToken = localStorage.getItem('refreshToken');\n\n      if (accessToken) {\n        await fetch(`${API_BASE_URL}/auth/logout`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${accessToken}`,\n          },\n          body: JSON.stringify({ accessToken, refreshToken }),\n        });\n      }\n\n      // Clear local storage\n      localStorage.removeItem('accessToken');\n      localStorage.removeItem('refreshToken');\n\n      setUser(null);\n      setLicense(null);\n      setError(null);\n\n      return { success: true };\n    } catch (error) {\n      console.error('Logout error:', error);\n      // Even if logout request fails, clear local state\n      localStorage.removeItem('accessToken');\n      localStorage.removeItem('refreshToken');\n      setUser(null);\n      setLicense(null);\n      setError(null);\n      return { success: true };\n    }\n  };\n\n  // Refresh token function\n  const refreshToken = async () => {\n    try {\n      const refreshTokenValue = localStorage.getItem('refreshToken');\n\n      if (!refreshTokenValue) {\n        throw new Error('No refresh token available');\n      }\n\n      const response = await fetch(`${API_BASE_URL}/auth/refresh`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ refreshToken: refreshTokenValue }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new Error(data.error || 'Token refresh failed');\n      }\n\n      // Update stored tokens\n      localStorage.setItem('accessToken', data.accessToken);\n      localStorage.setItem('refreshToken', data.refreshToken);\n\n      return data.accessToken;\n    } catch (error) {\n      // If refresh fails, logout user\n      await logout();\n      throw error;\n    }\n  };\n\n  // Check if user has specific feature\n  const hasFeature = (feature) => {\n    if (!license || !license.features) return false;\n    return license.features.includes(feature);\n  };\n\n  // Check if user has any active license\n  const hasActiveLicense = () => {\n    return license && license.status === 'active';\n  };\n\n  // Get license type\n  const getLicenseType = () => {\n    return license ? license.license_type : null;\n  };\n\n  // Initialize auth state on app load\n  useEffect(() => {\n    const initializeAuth = async () => {\n      try {\n        const accessToken = localStorage.getItem('accessToken');\n\n        if (!accessToken) {\n          setLoading(false);\n          return;\n        }\n\n        // Verify token with server\n        const response = await fetch(`${API_BASE_URL}/auth/verify`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${accessToken}`,\n          },\n        });\n\n        const data = await response.json();\n\n        if (data.valid) {\n          setUser(data.user);\n          setLicense(data.license);\n        } else {\n          // Token invalid, try to refresh\n          try {\n            await refreshToken();\n            // If refresh successful, get updated user data\n            const refreshResponse = await fetch(`${API_BASE_URL}/auth/verify`, {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${localStorage.getItem('accessToken')}`,\n              },\n            });\n\n            const refreshData = await refreshResponse.json();\n\n            if (refreshData.valid) {\n              setUser(refreshData.user);\n              setLicense(refreshData.license);\n            }\n          } catch (refreshError) {\n            // Refresh failed, logout user\n            await logout();\n          }\n        }\n      } catch (error) {\n        console.error('Auth initialization error:', error);\n        await logout();\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    initializeAuth();\n  }, []);\n\n  const value = {\n    user,\n    license,\n    loading,\n    error,\n    login,\n    register,\n    logout,\n    refreshToken,\n    hasFeature,\n    hasActiveLicense,\n    getLicenseType,\n  };\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n};\n\n// Custom hook to use auth context\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/config/templates/config.loader.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":4,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":4,"endColumn":19},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'require' is not defined.","line":5,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":8,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":8,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":26,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":31,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'module' is not defined.","line":34,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":7}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Central config loader (template)\n// Usage: import validateConfig from '../config/templates/config.loader'\n\nconst fs = require('fs');\nconst path = require('path');\n\nfunction loadEnvFile(fileName) {\n  const fullPath = path.join(process.cwd(), fileName);\n  if (!fs.existsSync(fullPath)) return {};\n  const content = fs.readFileSync(fullPath, 'utf8');\n  return Object.fromEntries(\n    content\n      .split(/\\r?\\n/)\n      .filter(Boolean)\n      .map((line) => {\n        const idx = line.indexOf('=');\n        if (idx === -1) return [line.trim(), ''];\n        const key = line.trim();\n        const val = line.slice(idx + 1).trim();\n        return [key, val];\n      }),\n  );\n}\n\nfunction loadConfig() {\n  const env = process.env.APP_ENV || 'development';\n  const base = loadEnvFile('.env');\n  const specific =\n    env === 'production' ? loadEnvFile('.env.production') : loadEnvFile('.env.development');\n\n  return { ...base, ...specific, ...process.env };\n}\n\nmodule.exports = {\n  loadConfig,\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/docs/internal/.docusaurus/client-modules.js","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/docs/internal/.docusaurus/registry.js","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/karina/Documents/rinawarp-business/docs/internal/docusaurus.config.js","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]